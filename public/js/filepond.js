/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/filepond.js":
/*!**********************************!*\
  !*** ./resources/js/filepond.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! filepond */ \"./node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond-plugin-file-validate-type */ \"./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\");\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! filepond-plugin-file-validate-size */ \"./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\");\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var filepond_plugin_image_exif_orientation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! filepond-plugin-image-exif-orientation */ \"./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js\");\n/* harmony import */ var filepond_plugin_image_exif_orientation__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_exif_orientation__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! filepond-plugin-image-preview */ \"./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js\");\n/* harmony import */ var filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var filepond_plugin_image_crop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! filepond-plugin-image-crop */ \"./node_modules/filepond-plugin-image-crop/dist/filepond-plugin-image-crop.js\");\n/* harmony import */ var filepond_plugin_image_crop__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_crop__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var filepond_plugin_image_resize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! filepond-plugin-image-resize */ \"./node_modules/filepond-plugin-image-resize/dist/filepond-plugin-image-resize.js\");\n/* harmony import */ var filepond_plugin_image_resize__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_resize__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var filepond_plugin_image_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! filepond-plugin-image-transform */ \"./node_modules/filepond-plugin-image-transform/dist/filepond-plugin-image-transform.js\");\n/* harmony import */ var filepond_plugin_image_transform__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_transform__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var filepond_plugin_image_edit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! filepond-plugin-image-edit */ \"./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.js\");\n/* harmony import */ var filepond_plugin_image_edit__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_edit__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var filepond_plugin_file_encode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! filepond-plugin-file-encode */ \"./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js\");\n/* harmony import */ var filepond_plugin_file_encode__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_encode__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var filepond_plugin_image_preview_dist_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css */ \"./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\");\n/* harmony import */ var filepond_plugin_image_edit_dist_filepond_plugin_image_edit_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css */ \"./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css\");\n// Import FilePond\n // Import the plugin code\n\n\n\n\n\n\n\n\n\n // Import the plugin styles\n\n\n // Import the plugin styles\n\n$(document).ready(function () {\n  var dataUrl; // Register the plugin\n\n  filepond__WEBPACK_IMPORTED_MODULE_0__.registerPlugin((filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_2___default()), (filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1___default()), (filepond_plugin_image_exif_orientation__WEBPACK_IMPORTED_MODULE_3___default()), (filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_4___default()), (filepond_plugin_image_crop__WEBPACK_IMPORTED_MODULE_5___default()), (filepond_plugin_image_resize__WEBPACK_IMPORTED_MODULE_6___default()), (filepond_plugin_image_transform__WEBPACK_IMPORTED_MODULE_7___default()), (filepond_plugin_image_edit__WEBPACK_IMPORTED_MODULE_8___default()), (filepond_plugin_file_encode__WEBPACK_IMPORTED_MODULE_9___default())); // Portfolio\n\n  var portfolioPond = filepond__WEBPACK_IMPORTED_MODULE_0__.create(document.querySelector('#portfolioFiles'));\n  sessionStorage.setItem(\"portfolioUpload\", 0);\n  portfolioPond.setOptions({\n    labelIdle: 'Hineinziehen oder <span class=\"filepond--label-action\">durchsuchen</span>',\n    maxFiles: 6,\n    required: false,\n    allowMultiple: true,\n    allowFileEncode: true,\n    allowFileTypeValidation: true,\n    allowProcess: false,\n    maxFileSize: \"100MB\",\n    labelMaxFileSizeExceeded: \"Die Datei ist zu gross.\",\n    labelMaxTotalFileSize: 'maximal erlaubte Dateigrösse: {filesize}',\n    acceptedFileTypes: [\"image/*\"]\n  }); // wenn eine Datei dem Upload hinzugefügt wird\n\n  portfolioPond.onaddfile = function (err, item) {\n    if (err) {\n      return;\n    } else {\n      var dataUrl = item.getFileEncodeDataURL();\n      var filename = item.filename;\n      $.ajax({\n        url: '/addTempPortfolioUpload',\n        headers: {\n          'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n        },\n        type: 'POST',\n        data: {\n          'file': dataUrl,\n          'filename': filename\n        },\n        success: function success(res) {\n          /*console.log(res);*/\n        },\n        failure: function failure(res) {\n          /*console.log(res);*/\n        }\n      });\n      sessionStorage.setItem(\"portfolioUpload\", 1);\n    }\n  }; // wenn eine Datei vom Upload entfernt wird\n\n\n  portfolioPond.onremovefile = function (err, item) {\n    var files = portfolioPond.getFiles();\n\n    if (err) {\n      return;\n    } else {\n      var filename = item.filename;\n      $.ajax({\n        url: '/deleteTempPortfolioUpload',\n        headers: {\n          'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n        },\n        type: 'POST',\n        data: {\n          'filename': filename\n        },\n        success: function success(res) {\n          /*console.log(res);*/\n        },\n        failure: function failure(res) {\n          /*console.log(res);*/\n        }\n      });\n\n      if (files == 0) {\n        sessionStorage.setItem(\"portfolioUpload\", 0);\n      }\n    }\n  }; // Job Anhang\n\n\n  var jobAttachmentPond = filepond__WEBPACK_IMPORTED_MODULE_0__.create(document.querySelector('#jobFiles'));\n  jobAttachmentPond.setOptions({\n    labelIdle: 'Hineinziehen oder <span class=\"filepond--label-action\">durchsuchen</span>',\n    maxFiles: 6,\n    required: false,\n    allowMultiple: true,\n    allowFileEncode: true,\n    allowFileTypeValidation: true,\n    allowProcess: true,\n    maxFileSize: \"100MB\",\n    labelMaxFileSizeExceeded: \"Die Datei ist zu gross.\",\n    labelMaxTotalFileSize: 'maximal erlaubte Dateigrösse: {filesize}',\n    acceptedFileTypes: [\"application/docx\", \"application/pdf\", \"application/doc\", \"image/*\"]\n  });\n  sessionStorage.setItem(\"jobAttachmentUpload\", 0); // wenn eine Datei dem Upload hinzugefügt wird\n\n  jobAttachmentPond.onaddfile = function (err, item) {\n    if (err) {\n      return;\n    } else {\n      var dataUrl = item.getFileEncodeDataURL();\n      var filename = item.filename;\n      $.ajax({\n        url: '/storeTempJobAttachments',\n        headers: {\n          'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n        },\n        type: 'POST',\n        data: {\n          'file': dataUrl,\n          'filename': filename\n        },\n        success: function success(res) {\n          /*console.log(res);*/\n        },\n        failure: function failure(res) {\n          /*console.log(res);*/\n        }\n      });\n      sessionStorage.setItem(\"jobAttachmentUpload\", 1);\n    }\n  }; // wenn eine Datei vom Upload entfernt wird\n\n\n  jobAttachmentPond.onremovefile = function (err, item) {\n    var files = jobAttachmentPond.getFiles();\n\n    if (err) {\n      return;\n    } else {\n      var filename = item.filename;\n      $.ajax({\n        url: '/deleteTempJobAttachments',\n        headers: {\n          'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n        },\n        type: 'POST',\n        data: {\n          'filename': filename\n        },\n        success: function success(res) {\n          /*console.log(res);*/\n        },\n        failure: function failure(res) {\n          /*console.log(res);*/\n        }\n      });\n\n      if (files == 0) {\n        sessionStorage.setItem(\"jobAttachmentUpload\", 0);\n      }\n    }\n  }; // Profilbild\n\n\n  sessionStorage.setItem(\"profileUpload\", 0);\n  var profileImagePond = filepond__WEBPACK_IMPORTED_MODULE_0__.create(document.querySelector('#image'));\n  profileImagePond.setOptions({\n    labelIdle: 'Hineinziehen oder <span class=\"filepond--label-action\">durchsuchen</span>',\n    allowImageCrop: true,\n    allowMultiple: false,\n    imagePreviewHeight: 50,\n    imageCropAspectRatio: '1:1',\n    imageResizeTargetWidth: 200,\n    imageResizeTargetHeight: 200,\n    imageResizeMode: 'cover',\n    stylePanelLayout: 'compact circle',\n    styleLoadIndicatorPosition: 'center bottom',\n    styleProgressIndicatorPosition: 'right bottom',\n    styleButtonRemoveItemPosition: 'right top',\n    styleButtonProcessItemPosition: 'right bottom',\n    allowImageEdit: true,\n    styleImageEditButtonEditItemPosition: '\tbottom center',\n    allowFileEncode: true,\n    server: {\n      url: '/profileImage',\n      headers: {\n        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n      }\n    },\n    headers: {\n      'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n    }\n  }); // Request encoded data\n\n  profileImagePond.onaddfile = function (err, item) {\n    if (err) {\n      $(\"button[type='submit']\").attr(\"disabled\", true); //console.warn(err);\n\n      $(\"#image-feedback\").fadeIn();\n      return;\n    } else {\n      $(\"button[type='submit']\").removeAttr(\"disabled\");\n      $(\"#image-feedback\").fadeOut();\n      dataUrl = item.getFileEncodeDataURL();\n      sessionStorage.setItem(\"profileUpload\", 1);\n    }\n  }; // Request encoded data\n\n\n  profileImagePond.onremovefile = function (err, item) {\n    if (err) {\n      //console.warn(err);\n      $(\"button[type='submit']\").attr(\"disabled\", true);\n      return;\n    } else {\n      $(\"button[type='submit']\").removeAttr(\"disabled\");\n      $(\"#image-feedback\").fadeOut();\n      sessionStorage.setItem(\"profileUpload\", 0);\n    }\n  }; // SVA\n\n\n  var svaPond = filepond__WEBPACK_IMPORTED_MODULE_0__.create(document.querySelector('#sva'));\n  svaPond.setOptions({\n    labelIdle: 'Hineinziehen oder <span class=\"filepond--label-action\">durchsuchen</span>',\n    allowMultiple: false,\n    allowFileEncode: true,\n    required: true,\n    allowFileTypeValidation: true,\n    maxFileSize: \"100MB\",\n    labelMaxFileSizeExceeded: \"Die Datei ist zu gross.\",\n    labelMaxTotalFileSize: 'maximal erlaubte Dateigrösse: {filesize}',\n    acceptedFileTypes: [\"application/pdf\"],\n    server: {\n      url: '/sva',\n      headers: {\n        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n      }\n    },\n    headers: {\n      'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n    }\n  }); // Request encoded data\n\n  svaPond.onaddfile = function (err, item) {\n    if (err) {\n      $(\"button[type='submit']\").attr(\"disabled\", true); //console.warn(err);\n\n      $(\"#sva-feedback\").fadeIn();\n      return;\n    } else {\n      $(\"button[type='submit']\").removeAttr(\"disabled\");\n      $(\"#sva-feedback\").fadeOut();\n      dataUrl = item.getFileEncodeDataURL();\n      $(\"#svaBase64String\").val(dataUrl);\n    }\n  }; // Request encoded data\n\n\n  svaPond.onremovefile = function (err, item) {\n    if (err) {\n      //console.warn(err);\n      $(\"button[type='submit']\").attr(\"disabled\", true);\n      return;\n    } else {\n      $(\"button[type='submit']\").removeAttr(\"disabled\");\n      $(\"#sva-feedback\").fadeOut();\n      $(\"#svaBase64String\").val(\"\");\n    }\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvZmlsZXBvbmQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtDQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtDQUlBOztBQUVBVSxDQUFDLENBQUNDLFFBQUQsQ0FBRCxDQUFZQyxLQUFaLENBQWtCLFlBQVc7QUFDN0IsTUFBSUMsT0FBSixDQUQ2QixDQUU3Qjs7QUFDSWIsRUFBQUEsb0RBQUEsQ0FDSUUsMkVBREosRUFFSUQsMkVBRkosRUFHSUUsK0VBSEosRUFJSUMsc0VBSkosRUFLSUMsbUVBTEosRUFNSUMscUVBTkosRUFPSUMsd0VBUEosRUFRSUMsbUVBUkosRUFTSUMsb0VBVEosRUFIeUIsQ0FlekI7O0FBQ0EsTUFBTU0sYUFBYSxHQUFHZiw0Q0FBQSxDQUFpQlcsUUFBUSxDQUFDTSxhQUFULENBQXVCLGlCQUF2QixDQUFqQixDQUF0QjtBQUNBQyxFQUFBQSxjQUFjLENBQUNDLE9BQWYsQ0FBdUIsaUJBQXZCLEVBQTBDLENBQTFDO0FBRUFKLEVBQUFBLGFBQWEsQ0FBQ0ssVUFBZCxDQUF5QjtBQUNyQkMsSUFBQUEsU0FBUyxFQUFFLDJFQURVO0FBRXJCQyxJQUFBQSxRQUFRLEVBQUUsQ0FGVztBQUdyQkMsSUFBQUEsUUFBUSxFQUFFLEtBSFc7QUFJckJDLElBQUFBLGFBQWEsRUFBRSxJQUpNO0FBS3JCQyxJQUFBQSxlQUFlLEVBQUMsSUFMSztBQU1yQkMsSUFBQUEsdUJBQXVCLEVBQUUsSUFOSjtBQU9yQkMsSUFBQUEsWUFBWSxFQUFDLEtBUFE7QUFRckJDLElBQUFBLFdBQVcsRUFBQyxPQVJTO0FBU3JCQyxJQUFBQSx3QkFBd0IsRUFBRSx5QkFUTDtBQVVyQkMsSUFBQUEscUJBQXFCLEVBQUUsMENBVkY7QUFXckJDLElBQUFBLGlCQUFpQixFQUFDLENBQUMsU0FBRDtBQVhHLEdBQXpCLEVBbkJ5QixDQWtDekI7O0FBQ0FoQixFQUFBQSxhQUFhLENBQUNpQixTQUFkLEdBQTBCLFVBQUNDLEdBQUQsRUFBTUMsSUFBTixFQUFlO0FBQ3JDLFFBQUlELEdBQUosRUFBUztBQUNMO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSXBCLE9BQU8sR0FBR3FCLElBQUksQ0FBQ0Msb0JBQUwsRUFBZDtBQUNBLFVBQUlDLFFBQVEsR0FBR0YsSUFBSSxDQUFDRSxRQUFwQjtBQUNBMUIsTUFBQUEsQ0FBQyxDQUFDMkIsSUFBRixDQUFPO0FBQ0hDLFFBQUFBLEdBQUcsRUFBRyx5QkFESDtBQUVIQyxRQUFBQSxPQUFPLEVBQUU7QUFBQywwQkFBZ0I3QixDQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QjhCLElBQTdCLENBQWtDLFNBQWxDO0FBQWpCLFNBRk47QUFHSEMsUUFBQUEsSUFBSSxFQUFHLE1BSEo7QUFJSEMsUUFBQUEsSUFBSSxFQUFHO0FBQUUsa0JBQVE3QixPQUFWO0FBQW1CLHNCQUFZdUI7QUFBL0IsU0FKSjtBQUtITyxRQUFBQSxPQUFPLEVBQUUsaUJBQVVDLEdBQVYsRUFBZTtBQUFDO0FBQXVCLFNBTDdDO0FBTUhDLFFBQUFBLE9BQU8sRUFBRSxpQkFBU0QsR0FBVCxFQUFjO0FBQUM7QUFBc0I7QUFOM0MsT0FBUDtBQVNBMUIsTUFBQUEsY0FBYyxDQUFDQyxPQUFmLENBQXVCLGlCQUF2QixFQUEwQyxDQUExQztBQUNIO0FBQ0osR0FqQkQsQ0FuQ3lCLENBc0R6Qjs7O0FBQ0FKLEVBQUFBLGFBQWEsQ0FBQytCLFlBQWQsR0FBNEIsVUFBQ2IsR0FBRCxFQUFNQyxJQUFOLEVBQWU7QUFDdkMsUUFBSWEsS0FBSyxHQUFHaEMsYUFBYSxDQUFDaUMsUUFBZCxFQUFaOztBQUNBLFFBQUlmLEdBQUosRUFBUztBQUNMO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSUcsUUFBUSxHQUFHRixJQUFJLENBQUNFLFFBQXBCO0FBQ0ExQixNQUFBQSxDQUFDLENBQUMyQixJQUFGLENBQU87QUFDSEMsUUFBQUEsR0FBRyxFQUFHLDRCQURIO0FBRUhDLFFBQUFBLE9BQU8sRUFBRTtBQUFDLDBCQUFnQjdCLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCOEIsSUFBN0IsQ0FBa0MsU0FBbEM7QUFBakIsU0FGTjtBQUdIQyxRQUFBQSxJQUFJLEVBQUcsTUFISjtBQUlIQyxRQUFBQSxJQUFJLEVBQUc7QUFBQyxzQkFBWU47QUFBYixTQUpKO0FBS0hPLFFBQUFBLE9BQU8sRUFBRSxpQkFBVUMsR0FBVixFQUFlO0FBQUM7QUFBdUIsU0FMN0M7QUFNSEMsUUFBQUEsT0FBTyxFQUFFLGlCQUFTRCxHQUFULEVBQWM7QUFBQztBQUFzQjtBQU4zQyxPQUFQOztBQVNBLFVBQUdHLEtBQUssSUFBSSxDQUFaLEVBQWM7QUFDVjdCLFFBQUFBLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QixpQkFBdkIsRUFBMEMsQ0FBMUM7QUFDSDtBQUNKO0FBQ0osR0FuQkQsQ0F2RHlCLENBNEV6Qjs7O0FBQ0EsTUFBTThCLGlCQUFpQixHQUFHakQsNENBQUEsQ0FBaUJXLFFBQVEsQ0FBQ00sYUFBVCxDQUF1QixXQUF2QixDQUFqQixDQUExQjtBQUNBZ0MsRUFBQUEsaUJBQWlCLENBQUM3QixVQUFsQixDQUE2QjtBQUN6QkMsSUFBQUEsU0FBUyxFQUFFLDJFQURjO0FBRXpCQyxJQUFBQSxRQUFRLEVBQUUsQ0FGZTtBQUd6QkMsSUFBQUEsUUFBUSxFQUFFLEtBSGU7QUFJekJDLElBQUFBLGFBQWEsRUFBRSxJQUpVO0FBS3pCQyxJQUFBQSxlQUFlLEVBQUMsSUFMUztBQU16QkMsSUFBQUEsdUJBQXVCLEVBQUUsSUFOQTtBQU96QkMsSUFBQUEsWUFBWSxFQUFDLElBUFk7QUFRekJDLElBQUFBLFdBQVcsRUFBQyxPQVJhO0FBU3pCQyxJQUFBQSx3QkFBd0IsRUFBRSx5QkFURDtBQVV6QkMsSUFBQUEscUJBQXFCLEVBQUUsMENBVkU7QUFXekJDLElBQUFBLGlCQUFpQixFQUFDLENBQUMsa0JBQUQsRUFBb0IsaUJBQXBCLEVBQXNDLGlCQUF0QyxFQUF5RCxTQUF6RDtBQVhPLEdBQTdCO0FBY0FiLEVBQUFBLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QixxQkFBdkIsRUFBOEMsQ0FBOUMsRUE1RnlCLENBOEZ6Qjs7QUFDQThCLEVBQUFBLGlCQUFpQixDQUFDakIsU0FBbEIsR0FBOEIsVUFBQ0MsR0FBRCxFQUFNQyxJQUFOLEVBQWU7QUFDekMsUUFBSUQsR0FBSixFQUFTO0FBQ0w7QUFDSCxLQUZELE1BRU87QUFDSCxVQUFJcEIsT0FBTyxHQUFHcUIsSUFBSSxDQUFDQyxvQkFBTCxFQUFkO0FBQ0EsVUFBSUMsUUFBUSxHQUFHRixJQUFJLENBQUNFLFFBQXBCO0FBQ0ExQixNQUFBQSxDQUFDLENBQUMyQixJQUFGLENBQU87QUFDSEMsUUFBQUEsR0FBRyxFQUFHLDBCQURIO0FBRUhDLFFBQUFBLE9BQU8sRUFBRTtBQUFDLDBCQUFnQjdCLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCOEIsSUFBN0IsQ0FBa0MsU0FBbEM7QUFBakIsU0FGTjtBQUdIQyxRQUFBQSxJQUFJLEVBQUcsTUFISjtBQUlIQyxRQUFBQSxJQUFJLEVBQUc7QUFBRSxrQkFBUTdCLE9BQVY7QUFBbUIsc0JBQVl1QjtBQUEvQixTQUpKO0FBS0hPLFFBQUFBLE9BQU8sRUFBRSxpQkFBVUMsR0FBVixFQUFlO0FBQUM7QUFBdUIsU0FMN0M7QUFNSEMsUUFBQUEsT0FBTyxFQUFFLGlCQUFTRCxHQUFULEVBQWM7QUFBQztBQUFzQjtBQU4zQyxPQUFQO0FBU0ExQixNQUFBQSxjQUFjLENBQUNDLE9BQWYsQ0FBdUIscUJBQXZCLEVBQThDLENBQTlDO0FBQ0g7QUFDSixHQWpCRCxDQS9GeUIsQ0FrSHpCOzs7QUFDQThCLEVBQUFBLGlCQUFpQixDQUFDSCxZQUFsQixHQUFnQyxVQUFDYixHQUFELEVBQU1DLElBQU4sRUFBZTtBQUMzQyxRQUFJYSxLQUFLLEdBQUdFLGlCQUFpQixDQUFDRCxRQUFsQixFQUFaOztBQUNBLFFBQUlmLEdBQUosRUFBUztBQUNMO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSUcsUUFBUSxHQUFHRixJQUFJLENBQUNFLFFBQXBCO0FBQ0ExQixNQUFBQSxDQUFDLENBQUMyQixJQUFGLENBQU87QUFDSEMsUUFBQUEsR0FBRyxFQUFHLDJCQURIO0FBRUhDLFFBQUFBLE9BQU8sRUFBRTtBQUFDLDBCQUFnQjdCLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCOEIsSUFBN0IsQ0FBa0MsU0FBbEM7QUFBakIsU0FGTjtBQUdIQyxRQUFBQSxJQUFJLEVBQUcsTUFISjtBQUlIQyxRQUFBQSxJQUFJLEVBQUc7QUFBQyxzQkFBWU47QUFBYixTQUpKO0FBS0hPLFFBQUFBLE9BQU8sRUFBRSxpQkFBVUMsR0FBVixFQUFlO0FBQUM7QUFBdUIsU0FMN0M7QUFNSEMsUUFBQUEsT0FBTyxFQUFFLGlCQUFTRCxHQUFULEVBQWM7QUFBQztBQUFzQjtBQU4zQyxPQUFQOztBQVNBLFVBQUdHLEtBQUssSUFBSSxDQUFaLEVBQWM7QUFDVjdCLFFBQUFBLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QixxQkFBdkIsRUFBOEMsQ0FBOUM7QUFDSDtBQUNKO0FBQ0osR0FuQkQsQ0FuSHlCLENBd0l6Qjs7O0FBQ0FELEVBQUFBLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QixlQUF2QixFQUF3QyxDQUF4QztBQUNBLE1BQU0rQixnQkFBZ0IsR0FBR2xELDRDQUFBLENBQWlCVyxRQUFRLENBQUNNLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBakIsQ0FBekI7QUFDQWlDLEVBQUFBLGdCQUFnQixDQUFDOUIsVUFBakIsQ0FBNEI7QUFDeEJDLElBQUFBLFNBQVMsRUFBRSwyRUFEYTtBQUV4QjhCLElBQUFBLGNBQWMsRUFBQyxJQUZTO0FBR3hCM0IsSUFBQUEsYUFBYSxFQUFDLEtBSFU7QUFJeEI0QixJQUFBQSxrQkFBa0IsRUFBRSxFQUpJO0FBS3hCQyxJQUFBQSxvQkFBb0IsRUFBRSxLQUxFO0FBTXhCQyxJQUFBQSxzQkFBc0IsRUFBRSxHQU5BO0FBT3hCQyxJQUFBQSx1QkFBdUIsRUFBRSxHQVBEO0FBUXhCQyxJQUFBQSxlQUFlLEVBQUMsT0FSUTtBQVN4QkMsSUFBQUEsZ0JBQWdCLEVBQUUsZ0JBVE07QUFVeEJDLElBQUFBLDBCQUEwQixFQUFFLGVBVko7QUFXeEJDLElBQUFBLDhCQUE4QixFQUFFLGNBWFI7QUFZeEJDLElBQUFBLDZCQUE2QixFQUFFLFdBWlA7QUFheEJDLElBQUFBLDhCQUE4QixFQUFFLGNBYlI7QUFjeEJDLElBQUFBLGNBQWMsRUFBQyxJQWRTO0FBZXhCQyxJQUFBQSxvQ0FBb0MsRUFBQyxnQkFmYjtBQWdCeEJ0QyxJQUFBQSxlQUFlLEVBQUMsSUFoQlE7QUFpQnhCdUMsSUFBQUEsTUFBTSxFQUFFO0FBQ0oxQixNQUFBQSxHQUFHLEVBQUUsZUFERDtBQUVKQyxNQUFBQSxPQUFPLEVBQUU7QUFDTCx3QkFBZ0I3QixDQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QjhCLElBQTdCLENBQWtDLFNBQWxDO0FBRFg7QUFGTCxLQWpCZ0I7QUF1QnhCRCxJQUFBQSxPQUFPLEVBQUU7QUFDTCxzQkFBZ0I3QixDQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QjhCLElBQTdCLENBQWtDLFNBQWxDO0FBRFg7QUF2QmUsR0FBNUIsRUEzSXlCLENBd0t6Qjs7QUFDQVUsRUFBQUEsZ0JBQWdCLENBQUNsQixTQUFqQixHQUE2QixVQUFDQyxHQUFELEVBQU1DLElBQU4sRUFBZTtBQUV4QyxRQUFJRCxHQUFKLEVBQVM7QUFDTHZCLE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCOEIsSUFBM0IsQ0FBZ0MsVUFBaEMsRUFBNEMsSUFBNUMsRUFESyxDQUVMOztBQUNBOUIsTUFBQUEsQ0FBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUJ1RCxNQUFyQjtBQUNBO0FBQ0gsS0FMRCxNQUtPO0FBQ0h2RCxNQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQndELFVBQTNCLENBQXNDLFVBQXRDO0FBQ0F4RCxNQUFBQSxDQUFDLENBQUMsaUJBQUQsQ0FBRCxDQUFxQnlELE9BQXJCO0FBQ0F0RCxNQUFBQSxPQUFPLEdBQUdxQixJQUFJLENBQUNDLG9CQUFMLEVBQVY7QUFDQWpCLE1BQUFBLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QixlQUF2QixFQUF3QyxDQUF4QztBQUNIO0FBRUosR0FkRCxDQXpLeUIsQ0F5THpCOzs7QUFDQStCLEVBQUFBLGdCQUFnQixDQUFDSixZQUFqQixHQUErQixVQUFDYixHQUFELEVBQU1DLElBQU4sRUFBZTtBQUMxQyxRQUFJRCxHQUFKLEVBQVM7QUFDTDtBQUNBdkIsTUFBQUEsQ0FBQyxDQUFDLHVCQUFELENBQUQsQ0FBMkI4QixJQUEzQixDQUFnQyxVQUFoQyxFQUE0QyxJQUE1QztBQUNBO0FBQ0gsS0FKRCxNQUlPO0FBQ0g5QixNQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQndELFVBQTNCLENBQXNDLFVBQXRDO0FBQ0F4RCxNQUFBQSxDQUFDLENBQUMsaUJBQUQsQ0FBRCxDQUFxQnlELE9BQXJCO0FBQ0FqRCxNQUFBQSxjQUFjLENBQUNDLE9BQWYsQ0FBdUIsZUFBdkIsRUFBd0MsQ0FBeEM7QUFDSDtBQUVKLEdBWEQsQ0ExTHlCLENBdU16Qjs7O0FBQ0EsTUFBTWlELE9BQU8sR0FBR3BFLDRDQUFBLENBQWlCVyxRQUFRLENBQUNNLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBakIsQ0FBaEI7QUFDQW1ELEVBQUFBLE9BQU8sQ0FBQ2hELFVBQVIsQ0FBbUI7QUFDZkMsSUFBQUEsU0FBUyxFQUFFLDJFQURJO0FBRWZHLElBQUFBLGFBQWEsRUFBQyxLQUZDO0FBR2ZDLElBQUFBLGVBQWUsRUFBQyxJQUhEO0FBSWZGLElBQUFBLFFBQVEsRUFBRSxJQUpLO0FBS2ZHLElBQUFBLHVCQUF1QixFQUFFLElBTFY7QUFNZkUsSUFBQUEsV0FBVyxFQUFDLE9BTkc7QUFPZkMsSUFBQUEsd0JBQXdCLEVBQUUseUJBUFg7QUFRZkMsSUFBQUEscUJBQXFCLEVBQUUsMENBUlI7QUFTZkMsSUFBQUEsaUJBQWlCLEVBQUMsQ0FBQyxpQkFBRCxDQVRIO0FBVWZpQyxJQUFBQSxNQUFNLEVBQUU7QUFDSjFCLE1BQUFBLEdBQUcsRUFBRSxNQUREO0FBRUpDLE1BQUFBLE9BQU8sRUFBRTtBQUNMLHdCQUFnQjdCLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCOEIsSUFBN0IsQ0FBa0MsU0FBbEM7QUFEWDtBQUZMLEtBVk87QUFnQmZELElBQUFBLE9BQU8sRUFBRTtBQUNMLHNCQUFnQjdCLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCOEIsSUFBN0IsQ0FBa0MsU0FBbEM7QUFEWDtBQWhCTSxHQUFuQixFQXpNeUIsQ0ErTnpCOztBQUNBNEIsRUFBQUEsT0FBTyxDQUFDcEMsU0FBUixHQUFvQixVQUFDQyxHQUFELEVBQU1DLElBQU4sRUFBZTtBQUUvQixRQUFJRCxHQUFKLEVBQVM7QUFDTHZCLE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCOEIsSUFBM0IsQ0FBZ0MsVUFBaEMsRUFBNEMsSUFBNUMsRUFESyxDQUVMOztBQUNBOUIsTUFBQUEsQ0FBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQnVELE1BQW5CO0FBQ0E7QUFDSCxLQUxELE1BS087QUFDSHZELE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCd0QsVUFBM0IsQ0FBc0MsVUFBdEM7QUFDQXhELE1BQUFBLENBQUMsQ0FBQyxlQUFELENBQUQsQ0FBbUJ5RCxPQUFuQjtBQUNBdEQsTUFBQUEsT0FBTyxHQUFHcUIsSUFBSSxDQUFDQyxvQkFBTCxFQUFWO0FBQ0F6QixNQUFBQSxDQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQjJELEdBQXRCLENBQTBCeEQsT0FBMUI7QUFDSDtBQUNKLEdBYkQsQ0FoT3lCLENBK096Qjs7O0FBQ0F1RCxFQUFBQSxPQUFPLENBQUN0QixZQUFSLEdBQXNCLFVBQUNiLEdBQUQsRUFBTUMsSUFBTixFQUFlO0FBQ2pDLFFBQUlELEdBQUosRUFBUztBQUNMO0FBQ0F2QixNQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQjhCLElBQTNCLENBQWdDLFVBQWhDLEVBQTRDLElBQTVDO0FBQ0E7QUFDSCxLQUpELE1BSU87QUFDSDlCLE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCd0QsVUFBM0IsQ0FBc0MsVUFBdEM7QUFDQXhELE1BQUFBLENBQUMsQ0FBQyxlQUFELENBQUQsQ0FBbUJ5RCxPQUFuQjtBQUNBekQsTUFBQUEsQ0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0IyRCxHQUF0QixDQUEwQixFQUExQjtBQUNIO0FBQ0osR0FWRDtBQVlILENBNVBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2ZpbGVwb25kLmpzP2VkYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IEZpbGVQb25kXG5pbXBvcnQgKiBhcyBGaWxlUG9uZCBmcm9tICdmaWxlcG9uZCc7XG5cbi8vIEltcG9ydCB0aGUgcGx1Z2luIGNvZGVcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgZnJvbSAnZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZSc7XG5pbXBvcnQgRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplIGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUnO1xuaW1wb3J0IEZpbGVQb25kUGx1Z2luSW1hZ2VFeGlmT3JpZW50YXRpb24gZnJvbSAnZmlsZXBvbmQtcGx1Z2luLWltYWdlLWV4aWYtb3JpZW50YXRpb24nO1xuaW1wb3J0IEZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3IGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3JztcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkltYWdlQ3JvcCBmcm9tICdmaWxlcG9uZC1wbHVnaW4taW1hZ2UtY3JvcCc7XG5pbXBvcnQgRmlsZVBvbmRQbHVnaW5JbWFnZVJlc2l6ZSBmcm9tICdmaWxlcG9uZC1wbHVnaW4taW1hZ2UtcmVzaXplJztcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkltYWdlVHJhbnNmb3JtIGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1pbWFnZS10cmFuc2Zvcm0nO1xuaW1wb3J0IEZpbGVQb25kUGx1Z2luSW1hZ2VFZGl0IGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1lZGl0JztcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkZpbGVFbmNvZGUgZnJvbSAnZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlJztcblxuLy8gSW1wb3J0IHRoZSBwbHVnaW4gc3R5bGVzXG5pbXBvcnQgJ2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuY3NzJztcbmltcG9ydCAnZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC5jc3MnO1xuXG5cbi8vIEltcG9ydCB0aGUgcGx1Z2luIHN0eWxlc1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKXtcbnZhciBkYXRhVXJsO1xuLy8gUmVnaXN0ZXIgdGhlIHBsdWdpblxuICAgIEZpbGVQb25kLnJlZ2lzdGVyUGx1Z2luKFxuICAgICAgICBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUsXG4gICAgICAgIEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSxcbiAgICAgICAgRmlsZVBvbmRQbHVnaW5JbWFnZUV4aWZPcmllbnRhdGlvbixcbiAgICAgICAgRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXcsXG4gICAgICAgIEZpbGVQb25kUGx1Z2luSW1hZ2VDcm9wLFxuICAgICAgICBGaWxlUG9uZFBsdWdpbkltYWdlUmVzaXplLFxuICAgICAgICBGaWxlUG9uZFBsdWdpbkltYWdlVHJhbnNmb3JtLFxuICAgICAgICBGaWxlUG9uZFBsdWdpbkltYWdlRWRpdCxcbiAgICAgICAgRmlsZVBvbmRQbHVnaW5GaWxlRW5jb2RlXG4gICAgKTtcblxuICAgIC8vIFBvcnRmb2xpb1xuICAgIGNvbnN0IHBvcnRmb2xpb1BvbmQgPSBGaWxlUG9uZC5jcmVhdGUoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwb3J0Zm9saW9GaWxlcycpKTtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicG9ydGZvbGlvVXBsb2FkXCIsIDApO1xuXG4gICAgcG9ydGZvbGlvUG9uZC5zZXRPcHRpb25zKHtcbiAgICAgICAgbGFiZWxJZGxlOiAnSGluZWluemllaGVuIG9kZXIgPHNwYW4gY2xhc3M9XCJmaWxlcG9uZC0tbGFiZWwtYWN0aW9uXCI+ZHVyY2hzdWNoZW48L3NwYW4+JyxcbiAgICAgICAgbWF4RmlsZXM6IDYsXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgYWxsb3dNdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgYWxsb3dGaWxlRW5jb2RlOnRydWUsXG4gICAgICAgIGFsbG93RmlsZVR5cGVWYWxpZGF0aW9uOiB0cnVlLFxuICAgICAgICBhbGxvd1Byb2Nlc3M6ZmFsc2UsXG4gICAgICAgIG1heEZpbGVTaXplOlwiMTAwTUJcIixcbiAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZUV4Y2VlZGVkOiBcIkRpZSBEYXRlaSBpc3QgenUgZ3Jvc3MuXCIsXG4gICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZTogJ21heGltYWwgZXJsYXVidGUgRGF0ZWlncsO2c3NlOiB7ZmlsZXNpemV9JyxcbiAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXM6W1wiaW1hZ2UvKlwiXSxcbiAgICB9KTtcblxuXG4gICAgLy8gd2VubiBlaW5lIERhdGVpIGRlbSBVcGxvYWQgaGluenVnZWbDvGd0IHdpcmRcbiAgICBwb3J0Zm9saW9Qb25kLm9uYWRkZmlsZSA9IChlcnIsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGFVcmwgPSBpdGVtLmdldEZpbGVFbmNvZGVEYXRhVVJMKCk7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmwgOiAnL2FkZFRlbXBQb3J0Zm9saW9VcGxvYWQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsnWC1DU1JGLVRPS0VOJzogJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKX0sXG4gICAgICAgICAgICAgICAgdHlwZSA6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBkYXRhIDogeyAnZmlsZSc6IGRhdGFVcmwsICdmaWxlbmFtZSc6IGZpbGVuYW1lIH0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlcykgey8qY29uc29sZS5sb2cocmVzKTsqLyB9LFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uKHJlcykgey8qY29uc29sZS5sb2cocmVzKTsqL31cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicG9ydGZvbGlvVXBsb2FkXCIsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2VubiBlaW5lIERhdGVpIHZvbSBVcGxvYWQgZW50ZmVybnQgd2lyZFxuICAgIHBvcnRmb2xpb1BvbmQub25yZW1vdmVmaWxlPSAoZXJyLCBpdGVtKSA9PiB7XG4gICAgICAgIHZhciBmaWxlcyA9IHBvcnRmb2xpb1BvbmQuZ2V0RmlsZXMoKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsIDogJy9kZWxldGVUZW1wUG9ydGZvbGlvVXBsb2FkJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7J1gtQ1NSRi1UT0tFTic6ICQoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5hdHRyKCdjb250ZW50Jyl9LFxuICAgICAgICAgICAgICAgIHR5cGUgOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgZGF0YSA6IHsnZmlsZW5hbWUnOiBmaWxlbmFtZSB9LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXMpIHsvKmNvbnNvbGUubG9nKHJlcyk7Ki8gfSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbihyZXMpIHsvKmNvbnNvbGUubG9nKHJlcyk7Ki99XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYoZmlsZXMgPT0gMCl7XG4gICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInBvcnRmb2xpb1VwbG9hZFwiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEpvYiBBbmhhbmdcbiAgICBjb25zdCBqb2JBdHRhY2htZW50UG9uZCA9IEZpbGVQb25kLmNyZWF0ZSggZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2pvYkZpbGVzJykpO1xuICAgIGpvYkF0dGFjaG1lbnRQb25kLnNldE9wdGlvbnMoe1xuICAgICAgICBsYWJlbElkbGU6ICdIaW5laW56aWVoZW4gb2RlciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5kdXJjaHN1Y2hlbjwvc3Bhbj4nLFxuICAgICAgICBtYXhGaWxlczogNixcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBhbGxvd011bHRpcGxlOiB0cnVlLFxuICAgICAgICBhbGxvd0ZpbGVFbmNvZGU6dHJ1ZSxcbiAgICAgICAgYWxsb3dGaWxlVHlwZVZhbGlkYXRpb246IHRydWUsXG4gICAgICAgIGFsbG93UHJvY2Vzczp0cnVlLFxuICAgICAgICBtYXhGaWxlU2l6ZTpcIjEwME1CXCIsXG4gICAgICAgIGxhYmVsTWF4RmlsZVNpemVFeGNlZWRlZDogXCJEaWUgRGF0ZWkgaXN0IHp1IGdyb3NzLlwiLFxuICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6ICdtYXhpbWFsIGVybGF1YnRlIERhdGVpZ3LDtnNzZToge2ZpbGVzaXplfScsXG4gICAgICAgIGFjY2VwdGVkRmlsZVR5cGVzOltcImFwcGxpY2F0aW9uL2RvY3hcIixcImFwcGxpY2F0aW9uL3BkZlwiLFwiYXBwbGljYXRpb24vZG9jXCIsIFwiaW1hZ2UvKlwiXSxcbiAgICB9KTtcblxuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJqb2JBdHRhY2htZW50VXBsb2FkXCIsIDApO1xuXG4gICAgLy8gd2VubiBlaW5lIERhdGVpIGRlbSBVcGxvYWQgaGluenVnZWbDvGd0IHdpcmRcbiAgICBqb2JBdHRhY2htZW50UG9uZC5vbmFkZGZpbGUgPSAoZXJyLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gaXRlbS5nZXRGaWxlRW5jb2RlRGF0YVVSTCgpO1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsIDogJy9zdG9yZVRlbXBKb2JBdHRhY2htZW50cycsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeydYLUNTUkYtVE9LRU4nOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpfSxcbiAgICAgICAgICAgICAgICB0eXBlIDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGRhdGEgOiB7ICdmaWxlJzogZGF0YVVybCwgJ2ZpbGVuYW1lJzogZmlsZW5hbWUgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7Lypjb25zb2xlLmxvZyhyZXMpOyovIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24ocmVzKSB7Lypjb25zb2xlLmxvZyhyZXMpOyovfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJqb2JBdHRhY2htZW50VXBsb2FkXCIsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2VubiBlaW5lIERhdGVpIHZvbSBVcGxvYWQgZW50ZmVybnQgd2lyZFxuICAgIGpvYkF0dGFjaG1lbnRQb25kLm9ucmVtb3ZlZmlsZT0gKGVyciwgaXRlbSkgPT4ge1xuICAgICAgICB2YXIgZmlsZXMgPSBqb2JBdHRhY2htZW50UG9uZC5nZXRGaWxlcygpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmwgOiAnL2RlbGV0ZVRlbXBKb2JBdHRhY2htZW50cycsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeydYLUNTUkYtVE9LRU4nOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpfSxcbiAgICAgICAgICAgICAgICB0eXBlIDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGRhdGEgOiB7J2ZpbGVuYW1lJzogZmlsZW5hbWUgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7Lypjb25zb2xlLmxvZyhyZXMpOyovIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24ocmVzKSB7Lypjb25zb2xlLmxvZyhyZXMpOyovfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKGZpbGVzID09IDApe1xuICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJqb2JBdHRhY2htZW50VXBsb2FkXCIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvZmlsYmlsZFxuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwcm9maWxlVXBsb2FkXCIsIDApO1xuICAgIGNvbnN0IHByb2ZpbGVJbWFnZVBvbmQgPSBGaWxlUG9uZC5jcmVhdGUoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbWFnZScpKTtcbiAgICBwcm9maWxlSW1hZ2VQb25kLnNldE9wdGlvbnMoe1xuICAgICAgICBsYWJlbElkbGU6ICdIaW5laW56aWVoZW4gb2RlciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5kdXJjaHN1Y2hlbjwvc3Bhbj4nLFxuICAgICAgICBhbGxvd0ltYWdlQ3JvcDp0cnVlLFxuICAgICAgICBhbGxvd011bHRpcGxlOmZhbHNlLFxuICAgICAgICBpbWFnZVByZXZpZXdIZWlnaHQ6IDUwLFxuICAgICAgICBpbWFnZUNyb3BBc3BlY3RSYXRpbzogJzE6MScsXG4gICAgICAgIGltYWdlUmVzaXplVGFyZ2V0V2lkdGg6IDIwMCxcbiAgICAgICAgaW1hZ2VSZXNpemVUYXJnZXRIZWlnaHQ6IDIwMCxcbiAgICAgICAgaW1hZ2VSZXNpemVNb2RlOidjb3ZlcicsXG4gICAgICAgIHN0eWxlUGFuZWxMYXlvdXQ6ICdjb21wYWN0IGNpcmNsZScsXG4gICAgICAgIHN0eWxlTG9hZEluZGljYXRvclBvc2l0aW9uOiAnY2VudGVyIGJvdHRvbScsXG4gICAgICAgIHN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbjogJ3JpZ2h0IGJvdHRvbScsXG4gICAgICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uOiAncmlnaHQgdG9wJyxcbiAgICAgICAgc3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uOiAncmlnaHQgYm90dG9tJyxcbiAgICAgICAgYWxsb3dJbWFnZUVkaXQ6dHJ1ZSxcbiAgICAgICAgc3R5bGVJbWFnZUVkaXRCdXR0b25FZGl0SXRlbVBvc2l0aW9uOidcdGJvdHRvbSBjZW50ZXInLFxuICAgICAgICBhbGxvd0ZpbGVFbmNvZGU6dHJ1ZSxcbiAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICB1cmw6ICcvcHJvZmlsZUltYWdlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnWC1DU1JGLVRPS0VOJzogJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnWC1DU1JGLVRPS0VOJzogJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIFJlcXVlc3QgZW5jb2RlZCBkYXRhXG4gICAgcHJvZmlsZUltYWdlUG9uZC5vbmFkZGZpbGUgPSAoZXJyLCBpdGVtKSA9PiB7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgJChcImJ1dHRvblt0eXBlPSdzdWJtaXQnXVwiKS5hdHRyKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUud2FybihlcnIpO1xuICAgICAgICAgICAgJChcIiNpbWFnZS1mZWVkYmFja1wiKS5mYWRlSW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoXCJidXR0b25bdHlwZT0nc3VibWl0J11cIikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgJChcIiNpbWFnZS1mZWVkYmFja1wiKS5mYWRlT3V0KCk7XG4gICAgICAgICAgICBkYXRhVXJsID0gaXRlbS5nZXRGaWxlRW5jb2RlRGF0YVVSTCgpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInByb2ZpbGVVcGxvYWRcIiwgMSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFJlcXVlc3QgZW5jb2RlZCBkYXRhXG4gICAgcHJvZmlsZUltYWdlUG9uZC5vbnJlbW92ZWZpbGU9IChlcnIsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy9jb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgICQoXCJidXR0b25bdHlwZT0nc3VibWl0J11cIikuYXR0cihcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcImJ1dHRvblt0eXBlPSdzdWJtaXQnXVwiKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAkKFwiI2ltYWdlLWZlZWRiYWNrXCIpLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwcm9maWxlVXBsb2FkXCIsIDApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBTVkFcbiAgICBjb25zdCBzdmFQb25kID0gRmlsZVBvbmQuY3JlYXRlKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3ZhJykpO1xuICAgIHN2YVBvbmQuc2V0T3B0aW9ucyh7XG4gICAgICAgIGxhYmVsSWRsZTogJ0hpbmVpbnppZWhlbiBvZGVyIDxzcGFuIGNsYXNzPVwiZmlsZXBvbmQtLWxhYmVsLWFjdGlvblwiPmR1cmNoc3VjaGVuPC9zcGFuPicsXG4gICAgICAgIGFsbG93TXVsdGlwbGU6ZmFsc2UsXG4gICAgICAgIGFsbG93RmlsZUVuY29kZTp0cnVlLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgYWxsb3dGaWxlVHlwZVZhbGlkYXRpb246IHRydWUsXG4gICAgICAgIG1heEZpbGVTaXplOlwiMTAwTUJcIixcbiAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZUV4Y2VlZGVkOiBcIkRpZSBEYXRlaSBpc3QgenUgZ3Jvc3MuXCIsXG4gICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZTogJ21heGltYWwgZXJsYXVidGUgRGF0ZWlncsO2c3NlOiB7ZmlsZXNpemV9JyxcbiAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXM6W1wiYXBwbGljYXRpb24vcGRmXCJdLFxuICAgICAgICBzZXJ2ZXI6IHtcbiAgICAgICAgICAgIHVybDogJy9zdmEnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdYLUNTUkYtVE9LRU4nOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdYLUNTUkYtVE9LRU4nOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gUmVxdWVzdCBlbmNvZGVkIGRhdGFcbiAgICBzdmFQb25kLm9uYWRkZmlsZSA9IChlcnIsIGl0ZW0pID0+IHtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAkKFwiYnV0dG9uW3R5cGU9J3N1Ym1pdCddXCIpLmF0dHIoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICAkKFwiI3N2YS1mZWVkYmFja1wiKS5mYWRlSW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoXCJidXR0b25bdHlwZT0nc3VibWl0J11cIikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgJChcIiNzdmEtZmVlZGJhY2tcIikuZmFkZU91dCgpO1xuICAgICAgICAgICAgZGF0YVVybCA9IGl0ZW0uZ2V0RmlsZUVuY29kZURhdGFVUkwoKTtcbiAgICAgICAgICAgICQoXCIjc3ZhQmFzZTY0U3RyaW5nXCIpLnZhbChkYXRhVXJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVlc3QgZW5jb2RlZCBkYXRhXG4gICAgc3ZhUG9uZC5vbnJlbW92ZWZpbGU9IChlcnIsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy9jb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgICQoXCJidXR0b25bdHlwZT0nc3VibWl0J11cIikuYXR0cihcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcImJ1dHRvblt0eXBlPSdzdWJtaXQnXVwiKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAkKFwiI3N2YS1mZWVkYmFja1wiKS5mYWRlT3V0KCk7XG4gICAgICAgICAgICAkKFwiI3N2YUJhc2U2NFN0cmluZ1wiKS52YWwoXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pXG4iXSwibmFtZXMiOlsiRmlsZVBvbmQiLCJGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUiLCJGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUiLCJGaWxlUG9uZFBsdWdpbkltYWdlRXhpZk9yaWVudGF0aW9uIiwiRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXciLCJGaWxlUG9uZFBsdWdpbkltYWdlQ3JvcCIsIkZpbGVQb25kUGx1Z2luSW1hZ2VSZXNpemUiLCJGaWxlUG9uZFBsdWdpbkltYWdlVHJhbnNmb3JtIiwiRmlsZVBvbmRQbHVnaW5JbWFnZUVkaXQiLCJGaWxlUG9uZFBsdWdpbkZpbGVFbmNvZGUiLCIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImRhdGFVcmwiLCJyZWdpc3RlclBsdWdpbiIsInBvcnRmb2xpb1BvbmQiLCJjcmVhdGUiLCJxdWVyeVNlbGVjdG9yIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwic2V0T3B0aW9ucyIsImxhYmVsSWRsZSIsIm1heEZpbGVzIiwicmVxdWlyZWQiLCJhbGxvd011bHRpcGxlIiwiYWxsb3dGaWxlRW5jb2RlIiwiYWxsb3dGaWxlVHlwZVZhbGlkYXRpb24iLCJhbGxvd1Byb2Nlc3MiLCJtYXhGaWxlU2l6ZSIsImxhYmVsTWF4RmlsZVNpemVFeGNlZWRlZCIsImxhYmVsTWF4VG90YWxGaWxlU2l6ZSIsImFjY2VwdGVkRmlsZVR5cGVzIiwib25hZGRmaWxlIiwiZXJyIiwiaXRlbSIsImdldEZpbGVFbmNvZGVEYXRhVVJMIiwiZmlsZW5hbWUiLCJhamF4IiwidXJsIiwiaGVhZGVycyIsImF0dHIiLCJ0eXBlIiwiZGF0YSIsInN1Y2Nlc3MiLCJyZXMiLCJmYWlsdXJlIiwib25yZW1vdmVmaWxlIiwiZmlsZXMiLCJnZXRGaWxlcyIsImpvYkF0dGFjaG1lbnRQb25kIiwicHJvZmlsZUltYWdlUG9uZCIsImFsbG93SW1hZ2VDcm9wIiwiaW1hZ2VQcmV2aWV3SGVpZ2h0IiwiaW1hZ2VDcm9wQXNwZWN0UmF0aW8iLCJpbWFnZVJlc2l6ZVRhcmdldFdpZHRoIiwiaW1hZ2VSZXNpemVUYXJnZXRIZWlnaHQiLCJpbWFnZVJlc2l6ZU1vZGUiLCJzdHlsZVBhbmVsTGF5b3V0Iiwic3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb24iLCJzdHlsZVByb2dyZXNzSW5kaWNhdG9yUG9zaXRpb24iLCJzdHlsZUJ1dHRvblJlbW92ZUl0ZW1Qb3NpdGlvbiIsInN0eWxlQnV0dG9uUHJvY2Vzc0l0ZW1Qb3NpdGlvbiIsImFsbG93SW1hZ2VFZGl0Iiwic3R5bGVJbWFnZUVkaXRCdXR0b25FZGl0SXRlbVBvc2l0aW9uIiwic2VydmVyIiwiZmFkZUluIiwicmVtb3ZlQXR0ciIsImZhZGVPdXQiLCJzdmFQb25kIiwidmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/filepond.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css":
/*!***********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css ***!
  \***********************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*!\\n * FilePondPluginImageEdit 1.6.3\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--action-edit-item.filepond--action-edit-item {\\n  width: 2em;\\n  height: 2em;\\n  padding: 0.1875em;\\n}\\n\\n.filepond--action-edit-item.filepond--action-edit-item[data-align*='center'] {\\n  margin-left: -0.1875em;\\n}\\n\\n.filepond--action-edit-item.filepond--action-edit-item[data-align*='bottom'] {\\n  margin-bottom: -0.1875em;\\n}\\n\\n.filepond--action-edit-item-alt {\\n  border: none;\\n  line-height: inherit;\\n  background: transparent;\\n  font-family: inherit;\\n  color: inherit;\\n  outline: none;\\n  padding: 0;\\n  margin: 0 0 0 0.25em;\\n  pointer-events: all;\\n  position: absolute;\\n}\\n\\n.filepond--action-edit-item-alt svg {\\n  width: 1.3125em;\\n  height: 1.3125em;\\n}\\n\\n.filepond--action-edit-item-alt span {\\n  font-size: 0;\\n  opacity: 0;\\n}\\n.filepond--root[data-style-panel-layout~='circle'] .filepond--action-edit-item {\\n  opacity: 1 !important;\\n  visibility: visible !important;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css\"],\"names\":[],\"mappings\":\"AAAA;;;;EAIE;;AAEF,mBAAmB;AACnB;EACE,UAAU;EACV,WAAW;EACX,iBAAiB;AACnB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,oBAAoB;EACpB,uBAAuB;EACvB,oBAAoB;EACpB,cAAc;EACd,aAAa;EACb,UAAU;EACV,oBAAoB;EACpB,mBAAmB;EACnB,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,UAAU;AACZ;AACA;EACE,qBAAqB;EACrB,8BAA8B;AAChC\",\"sourcesContent\":[\"/*!\\n * FilePondPluginImageEdit 1.6.3\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--action-edit-item.filepond--action-edit-item {\\n  width: 2em;\\n  height: 2em;\\n  padding: 0.1875em;\\n}\\n\\n.filepond--action-edit-item.filepond--action-edit-item[data-align*='center'] {\\n  margin-left: -0.1875em;\\n}\\n\\n.filepond--action-edit-item.filepond--action-edit-item[data-align*='bottom'] {\\n  margin-bottom: -0.1875em;\\n}\\n\\n.filepond--action-edit-item-alt {\\n  border: none;\\n  line-height: inherit;\\n  background: transparent;\\n  font-family: inherit;\\n  color: inherit;\\n  outline: none;\\n  padding: 0;\\n  margin: 0 0 0 0.25em;\\n  pointer-events: all;\\n  position: absolute;\\n}\\n\\n.filepond--action-edit-item-alt svg {\\n  width: 1.3125em;\\n  height: 1.3125em;\\n}\\n\\n.filepond--action-edit-item-alt span {\\n  font-size: 0;\\n  opacity: 0;\\n}\\n.filepond--root[data-style-panel-layout~='circle'] .filepond--action-edit-item {\\n  opacity: 1 !important;\\n  visibility: visible !important;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xM1swXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTNbMF0ucnVsZXNbMF0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1lZGl0L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDNEc7QUFDN0I7QUFDL0UsOEJBQThCLHNFQUEyQixDQUFDLDJGQUFxQztBQUMvRjtBQUNBLDRSQUE0UixlQUFlLGdCQUFnQixzQkFBc0IsR0FBRyxrRkFBa0YsMkJBQTJCLEdBQUcsa0ZBQWtGLDZCQUE2QixHQUFHLHFDQUFxQyxpQkFBaUIseUJBQXlCLDRCQUE0Qix5QkFBeUIsbUJBQW1CLGtCQUFrQixlQUFlLHlCQUF5Qix3QkFBd0IsdUJBQXVCLEdBQUcseUNBQXlDLG9CQUFvQixxQkFBcUIsR0FBRywwQ0FBMEMsaUJBQWlCLGVBQWUsR0FBRyxrRkFBa0YsMEJBQTBCLG1DQUFtQyxHQUFHLFNBQVMsaUpBQWlKLE1BQU0sWUFBWSxNQUFNLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssWUFBWSxhQUFhLDRRQUE0USxlQUFlLGdCQUFnQixzQkFBc0IsR0FBRyxrRkFBa0YsMkJBQTJCLEdBQUcsa0ZBQWtGLDZCQUE2QixHQUFHLHFDQUFxQyxpQkFBaUIseUJBQXlCLDRCQUE0Qix5QkFBeUIsbUJBQW1CLGtCQUFrQixlQUFlLHlCQUF5Qix3QkFBd0IsdUJBQXVCLEdBQUcseUNBQXlDLG9CQUFvQixxQkFBcUIsR0FBRywwQ0FBMEMsaUJBQWlCLGVBQWUsR0FBRyxrRkFBa0YsMEJBQTBCLG1DQUFtQyxHQUFHLHFCQUFxQjtBQUN2c0Y7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1lZGl0LmNzcz8xM2UzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIEZpbGVQb25kUGx1Z2luSW1hZ2VFZGl0IDEuNi4zXFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgKi9cXG4uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0ge1xcbiAgd2lkdGg6IDJlbTtcXG4gIGhlaWdodDogMmVtO1xcbiAgcGFkZGluZzogMC4xODc1ZW07XFxufVxcblxcbi5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbVtkYXRhLWFsaWduKj0nY2VudGVyJ10ge1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjE4NzVlbTtcXG59XFxuXFxuLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtW2RhdGEtYWxpZ24qPSdib3R0b20nXSB7XFxuICBtYXJnaW4tYm90dG9tOiAtMC4xODc1ZW07XFxufVxcblxcbi5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbS1hbHQge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMCAwIDAgMC4yNWVtO1xcbiAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLWFsdCBzdmcge1xcbiAgd2lkdGg6IDEuMzEyNWVtO1xcbiAgaGVpZ2h0OiAxLjMxMjVlbTtcXG59XFxuXFxuLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLWFsdCBzcGFuIHtcXG4gIGZvbnQtc2l6ZTogMDtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddIC5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbSB7XFxuICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1lZGl0LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7OztFQUlFOztBQUVGLG1CQUFtQjtBQUNuQjtFQUNFLFVBQVU7RUFDVixXQUFXO0VBQ1gsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0Usc0JBQXNCO0FBQ3hCOztBQUVBO0VBQ0Usd0JBQXdCO0FBQzFCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLG9CQUFvQjtFQUNwQix1QkFBdUI7RUFDdkIsb0JBQW9CO0VBQ3BCLGNBQWM7RUFDZCxhQUFhO0VBQ2IsVUFBVTtFQUNWLG9CQUFvQjtFQUNwQixtQkFBbUI7RUFDbkIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixVQUFVO0FBQ1o7QUFDQTtFQUNFLHFCQUFxQjtFQUNyQiw4QkFBOEI7QUFDaENcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyohXFxuICogRmlsZVBvbmRQbHVnaW5JbWFnZUVkaXQgMS42LjNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xcbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xcbi5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbSB7XFxuICB3aWR0aDogMmVtO1xcbiAgaGVpZ2h0OiAyZW07XFxuICBwYWRkaW5nOiAwLjE4NzVlbTtcXG59XFxuXFxuLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtW2RhdGEtYWxpZ24qPSdjZW50ZXInXSB7XFxuICBtYXJnaW4tbGVmdDogLTAuMTg3NWVtO1xcbn1cXG5cXG4uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW1bZGF0YS1hbGlnbio9J2JvdHRvbSddIHtcXG4gIG1hcmdpbi1ib3R0b206IC0wLjE4NzVlbTtcXG59XFxuXFxuLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLWFsdCB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwIDAgMCAwLjI1ZW07XFxuICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0tYWx0IHN2ZyB7XFxuICB3aWR0aDogMS4zMTI1ZW07XFxuICBoZWlnaHQ6IDEuMzEyNWVtO1xcbn1cXG5cXG4uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0tYWx0IHNwYW4ge1xcbiAgZm9udC1zaXplOiAwO1xcbiAgb3BhY2l0eTogMDtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ10gLmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtIHtcXG4gIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcXG4gIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css":
/*!*****************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css ***!
  \*****************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*!\\n * FilePondPluginImagePreview 4.6.10\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--image-preview-markup {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n.filepond--image-preview-wrapper {\\n  z-index: 2;\\n}\\n.filepond--image-preview-overlay {\\n  display: block;\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  min-height: 5rem;\\n  max-height: 7rem;\\n  margin: 0;\\n  opacity: 0;\\n  z-index: 2;\\n  pointer-events: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n.filepond--image-preview-overlay svg {\\n  width: 100%;\\n  height: auto;\\n  color: inherit;\\n  max-height: inherit;\\n}\\n.filepond--image-preview-overlay-idle {\\n  mix-blend-mode: multiply;\\n  color: rgba(40, 40, 40, 0.85);\\n}\\n.filepond--image-preview-overlay-success {\\n  mix-blend-mode: normal;\\n  color: rgba(54, 151, 99, 1);\\n}\\n.filepond--image-preview-overlay-failure {\\n  mix-blend-mode: normal;\\n  color: rgba(196, 78, 71, 1);\\n}\\n/* disable for Safari as mix-blend-mode causes the overflow:hidden of the parent container to not work */\\n@supports (-webkit-marquee-repetition: infinite) and\\n  ((-o-object-fit: fill) or (object-fit: fill)) {\\n  .filepond--image-preview-overlay-idle {\\n    mix-blend-mode: normal;\\n  }\\n}\\n.filepond--image-preview-wrapper {\\n  /* no interaction */\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n\\n  /* have preview fill up all available space */\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  right: 0;\\n  height: 100%;\\n  margin: 0;\\n\\n  /* radius is .05em less to prevent the panel background color from shining through */\\n  border-radius: 0.45em;\\n  overflow: hidden;\\n\\n  /* this seems to prevent Chrome from redrawing this layer constantly */\\n  background: rgba(0, 0, 0, 0.01);\\n}\\n.filepond--image-preview {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  z-index: 1;\\n  display: flex; /* this aligns the graphic vertically if the panel is higher than the image */\\n  align-items: center;\\n  height: 100%;\\n  width: 100%;\\n  pointer-events: none;\\n  background: #222;\\n\\n  /* will be animated */\\n  will-change: transform, opacity;\\n}\\n.filepond--image-clip {\\n  position: relative;\\n  overflow: hidden;\\n  margin: 0 auto;\\n\\n  /* transparency indicator (currently only supports grid or basic color) */\\n}\\n.filepond--image-clip[data-transparency-indicator='grid'] img,\\n.filepond--image-clip[data-transparency-indicator='grid'] canvas {\\n  background-color: #fff;\\n  background-image: url(\\\"data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg' fill='%23eee'%3E%3Cpath d='M0 0 H50 V50 H0'/%3E%3Cpath d='M50 50 H100 V100 H50'/%3E%3C/svg%3E\\\");\\n  background-size: 1.25em 1.25em;\\n}\\n.filepond--image-bitmap,\\n.filepond--image-vector {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  will-change: transform;\\n}\\n.filepond--root[data-style-panel-layout~='integrated']\\n  .filepond--image-preview-wrapper {\\n  border-radius: 0;\\n}\\n.filepond--root[data-style-panel-layout~='integrated']\\n  .filepond--image-preview {\\n  height: 100%;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--image-preview-wrapper {\\n  border-radius: 99999rem;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--image-preview-overlay {\\n  top: auto;\\n  bottom: 0;\\n  -webkit-transform: scaleY(-1);\\n  transform: scaleY(-1);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  .filepond--file-action-button[data-align*='bottom']:not([data-align*='center']) {\\n  margin-bottom: 0.325em;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  [data-align*='left'] {\\n  left: calc(50% - 3em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  [data-align*='right'] {\\n  right: calc(50% - 3em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='left'],\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='right'] {\\n  margin-bottom: calc(0.325em + 0.1875em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='center'] {\\n  margin-top: 0;\\n  margin-bottom: 0.1875em;\\n  margin-left: 0.1875em;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\"],\"names\":[],\"mappings\":\"AAAA;;;;EAIE;;AAEF,mBAAmB;AACnB;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;AACR;AACA;EACE,UAAU;AACZ;AACA;EACE,cAAc;EACd,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,WAAW;EACX,gBAAgB;EAChB,gBAAgB;EAChB,SAAS;EACT,UAAU;EACV,UAAU;EACV,oBAAoB;EACpB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;AACA;EACE,WAAW;EACX,YAAY;EACZ,cAAc;EACd,mBAAmB;AACrB;AACA;EACE,wBAAwB;EACxB,6BAA6B;AAC/B;AACA;EACE,sBAAsB;EACtB,2BAA2B;AAC7B;AACA;EACE,sBAAsB;EACtB,2BAA2B;AAC7B;AACA,wGAAwG;AACxG;;EAEE;IACE,sBAAsB;EACxB;AACF;AACA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;;EAEjB,6CAA6C;EAC7C,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,QAAQ;EACR,YAAY;EACZ,SAAS;;EAET,oFAAoF;EACpF,qBAAqB;EACrB,gBAAgB;;EAEhB,sEAAsE;EACtE,+BAA+B;AACjC;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,UAAU;EACV,aAAa,EAAE,6EAA6E;EAC5F,mBAAmB;EACnB,YAAY;EACZ,WAAW;EACX,oBAAoB;EACpB,gBAAgB;;EAEhB,qBAAqB;EACrB,+BAA+B;AACjC;AACA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,cAAc;;EAEd,yEAAyE;AAC3E;AACA;;EAEE,sBAAsB;EACtB,yMAAyM;EACzM,8BAA8B;AAChC;AACA;;EAEE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,sBAAsB;AACxB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,YAAY;EACZ,aAAa;EACb,uBAAuB;EACvB,mBAAmB;AACrB;AACA;;EAEE,uBAAuB;AACzB;AACA;;EAEE,SAAS;EACT,SAAS;EACT,6BAA6B;EAC7B,qBAAqB;AACvB;AACA;;;EAGE,sBAAsB;AACxB;AACA;;;EAGE,qBAAqB;AACvB;AACA;;;EAGE,sBAAsB;AACxB;AACA;;;;EAIE,uCAAuC;AACzC;AACA;;EAEE,aAAa;EACb,uBAAuB;EACvB,qBAAqB;AACvB\",\"sourcesContent\":[\"/*!\\n * FilePondPluginImagePreview 4.6.10\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--image-preview-markup {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n.filepond--image-preview-wrapper {\\n  z-index: 2;\\n}\\n.filepond--image-preview-overlay {\\n  display: block;\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  min-height: 5rem;\\n  max-height: 7rem;\\n  margin: 0;\\n  opacity: 0;\\n  z-index: 2;\\n  pointer-events: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n.filepond--image-preview-overlay svg {\\n  width: 100%;\\n  height: auto;\\n  color: inherit;\\n  max-height: inherit;\\n}\\n.filepond--image-preview-overlay-idle {\\n  mix-blend-mode: multiply;\\n  color: rgba(40, 40, 40, 0.85);\\n}\\n.filepond--image-preview-overlay-success {\\n  mix-blend-mode: normal;\\n  color: rgba(54, 151, 99, 1);\\n}\\n.filepond--image-preview-overlay-failure {\\n  mix-blend-mode: normal;\\n  color: rgba(196, 78, 71, 1);\\n}\\n/* disable for Safari as mix-blend-mode causes the overflow:hidden of the parent container to not work */\\n@supports (-webkit-marquee-repetition: infinite) and\\n  ((-o-object-fit: fill) or (object-fit: fill)) {\\n  .filepond--image-preview-overlay-idle {\\n    mix-blend-mode: normal;\\n  }\\n}\\n.filepond--image-preview-wrapper {\\n  /* no interaction */\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n\\n  /* have preview fill up all available space */\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  right: 0;\\n  height: 100%;\\n  margin: 0;\\n\\n  /* radius is .05em less to prevent the panel background color from shining through */\\n  border-radius: 0.45em;\\n  overflow: hidden;\\n\\n  /* this seems to prevent Chrome from redrawing this layer constantly */\\n  background: rgba(0, 0, 0, 0.01);\\n}\\n.filepond--image-preview {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  z-index: 1;\\n  display: flex; /* this aligns the graphic vertically if the panel is higher than the image */\\n  align-items: center;\\n  height: 100%;\\n  width: 100%;\\n  pointer-events: none;\\n  background: #222;\\n\\n  /* will be animated */\\n  will-change: transform, opacity;\\n}\\n.filepond--image-clip {\\n  position: relative;\\n  overflow: hidden;\\n  margin: 0 auto;\\n\\n  /* transparency indicator (currently only supports grid or basic color) */\\n}\\n.filepond--image-clip[data-transparency-indicator='grid'] img,\\n.filepond--image-clip[data-transparency-indicator='grid'] canvas {\\n  background-color: #fff;\\n  background-image: url(\\\"data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg' fill='%23eee'%3E%3Cpath d='M0 0 H50 V50 H0'/%3E%3Cpath d='M50 50 H100 V100 H50'/%3E%3C/svg%3E\\\");\\n  background-size: 1.25em 1.25em;\\n}\\n.filepond--image-bitmap,\\n.filepond--image-vector {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  will-change: transform;\\n}\\n.filepond--root[data-style-panel-layout~='integrated']\\n  .filepond--image-preview-wrapper {\\n  border-radius: 0;\\n}\\n.filepond--root[data-style-panel-layout~='integrated']\\n  .filepond--image-preview {\\n  height: 100%;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--image-preview-wrapper {\\n  border-radius: 99999rem;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--image-preview-overlay {\\n  top: auto;\\n  bottom: 0;\\n  -webkit-transform: scaleY(-1);\\n  transform: scaleY(-1);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  .filepond--file-action-button[data-align*='bottom']:not([data-align*='center']) {\\n  margin-bottom: 0.325em;\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  [data-align*='left'] {\\n  left: calc(50% - 3em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--file\\n  [data-align*='right'] {\\n  right: calc(50% - 3em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='left'],\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='right'] {\\n  margin-bottom: calc(0.325em + 0.1875em);\\n}\\n.filepond--root[data-style-panel-layout~='circle']\\n  .filepond--progress-indicator[data-align*='bottom'][data-align*='center'] {\\n  margin-top: 0;\\n  margin-bottom: 0.1875em;\\n  margin-left: 0.1875em;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xM1swXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTNbMF0ucnVsZXNbMF0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDNEc7QUFDN0I7QUFDL0UsOEJBQThCLHNFQUEyQixDQUFDLDJGQUFxQztBQUMvRjtBQUNBLHlRQUF5USx1QkFBdUIsWUFBWSxXQUFXLEdBQUcsb0NBQW9DLGVBQWUsR0FBRyxvQ0FBb0MsbUJBQW1CLHVCQUF1QixZQUFZLFdBQVcsZ0JBQWdCLHFCQUFxQixxQkFBcUIsY0FBYyxlQUFlLGVBQWUseUJBQXlCLDhCQUE4QiwyQkFBMkIsMEJBQTBCLHNCQUFzQixHQUFHLHdDQUF3QyxnQkFBZ0IsaUJBQWlCLG1CQUFtQix3QkFBd0IsR0FBRyx5Q0FBeUMsNkJBQTZCLGtDQUFrQyxHQUFHLDRDQUE0QywyQkFBMkIsZ0NBQWdDLEdBQUcsNENBQTRDLDJCQUEyQixnQ0FBZ0MsR0FBRyxvTkFBb04sMkNBQTJDLDZCQUE2QixLQUFLLEdBQUcsb0NBQW9DLHNEQUFzRCwyQkFBMkIsMEJBQTBCLHNCQUFzQiwyRUFBMkUsWUFBWSxXQUFXLGFBQWEsaUJBQWlCLGNBQWMscUhBQXFILHFCQUFxQixpSEFBaUgsR0FBRyw0QkFBNEIsdUJBQXVCLFlBQVksV0FBVyxlQUFlLG1CQUFtQixzR0FBc0csaUJBQWlCLGdCQUFnQix5QkFBeUIscUJBQXFCLGdFQUFnRSxHQUFHLHlCQUF5Qix1QkFBdUIscUJBQXFCLG1CQUFtQixtRkFBbUYsb0lBQW9JLDJCQUEyQixnTkFBZ04sbUNBQW1DLEdBQUcscURBQXFELHVCQUF1QixZQUFZLFdBQVcsMkJBQTJCLEdBQUcsOEZBQThGLHFCQUFxQixHQUFHLHNGQUFzRixpQkFBaUIsa0JBQWtCLDRCQUE0Qix3QkFBd0IsR0FBRywwRkFBMEYsNEJBQTRCLEdBQUcsMEZBQTBGLGNBQWMsY0FBYyxrQ0FBa0MsMEJBQTBCLEdBQUcsNEpBQTRKLDJCQUEyQixHQUFHLGlHQUFpRywwQkFBMEIsR0FBRyxrR0FBa0csMkJBQTJCLEdBQUcsa1FBQWtRLDRDQUE0QyxHQUFHLG1JQUFtSSxrQkFBa0IsNEJBQTRCLDBCQUEwQixHQUFHLFNBQVMsdUpBQXVKLE1BQU0sWUFBWSxNQUFNLFlBQVksV0FBVyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksV0FBVyxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxjQUFjLGFBQWEsYUFBYSxXQUFXLFVBQVUsVUFBVSxVQUFVLFdBQVcsWUFBWSxhQUFhLGNBQWMsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLHNCQUFzQixhQUFhLFdBQVcsVUFBVSxZQUFZLGNBQWMsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsWUFBWSxZQUFZLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxNQUFNLE9BQU8sWUFBWSxNQUFNLE9BQU8sWUFBWSxNQUFNLE9BQU8sWUFBWSxNQUFNLFFBQVEsWUFBWSxNQUFNLE1BQU0sVUFBVSxZQUFZLGFBQWEseVBBQXlQLHVCQUF1QixZQUFZLFdBQVcsR0FBRyxvQ0FBb0MsZUFBZSxHQUFHLG9DQUFvQyxtQkFBbUIsdUJBQXVCLFlBQVksV0FBVyxnQkFBZ0IscUJBQXFCLHFCQUFxQixjQUFjLGVBQWUsZUFBZSx5QkFBeUIsOEJBQThCLDJCQUEyQiwwQkFBMEIsc0JBQXNCLEdBQUcsd0NBQXdDLGdCQUFnQixpQkFBaUIsbUJBQW1CLHdCQUF3QixHQUFHLHlDQUF5Qyw2QkFBNkIsa0NBQWtDLEdBQUcsNENBQTRDLDJCQUEyQixnQ0FBZ0MsR0FBRyw0Q0FBNEMsMkJBQTJCLGdDQUFnQyxHQUFHLG9OQUFvTiwyQ0FBMkMsNkJBQTZCLEtBQUssR0FBRyxvQ0FBb0Msc0RBQXNELDJCQUEyQiwwQkFBMEIsc0JBQXNCLDJFQUEyRSxZQUFZLFdBQVcsYUFBYSxpQkFBaUIsY0FBYyxxSEFBcUgscUJBQXFCLGlIQUFpSCxHQUFHLDRCQUE0Qix1QkFBdUIsWUFBWSxXQUFXLGVBQWUsbUJBQW1CLHNHQUFzRyxpQkFBaUIsZ0JBQWdCLHlCQUF5QixxQkFBcUIsZ0VBQWdFLEdBQUcseUJBQXlCLHVCQUF1QixxQkFBcUIsbUJBQW1CLG1GQUFtRixvSUFBb0ksMkJBQTJCLGdOQUFnTixtQ0FBbUMsR0FBRyxxREFBcUQsdUJBQXVCLFlBQVksV0FBVywyQkFBMkIsR0FBRyw4RkFBOEYscUJBQXFCLEdBQUcsc0ZBQXNGLGlCQUFpQixrQkFBa0IsNEJBQTRCLHdCQUF3QixHQUFHLDBGQUEwRiw0QkFBNEIsR0FBRywwRkFBMEYsY0FBYyxjQUFjLGtDQUFrQywwQkFBMEIsR0FBRyw0SkFBNEosMkJBQTJCLEdBQUcsaUdBQWlHLDBCQUEwQixHQUFHLGtHQUFrRywyQkFBMkIsR0FBRyxrUUFBa1EsNENBQTRDLEdBQUcsbUlBQW1JLGtCQUFrQiw0QkFBNEIsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ3o4VTtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuY3NzPzhjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXcgNC42LjEwXFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgKi9cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctbWFya3VwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy13cmFwcGVyIHtcXG4gIHotaW5kZXg6IDI7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWluLWhlaWdodDogNXJlbTtcXG4gIG1heC1oZWlnaHQ6IDdyZW07XFxuICBtYXJnaW46IDA7XFxuICBvcGFjaXR5OiAwO1xcbiAgei1pbmRleDogMjtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3LW92ZXJsYXkgc3ZnIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBtYXgtaGVpZ2h0OiBpbmhlcml0O1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctb3ZlcmxheS1pZGxlIHtcXG4gIG1peC1ibGVuZC1tb2RlOiBtdWx0aXBseTtcXG4gIGNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIDAuODUpO1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctb3ZlcmxheS1zdWNjZXNzIHtcXG4gIG1peC1ibGVuZC1tb2RlOiBub3JtYWw7XFxuICBjb2xvcjogcmdiYSg1NCwgMTUxLCA5OSwgMSk7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5LWZhaWx1cmUge1xcbiAgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDtcXG4gIGNvbG9yOiByZ2JhKDE5NiwgNzgsIDcxLCAxKTtcXG59XFxuLyogZGlzYWJsZSBmb3IgU2FmYXJpIGFzIG1peC1ibGVuZC1tb2RlIGNhdXNlcyB0aGUgb3ZlcmZsb3c6aGlkZGVuIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIHRvIG5vdCB3b3JrICovXFxuQHN1cHBvcnRzICgtd2Via2l0LW1hcnF1ZWUtcmVwZXRpdGlvbjogaW5maW5pdGUpIGFuZFxcbiAgKCgtby1vYmplY3QtZml0OiBmaWxsKSBvciAob2JqZWN0LWZpdDogZmlsbCkpIHtcXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5LWlkbGUge1xcbiAgICBtaXgtYmxlbmQtbW9kZTogbm9ybWFsO1xcbiAgfVxcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctd3JhcHBlciB7XFxuICAvKiBubyBpbnRlcmFjdGlvbiAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG5cXG4gIC8qIGhhdmUgcHJldmlldyBmaWxsIHVwIGFsbCBhdmFpbGFibGUgc3BhY2UgKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1hcmdpbjogMDtcXG5cXG4gIC8qIHJhZGl1cyBpcyAuMDVlbSBsZXNzIHRvIHByZXZlbnQgdGhlIHBhbmVsIGJhY2tncm91bmQgY29sb3IgZnJvbSBzaGluaW5nIHRocm91Z2ggKi9cXG4gIGJvcmRlci1yYWRpdXM6IDAuNDVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICAvKiB0aGlzIHNlZW1zIHRvIHByZXZlbnQgQ2hyb21lIGZyb20gcmVkcmF3aW5nIHRoaXMgbGF5ZXIgY29uc3RhbnRseSAqL1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjAxKTtcXG59XFxuLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB6LWluZGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDsgLyogdGhpcyBhbGlnbnMgdGhlIGdyYXBoaWMgdmVydGljYWxseSBpZiB0aGUgcGFuZWwgaXMgaGlnaGVyIHRoYW4gdGhlIGltYWdlICovXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGJhY2tncm91bmQ6ICMyMjI7XFxuXFxuICAvKiB3aWxsIGJlIGFuaW1hdGVkICovXFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtLCBvcGFjaXR5O1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLWNsaXAge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIG1hcmdpbjogMCBhdXRvO1xcblxcbiAgLyogdHJhbnNwYXJlbmN5IGluZGljYXRvciAoY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgZ3JpZCBvciBiYXNpYyBjb2xvcikgKi9cXG59XFxuLmZpbGVwb25kLS1pbWFnZS1jbGlwW2RhdGEtdHJhbnNwYXJlbmN5LWluZGljYXRvcj0nZ3JpZCddIGltZyxcXG4uZmlsZXBvbmQtLWltYWdlLWNsaXBbZGF0YS10cmFuc3BhcmVuY3ktaW5kaWNhdG9yPSdncmlkJ10gY2FudmFzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0Nzdmcgdmlld0JveD0nMCAwIDEwMCAxMDAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgZmlsbD0nJTIzZWVlJyUzRSUzQ3BhdGggZD0nTTAgMCBINTAgVjUwIEgwJy8lM0UlM0NwYXRoIGQ9J001MCA1MCBIMTAwIFYxMDAgSDUwJy8lM0UlM0Mvc3ZnJTNFXFxcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEuMjVlbSAxLjI1ZW07XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtYml0bWFwLFxcbi5maWxlcG9uZC0taW1hZ2UtdmVjdG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdpbnRlZ3JhdGVkJ11cXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy13cmFwcGVyIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2ludGVncmF0ZWQnXVxcbiAgLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3IHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLWltYWdlLXByZXZpZXctd3JhcHBlciB7XFxuICBib3JkZXItcmFkaXVzOiA5OTk5OXJlbTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5IHtcXG4gIHRvcDogYXV0bztcXG4gIGJvdHRvbTogMDtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xcbiAgdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xcbn1cXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdjaXJjbGUnXVxcbiAgLmZpbGVwb25kLS1maWxlXFxuICAuZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbltkYXRhLWFsaWduKj0nYm90dG9tJ106bm90KFtkYXRhLWFsaWduKj0nY2VudGVyJ10pIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuMzI1ZW07XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLWZpbGVcXG4gIFtkYXRhLWFsaWduKj0nbGVmdCddIHtcXG4gIGxlZnQ6IGNhbGMoNTAlIC0gM2VtKTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0tZmlsZVxcbiAgW2RhdGEtYWxpZ24qPSdyaWdodCddIHtcXG4gIHJpZ2h0OiBjYWxjKDUwJSAtIDNlbSk7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvcltkYXRhLWFsaWduKj0nYm90dG9tJ11bZGF0YS1hbGlnbio9J2xlZnQnXSxcXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdjaXJjbGUnXVxcbiAgLmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3JbZGF0YS1hbGlnbio9J2JvdHRvbSddW2RhdGEtYWxpZ24qPSdyaWdodCddIHtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC4zMjVlbSArIDAuMTg3NWVtKTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9yW2RhdGEtYWxpZ24qPSdib3R0b20nXVtkYXRhLWFsaWduKj0nY2VudGVyJ10ge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDAuMTg3NWVtO1xcbiAgbWFyZ2luLWxlZnQ6IDAuMTg3NWVtO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7Ozs7RUFJRTs7QUFFRixtQkFBbUI7QUFDbkI7RUFDRSxrQkFBa0I7RUFDbEIsT0FBTztFQUNQLE1BQU07QUFDUjtBQUNBO0VBQ0UsVUFBVTtBQUNaO0FBQ0E7RUFDRSxjQUFjO0VBQ2Qsa0JBQWtCO0VBQ2xCLE9BQU87RUFDUCxNQUFNO0VBQ04sV0FBVztFQUNYLGdCQUFnQjtFQUNoQixnQkFBZ0I7RUFDaEIsU0FBUztFQUNULFVBQVU7RUFDVixVQUFVO0VBQ1Ysb0JBQW9CO0VBQ3BCLHlCQUF5QjtFQUN6QixzQkFBc0I7RUFDdEIscUJBQXFCO0VBQ3JCLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFDWixjQUFjO0VBQ2QsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSx3QkFBd0I7RUFDeEIsNkJBQTZCO0FBQy9CO0FBQ0E7RUFDRSxzQkFBc0I7RUFDdEIsMkJBQTJCO0FBQzdCO0FBQ0E7RUFDRSxzQkFBc0I7RUFDdEIsMkJBQTJCO0FBQzdCO0FBQ0Esd0dBQXdHO0FBQ3hHOztFQUVFO0lBQ0Usc0JBQXNCO0VBQ3hCO0FBQ0Y7QUFDQTtFQUNFLG1CQUFtQjtFQUNuQix5QkFBeUI7RUFDekIsc0JBQXNCO0VBQ3RCLHFCQUFxQjtFQUNyQixpQkFBaUI7O0VBRWpCLDZDQUE2QztFQUM3QyxrQkFBa0I7RUFDbEIsT0FBTztFQUNQLE1BQU07RUFDTixRQUFRO0VBQ1IsWUFBWTtFQUNaLFNBQVM7O0VBRVQsb0ZBQW9GO0VBQ3BGLHFCQUFxQjtFQUNyQixnQkFBZ0I7O0VBRWhCLHNFQUFzRTtFQUN0RSwrQkFBK0I7QUFDakM7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQixPQUFPO0VBQ1AsTUFBTTtFQUNOLFVBQVU7RUFDVixhQUFhLEVBQUUsNkVBQTZFO0VBQzVGLG1CQUFtQjtFQUNuQixZQUFZO0VBQ1osV0FBVztFQUNYLG9CQUFvQjtFQUNwQixnQkFBZ0I7O0VBRWhCLHFCQUFxQjtFQUNyQiwrQkFBK0I7QUFDakM7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsY0FBYzs7RUFFZCx5RUFBeUU7QUFDM0U7QUFDQTs7RUFFRSxzQkFBc0I7RUFDdEIseU1BQXlNO0VBQ3pNLDhCQUE4QjtBQUNoQztBQUNBOztFQUVFLGtCQUFrQjtFQUNsQixPQUFPO0VBQ1AsTUFBTTtFQUNOLHNCQUFzQjtBQUN4QjtBQUNBOztFQUVFLGdCQUFnQjtBQUNsQjtBQUNBOztFQUVFLFlBQVk7RUFDWixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtBQUNyQjtBQUNBOztFQUVFLHVCQUF1QjtBQUN6QjtBQUNBOztFQUVFLFNBQVM7RUFDVCxTQUFTO0VBQ1QsNkJBQTZCO0VBQzdCLHFCQUFxQjtBQUN2QjtBQUNBOzs7RUFHRSxzQkFBc0I7QUFDeEI7QUFDQTs7O0VBR0UscUJBQXFCO0FBQ3ZCO0FBQ0E7OztFQUdFLHNCQUFzQjtBQUN4QjtBQUNBOzs7O0VBSUUsdUNBQXVDO0FBQ3pDO0FBQ0E7O0VBRUUsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixxQkFBcUI7QUFDdkJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyohXFxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXcgNC42LjEwXFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgKi9cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctbWFya3VwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy13cmFwcGVyIHtcXG4gIHotaW5kZXg6IDI7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWluLWhlaWdodDogNXJlbTtcXG4gIG1heC1oZWlnaHQ6IDdyZW07XFxuICBtYXJnaW46IDA7XFxuICBvcGFjaXR5OiAwO1xcbiAgei1pbmRleDogMjtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3LW92ZXJsYXkgc3ZnIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBtYXgtaGVpZ2h0OiBpbmhlcml0O1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctb3ZlcmxheS1pZGxlIHtcXG4gIG1peC1ibGVuZC1tb2RlOiBtdWx0aXBseTtcXG4gIGNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIDAuODUpO1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctb3ZlcmxheS1zdWNjZXNzIHtcXG4gIG1peC1ibGVuZC1tb2RlOiBub3JtYWw7XFxuICBjb2xvcjogcmdiYSg1NCwgMTUxLCA5OSwgMSk7XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5LWZhaWx1cmUge1xcbiAgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDtcXG4gIGNvbG9yOiByZ2JhKDE5NiwgNzgsIDcxLCAxKTtcXG59XFxuLyogZGlzYWJsZSBmb3IgU2FmYXJpIGFzIG1peC1ibGVuZC1tb2RlIGNhdXNlcyB0aGUgb3ZlcmZsb3c6aGlkZGVuIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIHRvIG5vdCB3b3JrICovXFxuQHN1cHBvcnRzICgtd2Via2l0LW1hcnF1ZWUtcmVwZXRpdGlvbjogaW5maW5pdGUpIGFuZFxcbiAgKCgtby1vYmplY3QtZml0OiBmaWxsKSBvciAob2JqZWN0LWZpdDogZmlsbCkpIHtcXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5LWlkbGUge1xcbiAgICBtaXgtYmxlbmQtbW9kZTogbm9ybWFsO1xcbiAgfVxcbn1cXG4uZmlsZXBvbmQtLWltYWdlLXByZXZpZXctd3JhcHBlciB7XFxuICAvKiBubyBpbnRlcmFjdGlvbiAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG5cXG4gIC8qIGhhdmUgcHJldmlldyBmaWxsIHVwIGFsbCBhdmFpbGFibGUgc3BhY2UgKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1hcmdpbjogMDtcXG5cXG4gIC8qIHJhZGl1cyBpcyAuMDVlbSBsZXNzIHRvIHByZXZlbnQgdGhlIHBhbmVsIGJhY2tncm91bmQgY29sb3IgZnJvbSBzaGluaW5nIHRocm91Z2ggKi9cXG4gIGJvcmRlci1yYWRpdXM6IDAuNDVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICAvKiB0aGlzIHNlZW1zIHRvIHByZXZlbnQgQ2hyb21lIGZyb20gcmVkcmF3aW5nIHRoaXMgbGF5ZXIgY29uc3RhbnRseSAqL1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjAxKTtcXG59XFxuLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB6LWluZGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDsgLyogdGhpcyBhbGlnbnMgdGhlIGdyYXBoaWMgdmVydGljYWxseSBpZiB0aGUgcGFuZWwgaXMgaGlnaGVyIHRoYW4gdGhlIGltYWdlICovXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGJhY2tncm91bmQ6ICMyMjI7XFxuXFxuICAvKiB3aWxsIGJlIGFuaW1hdGVkICovXFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtLCBvcGFjaXR5O1xcbn1cXG4uZmlsZXBvbmQtLWltYWdlLWNsaXAge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIG1hcmdpbjogMCBhdXRvO1xcblxcbiAgLyogdHJhbnNwYXJlbmN5IGluZGljYXRvciAoY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgZ3JpZCBvciBiYXNpYyBjb2xvcikgKi9cXG59XFxuLmZpbGVwb25kLS1pbWFnZS1jbGlwW2RhdGEtdHJhbnNwYXJlbmN5LWluZGljYXRvcj0nZ3JpZCddIGltZyxcXG4uZmlsZXBvbmQtLWltYWdlLWNsaXBbZGF0YS10cmFuc3BhcmVuY3ktaW5kaWNhdG9yPSdncmlkJ10gY2FudmFzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0Nzdmcgdmlld0JveD0nMCAwIDEwMCAxMDAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgZmlsbD0nJTIzZWVlJyUzRSUzQ3BhdGggZD0nTTAgMCBINTAgVjUwIEgwJy8lM0UlM0NwYXRoIGQ9J001MCA1MCBIMTAwIFYxMDAgSDUwJy8lM0UlM0Mvc3ZnJTNFXFxcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEuMjVlbSAxLjI1ZW07XFxufVxcbi5maWxlcG9uZC0taW1hZ2UtYml0bWFwLFxcbi5maWxlcG9uZC0taW1hZ2UtdmVjdG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdpbnRlZ3JhdGVkJ11cXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy13cmFwcGVyIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2ludGVncmF0ZWQnXVxcbiAgLmZpbGVwb25kLS1pbWFnZS1wcmV2aWV3IHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLWltYWdlLXByZXZpZXctd3JhcHBlciB7XFxuICBib3JkZXItcmFkaXVzOiA5OTk5OXJlbTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5IHtcXG4gIHRvcDogYXV0bztcXG4gIGJvdHRvbTogMDtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xcbiAgdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xcbn1cXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdjaXJjbGUnXVxcbiAgLmZpbGVwb25kLS1maWxlXFxuICAuZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbltkYXRhLWFsaWduKj0nYm90dG9tJ106bm90KFtkYXRhLWFsaWduKj0nY2VudGVyJ10pIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuMzI1ZW07XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLWZpbGVcXG4gIFtkYXRhLWFsaWduKj0nbGVmdCddIHtcXG4gIGxlZnQ6IGNhbGMoNTAlIC0gM2VtKTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0tZmlsZVxcbiAgW2RhdGEtYWxpZ24qPSdyaWdodCddIHtcXG4gIHJpZ2h0OiBjYWxjKDUwJSAtIDNlbSk7XFxufVxcbi5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49J2NpcmNsZSddXFxuICAuZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvcltkYXRhLWFsaWduKj0nYm90dG9tJ11bZGF0YS1hbGlnbio9J2xlZnQnXSxcXG4uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PSdjaXJjbGUnXVxcbiAgLmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3JbZGF0YS1hbGlnbio9J2JvdHRvbSddW2RhdGEtYWxpZ24qPSdyaWdodCddIHtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC4zMjVlbSArIDAuMTg3NWVtKTtcXG59XFxuLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj0nY2lyY2xlJ11cXG4gIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9yW2RhdGEtYWxpZ24qPSdib3R0b20nXVtkYXRhLWFsaWduKj0nY2VudGVyJ10ge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDAuMTg3NWVtO1xcbiAgbWFyZ2luLWxlZnQ6IDAuMTg3NWVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0M7O0FBRWxDLDhCQUE4Qjs7QUFFOUIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHlDQUF5Qyw4RkFBOEYsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRXZlLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcz83NWU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js ***!
  \**************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileEncode 2.1.10\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  var DataURIWorker = function DataURIWorker() {\n    // route messages\n    self.onmessage = function(e) {\n      convert(e.data.message, function(response) {\n        self.postMessage({ id: e.data.id, message: response });\n      });\n    };\n\n    // convert file to data uri\n    var convert = function convert(options, cb) {\n      var file = options.file;\n\n      var reader = new FileReader();\n      reader.onloadend = function() {\n        cb(reader.result.replace('data:', '').replace(/^.+,/, ''));\n      };\n      reader.readAsDataURL(file);\n    };\n  };\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      createWorker = utils.createWorker,\n      createRoute = utils.createRoute,\n      isFile = utils.isFile;\n\n    var encode = function encode(_ref2) {\n      var name = _ref2.name,\n        file = _ref2.file;\n      return new Promise(function(resolve) {\n        var worker = createWorker(DataURIWorker);\n        worker.post({ file: file }, function(data) {\n          resolve({ name: name, data: data });\n          worker.terminate();\n        });\n      });\n    };\n\n    // holds base64 strings till can be moved to item\n    var base64Cache = [];\n    addFilter('DID_CREATE_ITEM', function(item, _ref3) {\n      var query = _ref3.query;\n\n      if (!query('GET_ALLOW_FILE_ENCODE')) return;\n\n      item.extend('getFileEncodeBase64String', function() {\n        return base64Cache[item.id] && base64Cache[item.id].data;\n      });\n      item.extend('getFileEncodeDataURL', function() {\n        return 'data:'\n          .concat(item.fileType, ';base64,')\n          .concat(base64Cache[item.id].data);\n      });\n    });\n\n    addFilter('SHOULD_PREPARE_OUTPUT', function(shouldPrepareOutput, _ref4) {\n      var query = _ref4.query;\n      return new Promise(function(resolve) {\n        resolve(query('GET_ALLOW_FILE_ENCODE'));\n      });\n    });\n\n    addFilter('COMPLETE_PREPARE_OUTPUT', function(file, _ref5) {\n      var item = _ref5.item,\n        query = _ref5.query;\n      return new Promise(function(resolve) {\n        // if it's not a file or a list of files, continue\n        if (\n          !query('GET_ALLOW_FILE_ENCODE') ||\n          (!isFile(file) && !Array.isArray(file))\n        ) {\n          return resolve(file);\n        }\n\n        // store metadata settings for this cache\n        base64Cache[item.id] = {\n          metadata: item.getMetadata(),\n          data: null\n        };\n\n        // wait for all file items to be encoded\n        Promise.all(\n          (file instanceof Blob ? [{ name: null, file: file }] : file).map(\n            encode\n          )\n        ).then(function(dataItems) {\n          base64Cache[item.id].data =\n            file instanceof Blob ? dataItems[0].data : dataItems;\n          resolve(file);\n        });\n      });\n    });\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      // only hook up to item view\n      if (!is('file-wrapper') || !query('GET_ALLOW_FILE_ENCODE')) {\n        return;\n      }\n\n      view.registerWriter(\n        createRoute({\n          DID_PREPARE_OUTPUT: function DID_PREPARE_OUTPUT(_ref6) {\n            var root = _ref6.root,\n              action = _ref6.action;\n\n            // only do this if is not uploading async\n            if (query('IS_ASYNC')) {\n              return;\n            }\n\n            var item = query('GET_ITEM', action.id);\n            if (!item) return;\n\n            // extract base64 string\n            var cache = base64Cache[item.id];\n            var metadata = cache.metadata;\n            var data = cache.data;\n\n            // create JSON string from encoded data\n            var value = JSON.stringify({\n              id: item.id,\n              name: item.file.name,\n              type: item.file.type,\n              size: item.file.size,\n              metadata: metadata,\n              data: data\n            });\n\n            // for filepond < 4.13.0\n            if (root.ref.data) {\n              root.ref.data.value = value;\n            }\n            // newer versions\n            else {\n              root.dispatch('DID_DEFINE_VALUE', {\n                id: item.id,\n                value: value\n              });\n            }\n          },\n          DID_REMOVE_ITEM: function DID_REMOVE_ITEM(_ref7) {\n            var action = _ref7.action;\n            var item = query('GET_ITEM', action.id);\n            if (!item) return;\n            delete base64Cache[item.id];\n          }\n        })\n      );\n    });\n\n    return {\n      options: {\n        // Enable or disable file encoding\n        allowFileEncode: [true, Type.BOOLEAN]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxDQUc4QztBQUNwRCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLWVuY29kZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLWVuY29kZS5qcz83NGU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5GaWxlRW5jb2RlIDIuMS4xMFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVFbmNvZGUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERhdGFVUklXb3JrZXIgPSBmdW5jdGlvbiBEYXRhVVJJV29ya2VyKCkge1xuICAgIC8vIHJvdXRlIG1lc3NhZ2VzXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBjb252ZXJ0KGUuZGF0YS5tZXNzYWdlLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgbWVzc2FnZTogcmVzcG9uc2UgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gY29udmVydCBmaWxlIHRvIGRhdGEgdXJpXG4gICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KG9wdGlvbnMsIGNiKSB7XG4gICAgICB2YXIgZmlsZSA9IG9wdGlvbnMuZmlsZTtcblxuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHJlYWRlci5yZXN1bHQucmVwbGFjZSgnZGF0YTonLCAnJykucmVwbGFjZSgvXi4rLC8sICcnKSk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKF9yZWYpIHtcbiAgICB2YXIgYWRkRmlsdGVyID0gX3JlZi5hZGRGaWx0ZXIsXG4gICAgICB1dGlscyA9IF9yZWYudXRpbHM7XG5cbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlIHRvIFR5cGUgdXRpbHNcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICBjcmVhdGVXb3JrZXIgPSB1dGlscy5jcmVhdGVXb3JrZXIsXG4gICAgICBjcmVhdGVSb3V0ZSA9IHV0aWxzLmNyZWF0ZVJvdXRlLFxuICAgICAgaXNGaWxlID0gdXRpbHMuaXNGaWxlO1xuXG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShfcmVmMikge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICBmaWxlID0gX3JlZjIuZmlsZTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBjcmVhdGVXb3JrZXIoRGF0YVVSSVdvcmtlcik7XG4gICAgICAgIHdvcmtlci5wb3N0KHsgZmlsZTogZmlsZSB9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZSh7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBob2xkcyBiYXNlNjQgc3RyaW5ncyB0aWxsIGNhbiBiZSBtb3ZlZCB0byBpdGVtXG4gICAgdmFyIGJhc2U2NENhY2hlID0gW107XG4gICAgYWRkRmlsdGVyKCdESURfQ1JFQVRFX0lURU0nLCBmdW5jdGlvbihpdGVtLCBfcmVmMykge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG5cbiAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX0VOQ09ERScpKSByZXR1cm47XG5cbiAgICAgIGl0ZW0uZXh0ZW5kKCdnZXRGaWxlRW5jb2RlQmFzZTY0U3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjRDYWNoZVtpdGVtLmlkXSAmJiBiYXNlNjRDYWNoZVtpdGVtLmlkXS5kYXRhO1xuICAgICAgfSk7XG4gICAgICBpdGVtLmV4dGVuZCgnZ2V0RmlsZUVuY29kZURhdGFVUkwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhOidcbiAgICAgICAgICAuY29uY2F0KGl0ZW0uZmlsZVR5cGUsICc7YmFzZTY0LCcpXG4gICAgICAgICAgLmNvbmNhdChiYXNlNjRDYWNoZVtpdGVtLmlkXS5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWRkRmlsdGVyKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmdW5jdGlvbihzaG91bGRQcmVwYXJlT3V0cHV0LCBfcmVmNCkge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjQucXVlcnk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKHF1ZXJ5KCdHRVRfQUxMT1dfRklMRV9FTkNPREUnKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZEZpbHRlcignQ09NUExFVEVfUFJFUEFSRV9PVVRQVVQnLCBmdW5jdGlvbihmaWxlLCBfcmVmNSkge1xuICAgICAgdmFyIGl0ZW0gPSBfcmVmNS5pdGVtLFxuICAgICAgICBxdWVyeSA9IF9yZWY1LnF1ZXJ5O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgLy8gaWYgaXQncyBub3QgYSBmaWxlIG9yIGEgbGlzdCBvZiBmaWxlcywgY29udGludWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfRU5DT0RFJykgfHxcbiAgICAgICAgICAoIWlzRmlsZShmaWxlKSAmJiAhQXJyYXkuaXNBcnJheShmaWxlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBtZXRhZGF0YSBzZXR0aW5ncyBmb3IgdGhpcyBjYWNoZVxuICAgICAgICBiYXNlNjRDYWNoZVtpdGVtLmlkXSA9IHtcbiAgICAgICAgICBtZXRhZGF0YTogaXRlbS5nZXRNZXRhZGF0YSgpLFxuICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3YWl0IGZvciBhbGwgZmlsZSBpdGVtcyB0byBiZSBlbmNvZGVkXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIChmaWxlIGluc3RhbmNlb2YgQmxvYiA/IFt7IG5hbWU6IG51bGwsIGZpbGU6IGZpbGUgfV0gOiBmaWxlKS5tYXAoXG4gICAgICAgICAgICBlbmNvZGVcbiAgICAgICAgICApXG4gICAgICAgICkudGhlbihmdW5jdGlvbihkYXRhSXRlbXMpIHtcbiAgICAgICAgICBiYXNlNjRDYWNoZVtpdGVtLmlkXS5kYXRhID1cbiAgICAgICAgICAgIGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gZGF0YUl0ZW1zWzBdLmRhdGEgOiBkYXRhSXRlbXM7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGNhbGxlZCBmb3IgZWFjaCB2aWV3IHRoYXQgaXMgY3JlYXRlZCByaWdodCBhZnRlciB0aGUgJ2NyZWF0ZScgbWV0aG9kXG4gICAgYWRkRmlsdGVyKCdDUkVBVEVfVklFVycsIGZ1bmN0aW9uKHZpZXdBUEkpIHtcbiAgICAgIC8vIGdldCByZWZlcmVuY2UgdG8gY3JlYXRlZCB2aWV3XG4gICAgICB2YXIgaXMgPSB2aWV3QVBJLmlzLFxuICAgICAgICB2aWV3ID0gdmlld0FQSS52aWV3LFxuICAgICAgICBxdWVyeSA9IHZpZXdBUEkucXVlcnk7XG5cbiAgICAgIC8vIG9ubHkgaG9vayB1cCB0byBpdGVtIHZpZXdcbiAgICAgIGlmICghaXMoJ2ZpbGUtd3JhcHBlcicpIHx8ICFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfRU5DT0RFJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2aWV3LnJlZ2lzdGVyV3JpdGVyKFxuICAgICAgICBjcmVhdGVSb3V0ZSh7XG4gICAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBmdW5jdGlvbiBESURfUFJFUEFSRV9PVVRQVVQoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaWYgaXMgbm90IHVwbG9hZGluZyBhc3luY1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KCdJU19BU1lOQycpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBxdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGV4dHJhY3QgYmFzZTY0IHN0cmluZ1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gYmFzZTY0Q2FjaGVbaXRlbS5pZF07XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBjYWNoZS5tZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gY2FjaGUuZGF0YTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIEpTT04gc3RyaW5nIGZyb20gZW5jb2RlZCBkYXRhXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICBuYW1lOiBpdGVtLmZpbGUubmFtZSxcbiAgICAgICAgICAgICAgdHlwZTogaXRlbS5maWxlLnR5cGUsXG4gICAgICAgICAgICAgIHNpemU6IGl0ZW0uZmlsZS5zaXplLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBmb3IgZmlsZXBvbmQgPCA0LjEzLjBcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5kYXRhKSB7XG4gICAgICAgICAgICAgIHJvb3QucmVmLmRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5ld2VyIHZlcnNpb25zXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBESURfUkVNT1ZFX0lURU06IGZ1bmN0aW9uIERJRF9SRU1PVkVfSVRFTShfcmVmNykge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICAgICAgZGVsZXRlIGJhc2U2NENhY2hlW2l0ZW0uaWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIGVuY29kaW5nXG4gICAgICAgIGFsbG93RmlsZUVuY29kZTogW3RydWUsIFR5cGUuQk9PTEVBTl1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js ***!
  \****************************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileValidateSize 2.2.4\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? (module.exports = factory())\n        : 0;\n})(this, function() {\n    'use strict';\n\n    var plugin = function plugin(_ref) {\n        var addFilter = _ref.addFilter,\n            utils = _ref.utils;\n        // get quick reference to Type utils\n        var Type = utils.Type,\n            replaceInString = utils.replaceInString,\n            toNaturalFileSize = utils.toNaturalFileSize;\n\n        // filtering if an item is allowed in hopper\n        addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n            var query = _ref2.query;\n            if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n                return true;\n            }\n\n            var sizeMax = query('GET_MAX_FILE_SIZE');\n            if (sizeMax !== null && file.size >= sizeMax) {\n                return false;\n            }\n\n            var sizeMin = query('GET_MIN_FILE_SIZE');\n            if (sizeMin !== null && file.size <= sizeMin) {\n                return false;\n            }\n\n            return true;\n        });\n\n        // called for each file that is loaded\n        // right before it is set to the item state\n        // should return a promise\n        addFilter('LOAD_FILE', function(file, _ref3) {\n            var query = _ref3.query;\n            return new Promise(function(resolve, reject) {\n                // if not allowed, all fine, exit\n                if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n                    return resolve(file);\n                }\n\n                // check if file should be filtered\n                var fileFilter = query('GET_FILE_VALIDATE_SIZE_FILTER');\n                if (fileFilter && !fileFilter(file)) {\n                    return resolve(file);\n                }\n\n                // reject or resolve based on file size\n                var sizeMax = query('GET_MAX_FILE_SIZE');\n                if (sizeMax !== null && file.size >= sizeMax) {\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_MAX_FILE_SIZE_EXCEEDED'),\n                            sub: replaceInString(query('GET_LABEL_MAX_FILE_SIZE'), {\n                                filesize: toNaturalFileSize(\n                                    sizeMax,\n                                    '.',\n                                    query('GET_FILE_SIZE_BASE')\n                                ),\n                            }),\n                        },\n                    });\n\n                    return;\n                }\n\n                // reject or resolve based on file size\n                var sizeMin = query('GET_MIN_FILE_SIZE');\n                if (sizeMin !== null && file.size <= sizeMin) {\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_MIN_FILE_SIZE_EXCEEDED'),\n                            sub: replaceInString(query('GET_LABEL_MIN_FILE_SIZE'), {\n                                filesize: toNaturalFileSize(\n                                    sizeMin,\n                                    '.',\n                                    query('GET_FILE_SIZE_BASE')\n                                ),\n                            }),\n                        },\n                    });\n\n                    return;\n                }\n\n                // returns the current option value\n                var totalSizeMax = query('GET_MAX_TOTAL_FILE_SIZE');\n                if (totalSizeMax !== null) {\n                    // get the current total file size\n                    var currentTotalSize = query('GET_ACTIVE_ITEMS').reduce(function(total, item) {\n                        return total + item.fileSize;\n                    }, 0);\n\n                    // get the size of the new file\n                    if (currentTotalSize > totalSizeMax) {\n                        reject({\n                            status: {\n                                main: query('GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED'),\n                                sub: replaceInString(query('GET_LABEL_MAX_TOTAL_FILE_SIZE'), {\n                                    filesize: toNaturalFileSize(totalSizeMax),\n                                }),\n                            },\n                        });\n\n                        return;\n                    }\n                }\n\n                // file is fine, let's pass it back\n                resolve(file);\n            });\n        });\n\n        return {\n            options: {\n                // Enable or disable file type validation\n                allowFileSizeValidation: [true, Type.BOOLEAN],\n\n                // Max individual file size in bytes\n                maxFileSize: [null, Type.INT],\n\n                // Min individual file size in bytes\n                minFileSize: [null, Type.INT],\n\n                // Max total file size in bytes\n                maxTotalFileSize: [null, Type.INT],\n\n                // Filter the files that need to be validated for size\n                fileValidateSizeFilter: [null, Type.FUNCTION],\n\n                // error labels\n                labelMinFileSizeExceeded: ['File is too small', Type.STRING],\n                labelMinFileSize: ['Minimum file size is {filesize}', Type.STRING],\n\n                labelMaxFileSizeExceeded: ['File is too large', Type.STRING],\n                labelMaxFileSize: ['Maximum file size is {filesize}', Type.STRING],\n\n                labelMaxTotalFileSizeExceeded: ['Maximum total size exceeded', Type.STRING],\n                labelMaxTotalFileSize: ['Maximum total file size is {filesize}', Type.STRING],\n            },\n        };\n    };\n\n    // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n    var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    if (isBrowser) {\n        document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n    }\n\n    return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEU7QUFDQSxVQUFVLENBRWdGO0FBQzFGLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxTQUFTOztBQUVuRTtBQUNBLDBEQUEwRCxTQUFTOztBQUVuRTtBQUNBLHFFQUFxRSxTQUFTO0FBQzlFLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS1zaXplLmpzPzNiOTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgMi4yLjRcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICAgICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSwgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgICAgICB2YXIgYWRkRmlsdGVyID0gX3JlZi5hZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlscyA9IF9yZWYudXRpbHM7XG4gICAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgICAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICAgICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZSA9IHV0aWxzLnRvTmF0dXJhbEZpbGVTaXplO1xuXG4gICAgICAgIC8vIGZpbHRlcmluZyBpZiBhbiBpdGVtIGlzIGFsbG93ZWQgaW4gaG9wcGVyXG4gICAgICAgIGFkZEZpbHRlcignQUxMT1dfSE9QUEVSX0lURU0nLCBmdW5jdGlvbihmaWxlLCBfcmVmMikge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KCdHRVRfQUxMT1dfRklMRV9TSVpFX1ZBTElEQVRJT04nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2l6ZU1heCA9IHF1ZXJ5KCdHRVRfTUFYX0ZJTEVfU0laRScpO1xuICAgICAgICAgICAgaWYgKHNpemVNYXggIT09IG51bGwgJiYgZmlsZS5zaXplID49IHNpemVNYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaXplTWluID0gcXVlcnkoJ0dFVF9NSU5fRklMRV9TSVpFJyk7XG4gICAgICAgICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGxlZCBmb3IgZWFjaCBmaWxlIHRoYXQgaXMgbG9hZGVkXG4gICAgICAgIC8vIHJpZ2h0IGJlZm9yZSBpdCBpcyBzZXQgdG8gdGhlIGl0ZW0gc3RhdGVcbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgYWRkRmlsdGVyKCdMT0FEX0ZJTEUnLCBmdW5jdGlvbihmaWxlLCBfcmVmMykge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQsIGFsbCBmaW5lLCBleGl0XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfU0laRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZmlsZSBzaG91bGQgYmUgZmlsdGVyZWRcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUZpbHRlciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9TSVpFX0ZJTFRFUicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlRmlsdGVyICYmICFmaWxlRmlsdGVyKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICAgICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVNYXggIT09IG51bGwgJiYgZmlsZS5zaXplID49IHNpemVNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX0ZJTEVfU0laRV9FWENFRURFRCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzaXplOiB0b05hdHVyYWxGaWxlU2l6ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfU0laRV9CQVNFJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZWplY3Qgb3IgcmVzb2x2ZSBiYXNlZCBvbiBmaWxlIHNpemVcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZU1pbiA9IHF1ZXJ5KCdHRVRfTUlOX0ZJTEVfU0laRScpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplTWluICE9PSBudWxsICYmIGZpbGUuc2l6ZSA8PSBzaXplTWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01JTl9GSUxFX1NJWkVfRVhDRUVERUQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHJlcGxhY2VJblN0cmluZyhxdWVyeSgnR0VUX0xBQkVMX01JTl9GSUxFX1NJWkUnKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplTWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1NJWkVfQkFTRScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgY3VycmVudCBvcHRpb24gdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxTaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfVE9UQUxfRklMRV9TSVpFJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZU1heCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdG90YWwgZmlsZSBzaXplXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VG90YWxTaXplID0gcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKS5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCArIGl0ZW0uZmlsZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc2l6ZSBvZiB0aGUgbmV3IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUb3RhbFNpemUgPiB0b3RhbFNpemVNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX1RPVEFMX0ZJTEVfU0laRV9FWENFRURFRCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHJlcGxhY2VJblN0cmluZyhxdWVyeSgnR0VUX0xBQkVMX01BWF9UT1RBTF9GSUxFX1NJWkUnKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKHRvdGFsU2l6ZU1heCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsZSBpcyBmaW5lLCBsZXQncyBwYXNzIGl0IGJhY2tcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBhbGxvd0ZpbGVTaXplVmFsaWRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgICAgICAgICAvLyBNYXggaW5kaXZpZHVhbCBmaWxlIHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAgICAgICAgIC8vIE1pbiBpbmRpdmlkdWFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICAgICAgICAgIG1pbkZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgICAgICAgICAgLy8gTWF4IHRvdGFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICAgICAgICAgIG1heFRvdGFsRmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGZpbGVzIHRoYXQgbmVlZCB0byBiZSB2YWxpZGF0ZWQgZm9yIHNpemVcbiAgICAgICAgICAgICAgICBmaWxlVmFsaWRhdGVTaXplRmlsdGVyOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciBsYWJlbHNcbiAgICAgICAgICAgICAgICBsYWJlbE1pbkZpbGVTaXplRXhjZWVkZWQ6IFsnRmlsZSBpcyB0b28gc21hbGwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgICAgICAgICAgbGFiZWxNaW5GaWxlU2l6ZTogWydNaW5pbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgICAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZUV4Y2VlZGVkOiBbJ0ZpbGUgaXMgdG9vIGxhcmdlJywgVHlwZS5TVFJJTkddLFxuICAgICAgICAgICAgICAgIGxhYmVsTWF4RmlsZVNpemU6IFsnTWF4aW11bSBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAgICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiBbJ01heGltdW0gdG90YWwgc2l6ZSBleGNlZWRlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6IFsnTWF4aW11bSB0b3RhbCBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js ***!
  \****************************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileValidateType 1.2.6\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      isString = utils.isString,\n      replaceInString = utils.replaceInString,\n      guesstimateMimeType = utils.guesstimateMimeType,\n      getExtensionFromFilename = utils.getExtensionFromFilename,\n      getFilenameFromURL = utils.getFilenameFromURL;\n\n    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(\n      mimeType,\n      wildcard\n    ) {\n      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n      return mimeTypeGroup === wildcardGroup;\n    };\n\n    var isValidMimeType = function isValidMimeType(\n      acceptedTypes,\n      userInputType\n    ) {\n      return acceptedTypes.some(function(acceptedType) {\n        // accepted is wildcard mime type\n        if (/\\*$/.test(acceptedType)) {\n          return mimeTypeMatchesWildCard(userInputType, acceptedType);\n        }\n\n        // is normal mime type\n        return acceptedType === userInputType;\n      });\n    };\n\n    var getItemType = function getItemType(item) {\n      // if the item is a url we guess the mime type by the extension\n      var type = '';\n      if (isString(item)) {\n        var filename = getFilenameFromURL(item);\n        var extension = getExtensionFromFilename(filename);\n        if (extension) {\n          type = guesstimateMimeType(extension);\n        }\n      } else {\n        type = item.type;\n      }\n\n      return type;\n    };\n\n    var validateFile = function validateFile(\n      item,\n      acceptedFileTypes,\n      typeDetector\n    ) {\n      // no types defined, everything is allowed \\o/\n      if (acceptedFileTypes.length === 0) {\n        return true;\n      }\n\n      // gets the item type\n      var type = getItemType(item);\n\n      // no type detector, test now\n      if (!typeDetector) {\n        return isValidMimeType(acceptedFileTypes, type);\n      }\n\n      // use type detector\n      return new Promise(function(resolve, reject) {\n        typeDetector(item, type)\n          .then(function(detectedType) {\n            if (isValidMimeType(acceptedFileTypes, detectedType)) {\n              resolve();\n            } else {\n              reject();\n            }\n          })\n          .catch(reject);\n      });\n    };\n\n    var applyMimeTypeMap = function applyMimeTypeMap(map) {\n      return function(acceptedFileType) {\n        return map[acceptedFileType] === null\n          ? false\n          : map[acceptedFileType] || acceptedFileType;\n      };\n    };\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n      return Object.assign(map, {\n        accept: 'acceptedFileTypes'\n      });\n    });\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      // if we are not doing file type validation exit\n      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n        return true;\n      }\n\n      // we validate the file against the accepted file types\n      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n        // custom type detector method\n        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n        // if invalid, exit here\n        var validationResult = validateFile(\n          file,\n          acceptedFileTypes,\n          typeDetector\n        );\n\n        var handleRejection = function handleRejection() {\n          var acceptedFileTypesMapped = acceptedFileTypes\n            .map(\n              applyMimeTypeMap(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n              )\n            )\n            .filter(function(label) {\n              return label !== false;\n            });\n\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                {\n                  allTypes: acceptedFileTypesMapped.join(', '),\n                  allButLastType: acceptedFileTypesMapped\n                    .slice(0, -1)\n                    .join(', '),\n                  lastType:\n                    acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]\n                }\n              )\n            }\n          });\n        };\n\n        // has returned new filename immidiately\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n          return resolve(file);\n        }\n\n        // is promise\n        validationResult\n          .then(function() {\n            resolve(file);\n          })\n          .catch(handleRejection);\n      });\n    });\n\n    // expose plugin\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowFileTypeValidation: [true, Type.BOOLEAN],\n\n        // What file types to accept\n        acceptedFileTypes: [[], Type.ARRAY],\n        // - must be comma separated\n        // - mime types: image/png, image/jpeg, image/gif\n        // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n        // - wildcards: image/*\n\n        // label to show when a type is not allowed\n        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n        // nicer label\n        fileValidateTypeLabelExpectedTypes: [\n          'Expects {allButLastType} or {lastType}',\n          Type.STRING\n        ],\n\n        // map mime types to extensions\n        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n        // Custom function to detect type of file\n        fileValidateTypeDetectType: [null, Type.FUNCTION]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQ7QUFDQSxNQUFNLENBR29EO0FBQzFELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0IsSUFBSSxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanM/MTk0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSAxLjIuNlxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF9yZWYuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzO1xuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICBndWVzc3RpbWF0ZU1pbWVUeXBlID0gdXRpbHMuZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSA9IHV0aWxzLmdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgIGdldEZpbGVuYW1lRnJvbVVSTCA9IHV0aWxzLmdldEZpbGVuYW1lRnJvbVVSTDtcblxuICAgIHZhciBtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCA9IGZ1bmN0aW9uIG1pbWVUeXBlTWF0Y2hlc1dpbGRDYXJkKFxuICAgICAgbWltZVR5cGUsXG4gICAgICB3aWxkY2FyZFxuICAgICkge1xuICAgICAgdmFyIG1pbWVUeXBlR3JvdXAgPSAoL15bXi9dKy8uZXhlYyhtaW1lVHlwZSkgfHwgW10pLnBvcCgpOyAvLyBpbWFnZS9wbmcgLT4gaW1hZ2VcbiAgICAgIHZhciB3aWxkY2FyZEdyb3VwID0gd2lsZGNhcmQuc2xpY2UoMCwgLTIpOyAvLyBpbWFnZS8qIC0+IGltYWdlXG4gICAgICByZXR1cm4gbWltZVR5cGVHcm91cCA9PT0gd2lsZGNhcmRHcm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGlzVmFsaWRNaW1lVHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRNaW1lVHlwZShcbiAgICAgIGFjY2VwdGVkVHlwZXMsXG4gICAgICB1c2VySW5wdXRUeXBlXG4gICAgKSB7XG4gICAgICByZXR1cm4gYWNjZXB0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uKGFjY2VwdGVkVHlwZSkge1xuICAgICAgICAvLyBhY2NlcHRlZCBpcyB3aWxkY2FyZCBtaW1lIHR5cGVcbiAgICAgICAgaWYgKC9cXCokLy50ZXN0KGFjY2VwdGVkVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWltZVR5cGVNYXRjaGVzV2lsZENhcmQodXNlcklucHV0VHlwZSwgYWNjZXB0ZWRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIG5vcm1hbCBtaW1lIHR5cGVcbiAgICAgICAgcmV0dXJuIGFjY2VwdGVkVHlwZSA9PT0gdXNlcklucHV0VHlwZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbVR5cGUgPSBmdW5jdGlvbiBnZXRJdGVtVHlwZShpdGVtKSB7XG4gICAgICAvLyBpZiB0aGUgaXRlbSBpcyBhIHVybCB3ZSBndWVzcyB0aGUgbWltZSB0eXBlIGJ5IHRoZSBleHRlbnNpb25cbiAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tVVJMKGl0ZW0pO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGV4dGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICB2YXIgdmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gdmFsaWRhdGVGaWxlKFxuICAgICAgaXRlbSxcbiAgICAgIGFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgdHlwZURldGVjdG9yXG4gICAgKSB7XG4gICAgICAvLyBubyB0eXBlcyBkZWZpbmVkLCBldmVyeXRoaW5nIGlzIGFsbG93ZWQgXFxvL1xuICAgICAgaWYgKGFjY2VwdGVkRmlsZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0cyB0aGUgaXRlbSB0eXBlXG4gICAgICB2YXIgdHlwZSA9IGdldEl0ZW1UeXBlKGl0ZW0pO1xuXG4gICAgICAvLyBubyB0eXBlIGRldGVjdG9yLCB0ZXN0IG5vd1xuICAgICAgaWYgKCF0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSB0eXBlIGRldGVjdG9yXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHR5cGVEZXRlY3RvcihpdGVtLCB0eXBlKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgZGV0ZWN0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhcHBseU1pbWVUeXBlTWFwID0gZnVuY3Rpb24gYXBwbHlNaW1lVHlwZU1hcChtYXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhY2NlcHRlZEZpbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gPT09IG51bGxcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gfHwgYWNjZXB0ZWRGaWxlVHlwZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHNldHVwIGF0dHJpYnV0ZSBtYXBwaW5nIGZvciBhY2NlcHRcbiAgICBhZGRGaWx0ZXIoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgIGFjY2VwdDogJ2FjY2VwdGVkRmlsZVR5cGVzJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBmaWx0ZXJpbmcgaWYgYW4gaXRlbSBpcyBhbGxvd2VkIGluIGhvcHBlclxuICAgIGFkZEZpbHRlcignQUxMT1dfSE9QUEVSX0lURU0nLCBmdW5jdGlvbihmaWxlLCBfcmVmMikge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG4gICAgICAvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGZpbGUgdHlwZSB2YWxpZGF0aW9uIGV4aXRcbiAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB2YWxpZGF0ZSB0aGUgZmlsZSBhZ2FpbnN0IHRoZSBhY2NlcHRlZCBmaWxlIHR5cGVzXG4gICAgICByZXR1cm4gdmFsaWRhdGVGaWxlKGZpbGUsIHF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpKTtcbiAgICB9KTtcblxuICAgIC8vIGNhbGxlZCBmb3IgZWFjaCBmaWxlIHRoYXQgaXMgbG9hZGVkXG4gICAgLy8gcmlnaHQgYmVmb3JlIGl0IGlzIHNldCB0byB0aGUgaXRlbSBzdGF0ZVxuICAgIC8vIHNob3VsZCByZXR1cm4gYSBwcm9taXNlXG4gICAgYWRkRmlsdGVyKCdMT0FEX0ZJTEUnLCBmdW5jdGlvbihmaWxlLCBfcmVmMykge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXMgPSBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKTtcblxuICAgICAgICAvLyBjdXN0b20gdHlwZSBkZXRlY3RvciBtZXRob2RcbiAgICAgICAgdmFyIHR5cGVEZXRlY3RvciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9UWVBFX0RFVEVDVF9UWVBFJyk7XG5cbiAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0ID0gdmFsaWRhdGVGaWxlKFxuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgICAgdHlwZURldGVjdG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGhhbmRsZVJlamVjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbigpIHtcbiAgICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgYXBwbHlNaW1lVHlwZU1hcChcbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcoXG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhbGxUeXBlczogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICAgIGFsbEJ1dExhc3RUeXBlOiBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpLFxuICAgICAgICAgICAgICAgICAgbGFzdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkW2FjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaGFzIHJldHVybmVkIG5ldyBmaWxlbmFtZSBpbW1pZGlhdGVseVxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlamVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHByb21pc2VcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChoYW5kbGVSZWplY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgcGx1Z2luXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIHR5cGUgdmFsaWRhdGlvblxuICAgICAgICBhbGxvd0ZpbGVUeXBlVmFsaWRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICBhY2NlcHRlZEZpbGVUeXBlczogW1tdLCBUeXBlLkFSUkFZXSxcbiAgICAgICAgLy8gLSBtdXN0IGJlIGNvbW1hIHNlcGFyYXRlZFxuICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgIC8vIC0gZXh0ZW5zaW9uczogLnBuZywgLmpwZywgLmpwZWcgKCBub3QgZW5hYmxlZCB5ZXQgKVxuICAgICAgICAvLyAtIHdpbGRjYXJkczogaW1hZ2UvKlxuXG4gICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgbGFiZWxGaWxlVHlwZU5vdEFsbG93ZWQ6IFsnRmlsZSBpcyBvZiBpbnZhbGlkIHR5cGUnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gbmljZXIgbGFiZWxcbiAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICdFeHBlY3RzIHthbGxCdXRMYXN0VHlwZX0gb3Ige2xhc3RUeXBlfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBtYXAgbWltZSB0eXBlcyB0byBleHRlbnNpb25zXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVMYWJlbEV4cGVjdGVkVHlwZXNNYXA6IFt7fSwgVHlwZS5PQkpFQ1RdLFxuXG4gICAgICAgIC8vIEN1c3RvbSBmdW5jdGlvbiB0byBkZXRlY3QgdHlwZSBvZiBmaWxlXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVEZXRlY3RUeXBlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-crop/dist/filepond-plugin-image-crop.js":
/*!************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-crop/dist/filepond-plugin-image-crop.js ***!
  \************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImageCrop 2.0.6\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  var isImage = function isImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  /**\n   * Image Auto Crop Plugin\n   */\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    var Type = utils.Type,\n      isFile = utils.isFile,\n      getNumericAspectRatioFromString = utils.getNumericAspectRatioFromString;\n\n    // tests if crop is allowed on this item\n    var allowCrop = function allowCrop(item, query) {\n      return !(!isImage(item.file) || !query('GET_ALLOW_IMAGE_CROP'));\n    };\n\n    var isObject = function isObject(value) {\n      return typeof value === 'object';\n    };\n\n    var isNumber = function isNumber(value) {\n      return typeof value === 'number';\n    };\n\n    var updateCrop = function updateCrop(item, obj) {\n      return item.setMetadata(\n        'crop',\n        Object.assign({}, item.getMetadata('crop'), obj)\n      );\n    };\n\n    // extend item methods\n    addFilter('DID_CREATE_ITEM', function(item, _ref2) {\n      var query = _ref2.query;\n\n      item.extend('setImageCrop', function(crop) {\n        if (!allowCrop(item, query) || !isObject(center)) return;\n        item.setMetadata('crop', crop);\n        return crop;\n      });\n\n      item.extend('setImageCropCenter', function(center) {\n        if (!allowCrop(item, query) || !isObject(center)) return;\n        return updateCrop(item, { center: center });\n      });\n\n      item.extend('setImageCropZoom', function(zoom) {\n        if (!allowCrop(item, query) || !isNumber(zoom)) return;\n        return updateCrop(item, { zoom: Math.max(1, zoom) });\n      });\n\n      item.extend('setImageCropRotation', function(rotation) {\n        if (!allowCrop(item, query) || !isNumber(rotation)) return;\n        return updateCrop(item, { rotation: rotation });\n      });\n\n      item.extend('setImageCropFlip', function(flip) {\n        if (!allowCrop(item, query) || !isObject(flip)) return;\n        return updateCrop(item, { flip: flip });\n      });\n\n      item.extend('setImageCropAspectRatio', function(newAspectRatio) {\n        if (!allowCrop(item, query) || typeof newAspectRatio === 'undefined')\n          return;\n\n        var currentCrop = item.getMetadata('crop');\n\n        var aspectRatio = getNumericAspectRatioFromString(newAspectRatio);\n\n        var newCrop = {\n          center: {\n            x: 0.5,\n            y: 0.5\n          },\n\n          flip: currentCrop\n            ? Object.assign({}, currentCrop.flip)\n            : {\n                horizontal: false,\n                vertical: false\n              },\n\n          rotation: 0,\n          zoom: 1,\n          aspectRatio: aspectRatio\n        };\n\n        item.setMetadata('crop', newCrop);\n\n        return newCrop;\n      });\n    });\n\n    // subscribe to file transformations\n    addFilter('DID_LOAD_ITEM', function(item, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        // get file reference\n        var file = item.file;\n\n        // if this is not an image we do not have any business cropping it and we'll continue with the unaltered dataset\n        if (!isFile(file) || !isImage(file) || !query('GET_ALLOW_IMAGE_CROP')) {\n          return resolve(item);\n        }\n\n        // already has crop metadata set?\n        var crop = item.getMetadata('crop');\n        if (crop) {\n          return resolve(item);\n        }\n\n        // get the required aspect ratio and exit if it's not set\n        var humanAspectRatio = query('GET_IMAGE_CROP_ASPECT_RATIO');\n\n        // set default crop rectangle\n        item.setMetadata('crop', {\n          center: {\n            x: 0.5,\n            y: 0.5\n          },\n\n          flip: {\n            horizontal: false,\n            vertical: false\n          },\n\n          rotation: 0,\n          zoom: 1,\n          aspectRatio: humanAspectRatio\n            ? getNumericAspectRatioFromString(humanAspectRatio)\n            : null\n        });\n\n        // we done!\n        resolve(item);\n      });\n    });\n\n    // Expose plugin options\n    return {\n      options: {\n        // enable or disable image cropping\n        allowImageCrop: [true, Type.BOOLEAN],\n\n        // the aspect ratio of the crop ('1:1', '16:9', etc)\n        imageCropAspectRatio: [null, Type.STRING]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWNyb3AvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtY3JvcC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FFeUU7QUFDL0UsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xELE9BQU87O0FBRVA7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RCxPQUFPOztBQUVQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1jcm9wL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWNyb3AuanM/OTY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luSW1hZ2VDcm9wIDIuMC42XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyAobW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5JbWFnZUNyb3AgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiBpc0ltYWdlKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZS8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbWFnZSBBdXRvIENyb3AgUGx1Z2luXG4gICAqL1xuICB2YXIgcGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKF9yZWYpIHtcbiAgICB2YXIgYWRkRmlsdGVyID0gX3JlZi5hZGRGaWx0ZXIsXG4gICAgICB1dGlscyA9IF9yZWYudXRpbHM7XG4gICAgdmFyIFR5cGUgPSB1dGlscy5UeXBlLFxuICAgICAgaXNGaWxlID0gdXRpbHMuaXNGaWxlLFxuICAgICAgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IHV0aWxzLmdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmc7XG5cbiAgICAvLyB0ZXN0cyBpZiBjcm9wIGlzIGFsbG93ZWQgb24gdGhpcyBpdGVtXG4gICAgdmFyIGFsbG93Q3JvcCA9IGZ1bmN0aW9uIGFsbG93Q3JvcChpdGVtLCBxdWVyeSkge1xuICAgICAgcmV0dXJuICEoIWlzSW1hZ2UoaXRlbS5maWxlKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9DUk9QJykpO1xuICAgIH07XG5cbiAgICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgfTtcblxuICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUNyb3AgPSBmdW5jdGlvbiB1cGRhdGVDcm9wKGl0ZW0sIG9iaikge1xuICAgICAgcmV0dXJuIGl0ZW0uc2V0TWV0YWRhdGEoXG4gICAgICAgICdjcm9wJyxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgaXRlbS5nZXRNZXRhZGF0YSgnY3JvcCcpLCBvYmopXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBleHRlbmQgaXRlbSBtZXRob2RzXG4gICAgYWRkRmlsdGVyKCdESURfQ1JFQVRFX0lURU0nLCBmdW5jdGlvbihpdGVtLCBfcmVmMikge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG5cbiAgICAgIGl0ZW0uZXh0ZW5kKCdzZXRJbWFnZUNyb3AnLCBmdW5jdGlvbihjcm9wKSB7XG4gICAgICAgIGlmICghYWxsb3dDcm9wKGl0ZW0sIHF1ZXJ5KSB8fCAhaXNPYmplY3QoY2VudGVyKSkgcmV0dXJuO1xuICAgICAgICBpdGVtLnNldE1ldGFkYXRhKCdjcm9wJywgY3JvcCk7XG4gICAgICAgIHJldHVybiBjcm9wO1xuICAgICAgfSk7XG5cbiAgICAgIGl0ZW0uZXh0ZW5kKCdzZXRJbWFnZUNyb3BDZW50ZXInLCBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgICAgaWYgKCFhbGxvd0Nyb3AoaXRlbSwgcXVlcnkpIHx8ICFpc09iamVjdChjZW50ZXIpKSByZXR1cm47XG4gICAgICAgIHJldHVybiB1cGRhdGVDcm9wKGl0ZW0sIHsgY2VudGVyOiBjZW50ZXIgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXRlbS5leHRlbmQoJ3NldEltYWdlQ3JvcFpvb20nLCBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIGlmICghYWxsb3dDcm9wKGl0ZW0sIHF1ZXJ5KSB8fCAhaXNOdW1iZXIoem9vbSkpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNyb3AoaXRlbSwgeyB6b29tOiBNYXRoLm1heCgxLCB6b29tKSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdGVtLmV4dGVuZCgnc2V0SW1hZ2VDcm9wUm90YXRpb24nLCBmdW5jdGlvbihyb3RhdGlvbikge1xuICAgICAgICBpZiAoIWFsbG93Q3JvcChpdGVtLCBxdWVyeSkgfHwgIWlzTnVtYmVyKHJvdGF0aW9uKSkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ3JvcChpdGVtLCB7IHJvdGF0aW9uOiByb3RhdGlvbiB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdGVtLmV4dGVuZCgnc2V0SW1hZ2VDcm9wRmxpcCcsIGZ1bmN0aW9uKGZsaXApIHtcbiAgICAgICAgaWYgKCFhbGxvd0Nyb3AoaXRlbSwgcXVlcnkpIHx8ICFpc09iamVjdChmbGlwKSkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ3JvcChpdGVtLCB7IGZsaXA6IGZsaXAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXRlbS5leHRlbmQoJ3NldEltYWdlQ3JvcEFzcGVjdFJhdGlvJywgZnVuY3Rpb24obmV3QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKCFhbGxvd0Nyb3AoaXRlbSwgcXVlcnkpIHx8IHR5cGVvZiBuZXdBc3BlY3RSYXRpbyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjdXJyZW50Q3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKTtcblxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKG5ld0FzcGVjdFJhdGlvKTtcblxuICAgICAgICB2YXIgbmV3Q3JvcCA9IHtcbiAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgIHg6IDAuNSxcbiAgICAgICAgICAgIHk6IDAuNVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmbGlwOiBjdXJyZW50Q3JvcFxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50Q3JvcC5mbGlwKVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICB6b29tOiAxLFxuICAgICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoJ2Nyb3AnLCBuZXdDcm9wKTtcblxuICAgICAgICByZXR1cm4gbmV3Q3JvcDtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIGZpbGUgdHJhbnNmb3JtYXRpb25zXG4gICAgYWRkRmlsdGVyKCdESURfTE9BRF9JVEVNJywgZnVuY3Rpb24oaXRlbSwgX3JlZjMpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYzLnF1ZXJ5O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBnZXQgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgdmFyIGZpbGUgPSBpdGVtLmZpbGU7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYW4gaW1hZ2Ugd2UgZG8gbm90IGhhdmUgYW55IGJ1c2luZXNzIGNyb3BwaW5nIGl0IGFuZCB3ZSdsbCBjb250aW51ZSB3aXRoIHRoZSB1bmFsdGVyZWQgZGF0YXNldFxuICAgICAgICBpZiAoIWlzRmlsZShmaWxlKSB8fCAhaXNJbWFnZShmaWxlKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9DUk9QJykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFscmVhZHkgaGFzIGNyb3AgbWV0YWRhdGEgc2V0P1xuICAgICAgICB2YXIgY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKTtcbiAgICAgICAgaWYgKGNyb3ApIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgcmVxdWlyZWQgYXNwZWN0IHJhdGlvIGFuZCBleGl0IGlmIGl0J3Mgbm90IHNldFxuICAgICAgICB2YXIgaHVtYW5Bc3BlY3RSYXRpbyA9IHF1ZXJ5KCdHRVRfSU1BR0VfQ1JPUF9BU1BFQ1RfUkFUSU8nKTtcblxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBjcm9wIHJlY3RhbmdsZVxuICAgICAgICBpdGVtLnNldE1ldGFkYXRhKCdjcm9wJywge1xuICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgeTogMC41XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgdmVydGljYWw6IGZhbHNlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIHpvb206IDEsXG4gICAgICAgICAgYXNwZWN0UmF0aW86IGh1bWFuQXNwZWN0UmF0aW9cbiAgICAgICAgICAgID8gZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhodW1hbkFzcGVjdFJhdGlvKVxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEV4cG9zZSBwbHVnaW4gb3B0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC8vIGVuYWJsZSBvciBkaXNhYmxlIGltYWdlIGNyb3BwaW5nXG4gICAgICAgIGFsbG93SW1hZ2VDcm9wOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wICgnMToxJywgJzE2OjknLCBldGMpXG4gICAgICAgIGltYWdlQ3JvcEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBmaXJlIHBsdWdpbmxvYWRlZCBldmVudCBpZiBydW5uaW5nIGluIGJyb3dzZXIsIHRoaXMgYWxsb3dzIHJlZ2lzdGVyaW5nIHRoZSBwbHVnaW4gd2hlbiB1c2luZyBhc3luYyBzY3JpcHQgdGFnc1xuICB2YXIgaXNCcm93c2VyID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-crop/dist/filepond-plugin-image-crop.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.js":
/*!************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.js ***!
  \************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImageEdit 1.6.3\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  var isPreviewableImage = function isPreviewableImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  /**\n   * Image Edit Proxy Plugin\n   */\n  var plugin = function plugin(_) {\n    var addFilter = _.addFilter,\n      utils = _.utils,\n      views = _.views;\n    var Type = utils.Type,\n      createRoute = utils.createRoute,\n      _utils$createItemAPI = utils.createItemAPI,\n      createItemAPI =\n        _utils$createItemAPI === void 0\n          ? function(item) {\n              return item;\n            }\n          : _utils$createItemAPI;\n    var fileActionButton = views.fileActionButton;\n\n    addFilter('SHOULD_REMOVE_ON_REVERT', function(shouldRemove, _ref) {\n      var item = _ref.item,\n        query = _ref.query;\n      return new Promise(function(resolve) {\n        var file = item.file;\n\n        // if this file is editable it shouldn't be removed immidiately even when instant uploading\n        var canEdit =\n          query('GET_ALLOW_IMAGE_EDIT') &&\n          query('GET_IMAGE_EDIT_ALLOW_EDIT') &&\n          isPreviewableImage(file);\n\n        // if the file cannot be edited it should be removed on revert\n        resolve(!canEdit);\n      });\n    });\n\n    // open editor when loading a new item\n    addFilter('DID_LOAD_ITEM', function(item, _ref2) {\n      var query = _ref2.query,\n        dispatch = _ref2.dispatch;\n      return new Promise(function(resolve, reject) {\n        // if is temp or local file\n        if (item.origin > 1) {\n          resolve(item);\n          return;\n        }\n\n        // get file reference\n        var file = item.file;\n        if (\n          !query('GET_ALLOW_IMAGE_EDIT') ||\n          !query('GET_IMAGE_EDIT_INSTANT_EDIT')\n        ) {\n          resolve(item);\n          return;\n        }\n\n        // exit if this is not an image\n        if (!isPreviewableImage(file)) {\n          resolve(item);\n          return;\n        }\n\n        var createEditorResponseHandler = function createEditorResponseHandler(\n          item,\n          resolve,\n          reject\n        ) {\n          return function(userDidConfirm) {\n            // remove item\n            editRequestQueue.shift();\n\n            // handle item\n            if (userDidConfirm) {\n              resolve(item);\n            } else {\n              reject(item);\n            }\n\n            // TODO: Fix, should not be needed to kick the internal loop in case no processes are running\n            dispatch('KICK');\n\n            // handle next item!\n            requestEdit();\n          };\n        };\n\n        var requestEdit = function requestEdit() {\n          if (!editRequestQueue.length) return;\n          var _editRequestQueue$ = editRequestQueue[0],\n            item = _editRequestQueue$.item,\n            resolve = _editRequestQueue$.resolve,\n            reject = _editRequestQueue$.reject;\n\n          dispatch('EDIT_ITEM', {\n            id: item.id,\n            handleEditorResponse: createEditorResponseHandler(\n              item,\n              resolve,\n              reject\n            )\n          });\n        };\n\n        queueEditRequest({ item: item, resolve: resolve, reject: reject });\n\n        if (editRequestQueue.length === 1) {\n          requestEdit();\n        }\n      });\n    });\n\n    // extend item methods\n    addFilter('DID_CREATE_ITEM', function(item, _ref3) {\n      var query = _ref3.query,\n        dispatch = _ref3.dispatch;\n      item.extend('edit', function() {\n        dispatch('EDIT_ITEM', { id: item.id });\n      });\n    });\n\n    var editRequestQueue = [];\n    var queueEditRequest = function queueEditRequest(editRequest) {\n      editRequestQueue.push(editRequest);\n      return editRequest;\n    };\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      if (!query('GET_ALLOW_IMAGE_EDIT')) return;\n\n      var canShowImagePreview = query('GET_ALLOW_IMAGE_PREVIEW');\n\n      // only run for either the file or the file info panel\n      var shouldExtendView =\n        (is('file-info') && !canShowImagePreview) ||\n        (is('file') && canShowImagePreview);\n\n      if (!shouldExtendView) return;\n\n      // no editor defined, then exit\n      var editor = query('GET_IMAGE_EDIT_EDITOR');\n      if (!editor) return;\n\n      // set default FilePond options and add bridge once\n      if (!editor.filepondCallbackBridge) {\n        editor.outputData = true;\n        editor.outputFile = false;\n        editor.filepondCallbackBridge = {\n          onconfirm: editor.onconfirm || function() {},\n          oncancel: editor.oncancel || function() {}\n        };\n      }\n\n      // opens the editor, if it does not already exist, it creates the editor\n      var openEditor = function openEditor(_ref4) {\n        var root = _ref4.root,\n          props = _ref4.props,\n          action = _ref4.action;\n        var id = props.id;\n        var handleEditorResponse = action.handleEditorResponse;\n\n        // update editor props that could have changed\n        editor.cropAspectRatio =\n          root.query('GET_IMAGE_CROP_ASPECT_RATIO') || editor.cropAspectRatio;\n        editor.outputCanvasBackgroundColor =\n          root.query('GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR') ||\n          editor.outputCanvasBackgroundColor;\n\n        // get item\n        var item = root.query('GET_ITEM', id);\n        if (!item) return;\n\n        // file to open\n        var file = item.file;\n\n        // crop data to pass to editor\n        var crop = item.getMetadata('crop');\n        var cropDefault = {\n          center: {\n            x: 0.5,\n            y: 0.5\n          },\n\n          flip: {\n            horizontal: false,\n            vertical: false\n          },\n\n          zoom: 1,\n          rotation: 0,\n          aspectRatio: null\n        };\n\n        // size data to pass to editor\n        var resize = item.getMetadata('resize');\n\n        // filter and color data to pass to editor\n        var filter = item.getMetadata('filter') || null;\n        var filters = item.getMetadata('filters') || null;\n        var colors = item.getMetadata('colors') || null;\n        var markup = item.getMetadata('markup') || null;\n\n        // build parameters object\n        var imageParameters = {\n          crop: crop || cropDefault,\n          size: resize\n            ? {\n                upscale: resize.upscale,\n                mode: resize.mode,\n                width: resize.size.width,\n                height: resize.size.height\n              }\n            : null,\n          filter: filters\n            ? filters.id || filters.matrix\n            : root.query('GET_ALLOW_IMAGE_FILTER') &&\n              root.query('GET_IMAGE_FILTER_COLOR_MATRIX') &&\n              !colors\n            ? filter\n            : null,\n          color: colors,\n          markup: markup\n        };\n\n        editor.onconfirm = function(_ref5) {\n          var data = _ref5.data;\n          var crop = data.crop,\n            size = data.size,\n            filter = data.filter,\n            color = data.color,\n            colorMatrix = data.colorMatrix,\n            markup = data.markup;\n\n          // create new metadata object\n          var metadata = {};\n\n          // append crop data\n          if (crop) {\n            metadata.crop = crop;\n          }\n\n          // append size data\n          if (size) {\n            var initialSize = (item.getMetadata('resize') || {}).size;\n            var targetSize = {\n              width: size.width,\n              height: size.height\n            };\n\n            if (!(targetSize.width && targetSize.height) && initialSize) {\n              targetSize.width = initialSize.width;\n              targetSize.height = initialSize.height;\n            }\n\n            if (targetSize.width || targetSize.height) {\n              metadata.resize = {\n                upscale: size.upscale,\n                mode: size.mode,\n                size: targetSize\n              };\n            }\n          }\n\n          if (markup) {\n            metadata.markup = markup;\n          }\n\n          // set filters and colors so we can restore them when re-editing the image\n          metadata.colors = color;\n          metadata.filters = filter;\n\n          // set merged color matrix to use in preview plugin\n          metadata.filter = colorMatrix;\n\n          // update crop metadata\n          item.setMetadata(metadata);\n\n          // call\n          editor.filepondCallbackBridge.onconfirm(data, createItemAPI(item));\n\n          // used in instant edit mode\n          if (!handleEditorResponse) return;\n          editor.onclose = function() {\n            handleEditorResponse(true);\n            editor.onclose = null;\n          };\n        };\n\n        editor.oncancel = function() {\n          // call\n          editor.filepondCallbackBridge.oncancel(createItemAPI(item));\n\n          // used in instant edit mode\n          if (!handleEditorResponse) return;\n          editor.onclose = function() {\n            handleEditorResponse(false);\n            editor.onclose = null;\n          };\n        };\n\n        editor.open(file, imageParameters);\n      };\n\n      /**\n       * Image Preview related\n       */\n\n      // create the image edit plugin, but only do so if the item is an image\n      var didLoadItem = function didLoadItem(_ref6) {\n        var root = _ref6.root,\n          props = _ref6.props;\n\n        if (!query('GET_IMAGE_EDIT_ALLOW_EDIT')) return;\n        var id = props.id;\n\n        // try to access item\n        var item = query('GET_ITEM', id);\n        if (!item) return;\n\n        // get the file object\n        var file = item.file;\n\n        // exit if this is not an image\n        if (!isPreviewableImage(file)) return;\n\n        // handle interactions\n        root.ref.handleEdit = function(e) {\n          e.stopPropagation();\n          root.dispatch('EDIT_ITEM', { id: id });\n        };\n\n        if (canShowImagePreview) {\n          // add edit button to preview\n          var buttonView = view.createChildView(fileActionButton, {\n            label: 'edit',\n            icon: query('GET_IMAGE_EDIT_ICON_EDIT'),\n            opacity: 0\n          });\n\n          // edit item classname\n          buttonView.element.classList.add('filepond--action-edit-item');\n          buttonView.element.dataset.align = query(\n            'GET_STYLE_IMAGE_EDIT_BUTTON_EDIT_ITEM_POSITION'\n          );\n          buttonView.on('click', root.ref.handleEdit);\n\n          root.ref.buttonEditItem = view.appendChildView(buttonView);\n        } else {\n          // view is file info\n          var filenameElement = view.element.querySelector(\n            '.filepond--file-info-main'\n          );\n          var editButton = document.createElement('button');\n          editButton.className = 'filepond--action-edit-item-alt';\n          editButton.innerHTML =\n            query('GET_IMAGE_EDIT_ICON_EDIT') + '<span>edit</span>';\n          editButton.addEventListener('click', root.ref.handleEdit);\n          filenameElement.appendChild(editButton);\n\n          root.ref.editButton = editButton;\n        }\n      };\n\n      view.registerDestroyer(function(_ref7) {\n        var root = _ref7.root;\n        if (root.ref.buttonEditItem) {\n          root.ref.buttonEditItem.off('click', root.ref.handleEdit);\n        }\n        if (root.ref.editButton) {\n          root.ref.editButton.removeEventListener('click', root.ref.handleEdit);\n        }\n      });\n\n      var routes = {\n        EDIT_ITEM: openEditor,\n        DID_LOAD_ITEM: didLoadItem\n      };\n\n      if (canShowImagePreview) {\n        // view is file\n        var didPreviewUpdate = function didPreviewUpdate(_ref8) {\n          var root = _ref8.root;\n          if (!root.ref.buttonEditItem) return;\n          root.ref.buttonEditItem.opacity = 1;\n        };\n\n        routes.DID_IMAGE_PREVIEW_SHOW = didPreviewUpdate;\n      } else {\n      }\n\n      // start writing\n      view.registerWriter(createRoute(routes));\n    });\n\n    // Expose plugin options\n    return {\n      options: {\n        // enable or disable image editing\n        allowImageEdit: [true, Type.BOOLEAN],\n\n        // location of processing button\n        styleImageEditButtonEditItemPosition: ['bottom center', Type.STRING],\n\n        // open editor when image is dropped\n        imageEditInstantEdit: [false, Type.BOOLEAN],\n\n        // allow editing\n        imageEditAllowEdit: [true, Type.BOOLEAN],\n\n        // the icon to use for the edit button\n        imageEditIconEdit: [\n          '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M8.5 17h1.586l7-7L15.5 8.414l-7 7V17zm-1.707-2.707l8-8a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1 0 1.414l-8 8A1 1 0 0 1 10.5 19h-3a1 1 0 0 1-1-1v-3a1 1 0 0 1 .293-.707z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n          Type.STRING\n        ],\n\n        // editor object\n        imageEditEditor: [null, Type.OBJECT]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FFeUU7QUFDL0UsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSwyQkFBMkIsOENBQThDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC5qcz9mZmEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5JbWFnZUVkaXQgMS42LjNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSwgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkltYWdlRWRpdCA9IGZhY3RvcnkoKSkpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaXNQcmV2aWV3YWJsZUltYWdlID0gZnVuY3Rpb24gaXNQcmV2aWV3YWJsZUltYWdlKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZS8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbWFnZSBFZGl0IFByb3h5IFBsdWdpblxuICAgKi9cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF8uYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfLnV0aWxzLFxuICAgICAgdmlld3MgPSBfLnZpZXdzO1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgIGNyZWF0ZVJvdXRlID0gdXRpbHMuY3JlYXRlUm91dGUsXG4gICAgICBfdXRpbHMkY3JlYXRlSXRlbUFQSSA9IHV0aWxzLmNyZWF0ZUl0ZW1BUEksXG4gICAgICBjcmVhdGVJdGVtQVBJID1cbiAgICAgICAgX3V0aWxzJGNyZWF0ZUl0ZW1BUEkgPT09IHZvaWQgMFxuICAgICAgICAgID8gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IF91dGlscyRjcmVhdGVJdGVtQVBJO1xuICAgIHZhciBmaWxlQWN0aW9uQnV0dG9uID0gdmlld3MuZmlsZUFjdGlvbkJ1dHRvbjtcblxuICAgIGFkZEZpbHRlcignU0hPVUxEX1JFTU9WRV9PTl9SRVZFUlQnLCBmdW5jdGlvbihzaG91bGRSZW1vdmUsIF9yZWYpIHtcbiAgICAgIHZhciBpdGVtID0gX3JlZi5pdGVtLFxuICAgICAgICBxdWVyeSA9IF9yZWYucXVlcnk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB2YXIgZmlsZSA9IGl0ZW0uZmlsZTtcblxuICAgICAgICAvLyBpZiB0aGlzIGZpbGUgaXMgZWRpdGFibGUgaXQgc2hvdWxkbid0IGJlIHJlbW92ZWQgaW1taWRpYXRlbHkgZXZlbiB3aGVuIGluc3RhbnQgdXBsb2FkaW5nXG4gICAgICAgIHZhciBjYW5FZGl0ID1cbiAgICAgICAgICBxdWVyeSgnR0VUX0FMTE9XX0lNQUdFX0VESVQnKSAmJlxuICAgICAgICAgIHF1ZXJ5KCdHRVRfSU1BR0VfRURJVF9BTExPV19FRElUJykgJiZcbiAgICAgICAgICBpc1ByZXZpZXdhYmxlSW1hZ2UoZmlsZSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZpbGUgY2Fubm90IGJlIGVkaXRlZCBpdCBzaG91bGQgYmUgcmVtb3ZlZCBvbiByZXZlcnRcbiAgICAgICAgcmVzb2x2ZSghY2FuRWRpdCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIG9wZW4gZWRpdG9yIHdoZW4gbG9hZGluZyBhIG5ldyBpdGVtXG4gICAgYWRkRmlsdGVyKCdESURfTE9BRF9JVEVNJywgZnVuY3Rpb24oaXRlbSwgX3JlZjIpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5LFxuICAgICAgICBkaXNwYXRjaCA9IF9yZWYyLmRpc3BhdGNoO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBpZiBpcyB0ZW1wIG9yIGxvY2FsIGZpbGVcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID4gMSkge1xuICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGZpbGUgcmVmZXJlbmNlXG4gICAgICAgIHZhciBmaWxlID0gaXRlbS5maWxlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXF1ZXJ5KCdHRVRfQUxMT1dfSU1BR0VfRURJVCcpIHx8XG4gICAgICAgICAgIXF1ZXJ5KCdHRVRfSU1BR0VfRURJVF9JTlNUQU5UX0VESVQnKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4aXQgaWYgdGhpcyBpcyBub3QgYW4gaW1hZ2VcbiAgICAgICAgaWYgKCFpc1ByZXZpZXdhYmxlSW1hZ2UoZmlsZSkpIHtcbiAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcmVhdGVFZGl0b3JSZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbiBjcmVhdGVFZGl0b3JSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odXNlckRpZENvbmZpcm0pIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpdGVtXG4gICAgICAgICAgICBlZGl0UmVxdWVzdFF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBpdGVtXG4gICAgICAgICAgICBpZiAodXNlckRpZENvbmZpcm0pIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogRml4LCBzaG91bGQgbm90IGJlIG5lZWRlZCB0byBraWNrIHRoZSBpbnRlcm5hbCBsb29wIGluIGNhc2Ugbm8gcHJvY2Vzc2VzIGFyZSBydW5uaW5nXG4gICAgICAgICAgICBkaXNwYXRjaCgnS0lDSycpO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbmV4dCBpdGVtIVxuICAgICAgICAgICAgcmVxdWVzdEVkaXQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0RWRpdCA9IGZ1bmN0aW9uIHJlcXVlc3RFZGl0KCkge1xuICAgICAgICAgIGlmICghZWRpdFJlcXVlc3RRdWV1ZS5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICB2YXIgX2VkaXRSZXF1ZXN0UXVldWUkID0gZWRpdFJlcXVlc3RRdWV1ZVswXSxcbiAgICAgICAgICAgIGl0ZW0gPSBfZWRpdFJlcXVlc3RRdWV1ZSQuaXRlbSxcbiAgICAgICAgICAgIHJlc29sdmUgPSBfZWRpdFJlcXVlc3RRdWV1ZSQucmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdCA9IF9lZGl0UmVxdWVzdFF1ZXVlJC5yZWplY3Q7XG5cbiAgICAgICAgICBkaXNwYXRjaCgnRURJVF9JVEVNJywge1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBoYW5kbGVFZGl0b3JSZXNwb25zZTogY3JlYXRlRWRpdG9yUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBxdWV1ZUVkaXRSZXF1ZXN0KHsgaXRlbTogaXRlbSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QgfSk7XG5cbiAgICAgICAgaWYgKGVkaXRSZXF1ZXN0UXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmVxdWVzdEVkaXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBleHRlbmQgaXRlbSBtZXRob2RzXG4gICAgYWRkRmlsdGVyKCdESURfQ1JFQVRFX0lURU0nLCBmdW5jdGlvbihpdGVtLCBfcmVmMykge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnksXG4gICAgICAgIGRpc3BhdGNoID0gX3JlZjMuZGlzcGF0Y2g7XG4gICAgICBpdGVtLmV4dGVuZCgnZWRpdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNwYXRjaCgnRURJVF9JVEVNJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGVkaXRSZXF1ZXN0UXVldWUgPSBbXTtcbiAgICB2YXIgcXVldWVFZGl0UmVxdWVzdCA9IGZ1bmN0aW9uIHF1ZXVlRWRpdFJlcXVlc3QoZWRpdFJlcXVlc3QpIHtcbiAgICAgIGVkaXRSZXF1ZXN0UXVldWUucHVzaChlZGl0UmVxdWVzdCk7XG4gICAgICByZXR1cm4gZWRpdFJlcXVlc3Q7XG4gICAgfTtcblxuICAgIC8vIGNhbGxlZCBmb3IgZWFjaCB2aWV3IHRoYXQgaXMgY3JlYXRlZCByaWdodCBhZnRlciB0aGUgJ2NyZWF0ZScgbWV0aG9kXG4gICAgYWRkRmlsdGVyKCdDUkVBVEVfVklFVycsIGZ1bmN0aW9uKHZpZXdBUEkpIHtcbiAgICAgIC8vIGdldCByZWZlcmVuY2UgdG8gY3JlYXRlZCB2aWV3XG4gICAgICB2YXIgaXMgPSB2aWV3QVBJLmlzLFxuICAgICAgICB2aWV3ID0gdmlld0FQSS52aWV3LFxuICAgICAgICBxdWVyeSA9IHZpZXdBUEkucXVlcnk7XG5cbiAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9FRElUJykpIHJldHVybjtcblxuICAgICAgdmFyIGNhblNob3dJbWFnZVByZXZpZXcgPSBxdWVyeSgnR0VUX0FMTE9XX0lNQUdFX1BSRVZJRVcnKTtcblxuICAgICAgLy8gb25seSBydW4gZm9yIGVpdGhlciB0aGUgZmlsZSBvciB0aGUgZmlsZSBpbmZvIHBhbmVsXG4gICAgICB2YXIgc2hvdWxkRXh0ZW5kVmlldyA9XG4gICAgICAgIChpcygnZmlsZS1pbmZvJykgJiYgIWNhblNob3dJbWFnZVByZXZpZXcpIHx8XG4gICAgICAgIChpcygnZmlsZScpICYmIGNhblNob3dJbWFnZVByZXZpZXcpO1xuXG4gICAgICBpZiAoIXNob3VsZEV4dGVuZFZpZXcpIHJldHVybjtcblxuICAgICAgLy8gbm8gZWRpdG9yIGRlZmluZWQsIHRoZW4gZXhpdFxuICAgICAgdmFyIGVkaXRvciA9IHF1ZXJ5KCdHRVRfSU1BR0VfRURJVF9FRElUT1InKTtcbiAgICAgIGlmICghZWRpdG9yKSByZXR1cm47XG5cbiAgICAgIC8vIHNldCBkZWZhdWx0IEZpbGVQb25kIG9wdGlvbnMgYW5kIGFkZCBicmlkZ2Ugb25jZVxuICAgICAgaWYgKCFlZGl0b3IuZmlsZXBvbmRDYWxsYmFja0JyaWRnZSkge1xuICAgICAgICBlZGl0b3Iub3V0cHV0RGF0YSA9IHRydWU7XG4gICAgICAgIGVkaXRvci5vdXRwdXRGaWxlID0gZmFsc2U7XG4gICAgICAgIGVkaXRvci5maWxlcG9uZENhbGxiYWNrQnJpZGdlID0ge1xuICAgICAgICAgIG9uY29uZmlybTogZWRpdG9yLm9uY29uZmlybSB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgIG9uY2FuY2VsOiBlZGl0b3Iub25jYW5jZWwgfHwgZnVuY3Rpb24oKSB7fVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvcGVucyB0aGUgZWRpdG9yLCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LCBpdCBjcmVhdGVzIHRoZSBlZGl0b3JcbiAgICAgIHZhciBvcGVuRWRpdG9yID0gZnVuY3Rpb24gb3BlbkVkaXRvcihfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuICAgICAgICB2YXIgaGFuZGxlRWRpdG9yUmVzcG9uc2UgPSBhY3Rpb24uaGFuZGxlRWRpdG9yUmVzcG9uc2U7XG5cbiAgICAgICAgLy8gdXBkYXRlIGVkaXRvciBwcm9wcyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICBlZGl0b3IuY3JvcEFzcGVjdFJhdGlvID1cbiAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSU1BR0VfQ1JPUF9BU1BFQ1RfUkFUSU8nKSB8fCBlZGl0b3IuY3JvcEFzcGVjdFJhdGlvO1xuICAgICAgICBlZGl0b3Iub3V0cHV0Q2FudmFzQmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSU1BR0VfVFJBTlNGT1JNX0NBTlZBU19CQUNLR1JPVU5EX0NPTE9SJykgfHxcbiAgICAgICAgICBlZGl0b3Iub3V0cHV0Q2FudmFzQmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIC8vIGdldCBpdGVtXG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBpZCk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGZpbGUgdG8gb3BlblxuICAgICAgICB2YXIgZmlsZSA9IGl0ZW0uZmlsZTtcblxuICAgICAgICAvLyBjcm9wIGRhdGEgdG8gcGFzcyB0byBlZGl0b3JcbiAgICAgICAgdmFyIGNyb3AgPSBpdGVtLmdldE1ldGFkYXRhKCdjcm9wJyk7XG4gICAgICAgIHZhciBjcm9wRGVmYXVsdCA9IHtcbiAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgIHg6IDAuNSxcbiAgICAgICAgICAgIHk6IDAuNVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB6b29tOiAxLFxuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIGFzcGVjdFJhdGlvOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2l6ZSBkYXRhIHRvIHBhc3MgdG8gZWRpdG9yXG4gICAgICAgIHZhciByZXNpemUgPSBpdGVtLmdldE1ldGFkYXRhKCdyZXNpemUnKTtcblxuICAgICAgICAvLyBmaWx0ZXIgYW5kIGNvbG9yIGRhdGEgdG8gcGFzcyB0byBlZGl0b3JcbiAgICAgICAgdmFyIGZpbHRlciA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2ZpbHRlcicpIHx8IG51bGw7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gaXRlbS5nZXRNZXRhZGF0YSgnZmlsdGVycycpIHx8IG51bGw7XG4gICAgICAgIHZhciBjb2xvcnMgPSBpdGVtLmdldE1ldGFkYXRhKCdjb2xvcnMnKSB8fCBudWxsO1xuICAgICAgICB2YXIgbWFya3VwID0gaXRlbS5nZXRNZXRhZGF0YSgnbWFya3VwJykgfHwgbnVsbDtcblxuICAgICAgICAvLyBidWlsZCBwYXJhbWV0ZXJzIG9iamVjdFxuICAgICAgICB2YXIgaW1hZ2VQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIGNyb3A6IGNyb3AgfHwgY3JvcERlZmF1bHQsXG4gICAgICAgICAgc2l6ZTogcmVzaXplXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB1cHNjYWxlOiByZXNpemUudXBzY2FsZSxcbiAgICAgICAgICAgICAgICBtb2RlOiByZXNpemUubW9kZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzaXplLnNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXNpemUuc2l6ZS5oZWlnaHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIGZpbHRlcjogZmlsdGVyc1xuICAgICAgICAgICAgPyBmaWx0ZXJzLmlkIHx8IGZpbHRlcnMubWF0cml4XG4gICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19JTUFHRV9GSUxURVInKSAmJlxuICAgICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSU1BR0VfRklMVEVSX0NPTE9SX01BVFJJWCcpICYmXG4gICAgICAgICAgICAgICFjb2xvcnNcbiAgICAgICAgICAgID8gZmlsdGVyXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgY29sb3I6IGNvbG9ycyxcbiAgICAgICAgICBtYXJrdXA6IG1hcmt1cFxuICAgICAgICB9O1xuXG4gICAgICAgIGVkaXRvci5vbmNvbmZpcm0gPSBmdW5jdGlvbihfcmVmNSkge1xuICAgICAgICAgIHZhciBkYXRhID0gX3JlZjUuZGF0YTtcbiAgICAgICAgICB2YXIgY3JvcCA9IGRhdGEuY3JvcCxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemUsXG4gICAgICAgICAgICBmaWx0ZXIgPSBkYXRhLmZpbHRlcixcbiAgICAgICAgICAgIGNvbG9yID0gZGF0YS5jb2xvcixcbiAgICAgICAgICAgIGNvbG9yTWF0cml4ID0gZGF0YS5jb2xvck1hdHJpeCxcbiAgICAgICAgICAgIG1hcmt1cCA9IGRhdGEubWFya3VwO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAgICAgICAgIC8vIGFwcGVuZCBjcm9wIGRhdGFcbiAgICAgICAgICBpZiAoY3JvcCkge1xuICAgICAgICAgICAgbWV0YWRhdGEuY3JvcCA9IGNyb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXBwZW5kIHNpemUgZGF0YVxuICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFNpemUgPSAoaXRlbS5nZXRNZXRhZGF0YSgncmVzaXplJykgfHwge30pLnNpemU7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0U2l6ZSA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghKHRhcmdldFNpemUud2lkdGggJiYgdGFyZ2V0U2l6ZS5oZWlnaHQpICYmIGluaXRpYWxTaXplKSB7XG4gICAgICAgICAgICAgIHRhcmdldFNpemUud2lkdGggPSBpbml0aWFsU2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgdGFyZ2V0U2l6ZS5oZWlnaHQgPSBpbml0aWFsU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRTaXplLndpZHRoIHx8IHRhcmdldFNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnJlc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB1cHNjYWxlOiBzaXplLnVwc2NhbGUsXG4gICAgICAgICAgICAgICAgbW9kZTogc2l6ZS5tb2RlLFxuICAgICAgICAgICAgICAgIHNpemU6IHRhcmdldFNpemVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5tYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2V0IGZpbHRlcnMgYW5kIGNvbG9ycyBzbyB3ZSBjYW4gcmVzdG9yZSB0aGVtIHdoZW4gcmUtZWRpdGluZyB0aGUgaW1hZ2VcbiAgICAgICAgICBtZXRhZGF0YS5jb2xvcnMgPSBjb2xvcjtcbiAgICAgICAgICBtZXRhZGF0YS5maWx0ZXJzID0gZmlsdGVyO1xuXG4gICAgICAgICAgLy8gc2V0IG1lcmdlZCBjb2xvciBtYXRyaXggdG8gdXNlIGluIHByZXZpZXcgcGx1Z2luXG4gICAgICAgICAgbWV0YWRhdGEuZmlsdGVyID0gY29sb3JNYXRyaXg7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgY3JvcCBtZXRhZGF0YVxuICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEobWV0YWRhdGEpO1xuXG4gICAgICAgICAgLy8gY2FsbFxuICAgICAgICAgIGVkaXRvci5maWxlcG9uZENhbGxiYWNrQnJpZGdlLm9uY29uZmlybShkYXRhLCBjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcblxuICAgICAgICAgIC8vIHVzZWQgaW4gaW5zdGFudCBlZGl0IG1vZGVcbiAgICAgICAgICBpZiAoIWhhbmRsZUVkaXRvclJlc3BvbnNlKSByZXR1cm47XG4gICAgICAgICAgZWRpdG9yLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhbmRsZUVkaXRvclJlc3BvbnNlKHRydWUpO1xuICAgICAgICAgICAgZWRpdG9yLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZWRpdG9yLm9uY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gY2FsbFxuICAgICAgICAgIGVkaXRvci5maWxlcG9uZENhbGxiYWNrQnJpZGdlLm9uY2FuY2VsKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuXG4gICAgICAgICAgLy8gdXNlZCBpbiBpbnN0YW50IGVkaXQgbW9kZVxuICAgICAgICAgIGlmICghaGFuZGxlRWRpdG9yUmVzcG9uc2UpIHJldHVybjtcbiAgICAgICAgICBlZGl0b3Iub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGFuZGxlRWRpdG9yUmVzcG9uc2UoZmFsc2UpO1xuICAgICAgICAgICAgZWRpdG9yLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZWRpdG9yLm9wZW4oZmlsZSwgaW1hZ2VQYXJhbWV0ZXJzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1hZ2UgUHJldmlldyByZWxhdGVkXG4gICAgICAgKi9cblxuICAgICAgLy8gY3JlYXRlIHRoZSBpbWFnZSBlZGl0IHBsdWdpbiwgYnV0IG9ubHkgZG8gc28gaWYgdGhlIGl0ZW0gaXMgYW4gaW1hZ2VcbiAgICAgIHZhciBkaWRMb2FkSXRlbSA9IGZ1bmN0aW9uIGRpZExvYWRJdGVtKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzO1xuXG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9JTUFHRV9FRElUX0FMTE9XX0VESVQnKSkgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBwcm9wcy5pZDtcblxuICAgICAgICAvLyB0cnkgdG8gYWNjZXNzIGl0ZW1cbiAgICAgICAgdmFyIGl0ZW0gPSBxdWVyeSgnR0VUX0lURU0nLCBpZCk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCB0aGUgZmlsZSBvYmplY3RcbiAgICAgICAgdmFyIGZpbGUgPSBpdGVtLmZpbGU7XG5cbiAgICAgICAgLy8gZXhpdCBpZiB0aGlzIGlzIG5vdCBhbiBpbWFnZVxuICAgICAgICBpZiAoIWlzUHJldmlld2FibGVJbWFnZShmaWxlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbnRlcmFjdGlvbnNcbiAgICAgICAgcm9vdC5yZWYuaGFuZGxlRWRpdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0VESVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjYW5TaG93SW1hZ2VQcmV2aWV3KSB7XG4gICAgICAgICAgLy8gYWRkIGVkaXQgYnV0dG9uIHRvIHByZXZpZXdcbiAgICAgICAgICB2YXIgYnV0dG9uVmlldyA9IHZpZXcuY3JlYXRlQ2hpbGRWaWV3KGZpbGVBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgICAgIGxhYmVsOiAnZWRpdCcsXG4gICAgICAgICAgICBpY29uOiBxdWVyeSgnR0VUX0lNQUdFX0VESVRfSUNPTl9FRElUJyksXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBlZGl0IGl0ZW0gY2xhc3NuYW1lXG4gICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtJyk7XG4gICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBxdWVyeShcbiAgICAgICAgICAgICdHRVRfU1RZTEVfSU1BR0VfRURJVF9CVVRUT05fRURJVF9JVEVNX1BPU0lUSU9OJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCByb290LnJlZi5oYW5kbGVFZGl0KTtcblxuICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkVkaXRJdGVtID0gdmlldy5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmlldyBpcyBmaWxlIGluZm9cbiAgICAgICAgICB2YXIgZmlsZW5hbWVFbGVtZW50ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLmZpbGVwb25kLS1maWxlLWluZm8tbWFpbidcbiAgICAgICAgICApO1xuICAgICAgICAgIHZhciBlZGl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgZWRpdEJ1dHRvbi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0tYWx0JztcbiAgICAgICAgICBlZGl0QnV0dG9uLmlubmVySFRNTCA9XG4gICAgICAgICAgICBxdWVyeSgnR0VUX0lNQUdFX0VESVRfSUNPTl9FRElUJykgKyAnPHNwYW4+ZWRpdDwvc3Bhbj4nO1xuICAgICAgICAgIGVkaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVFZGl0KTtcbiAgICAgICAgICBmaWxlbmFtZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWRpdEJ1dHRvbik7XG5cbiAgICAgICAgICByb290LnJlZi5lZGl0QnV0dG9uID0gZWRpdEJ1dHRvbjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmlldy5yZWdpc3RlckRlc3Ryb3llcihmdW5jdGlvbihfcmVmNykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3Q7XG4gICAgICAgIGlmIChyb290LnJlZi5idXR0b25FZGl0SXRlbSkge1xuICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkVkaXRJdGVtLm9mZignY2xpY2snLCByb290LnJlZi5oYW5kbGVFZGl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdC5yZWYuZWRpdEJ1dHRvbikge1xuICAgICAgICAgIHJvb3QucmVmLmVkaXRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVFZGl0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByb3V0ZXMgPSB7XG4gICAgICAgIEVESVRfSVRFTTogb3BlbkVkaXRvcixcbiAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW1cbiAgICAgIH07XG5cbiAgICAgIGlmIChjYW5TaG93SW1hZ2VQcmV2aWV3KSB7XG4gICAgICAgIC8vIHZpZXcgaXMgZmlsZVxuICAgICAgICB2YXIgZGlkUHJldmlld1VwZGF0ZSA9IGZ1bmN0aW9uIGRpZFByZXZpZXdVcGRhdGUoX3JlZjgpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3Q7XG4gICAgICAgICAgaWYgKCFyb290LnJlZi5idXR0b25FZGl0SXRlbSkgcmV0dXJuO1xuICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkVkaXRJdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvdXRlcy5ESURfSU1BR0VfUFJFVklFV19TSE9XID0gZGlkUHJldmlld1VwZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IHdyaXRpbmdcbiAgICAgIHZpZXcucmVnaXN0ZXJXcml0ZXIoY3JlYXRlUm91dGUocm91dGVzKSk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHBvc2UgcGx1Z2luIG9wdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBlbmFibGUgb3IgZGlzYWJsZSBpbWFnZSBlZGl0aW5nXG4gICAgICAgIGFsbG93SW1hZ2VFZGl0OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBsb2NhdGlvbiBvZiBwcm9jZXNzaW5nIGJ1dHRvblxuICAgICAgICBzdHlsZUltYWdlRWRpdEJ1dHRvbkVkaXRJdGVtUG9zaXRpb246IFsnYm90dG9tIGNlbnRlcicsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBvcGVuIGVkaXRvciB3aGVuIGltYWdlIGlzIGRyb3BwZWRcbiAgICAgICAgaW1hZ2VFZGl0SW5zdGFudEVkaXQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBhbGxvdyBlZGl0aW5nXG4gICAgICAgIGltYWdlRWRpdEFsbG93RWRpdDogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gdGhlIGljb24gdG8gdXNlIGZvciB0aGUgZWRpdCBidXR0b25cbiAgICAgICAgaW1hZ2VFZGl0SWNvbkVkaXQ6IFtcbiAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCI+PHBhdGggZD1cIk04LjUgMTdoMS41ODZsNy03TDE1LjUgOC40MTRsLTcgN1YxN3ptLTEuNzA3LTIuNzA3bDgtOGExIDEgMCAwIDEgMS40MTQgMGwzIDNhMSAxIDAgMCAxIDAgMS40MTRsLTggOEExIDEgMCAwIDEgMTAuNSAxOWgtM2ExIDEgMCAwIDEtMS0xdi0zYTEgMSAwIDAgMSAuMjkzLS43MDd6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgICBUeXBlLlNUUklOR1xuICAgICAgICBdLFxuXG4gICAgICAgIC8vIGVkaXRvciBvYmplY3RcbiAgICAgICAgaW1hZ2VFZGl0RWRpdG9yOiBbbnVsbCwgVHlwZS5PQkpFQ1RdXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBmaXJlIHBsdWdpbmxvYWRlZCBldmVudCBpZiBydW5uaW5nIGluIGJyb3dzZXIsIHRoaXMgYWxsb3dzIHJlZ2lzdGVyaW5nIHRoZSBwbHVnaW4gd2hlbiB1c2luZyBhc3luYyBzY3JpcHQgdGFnc1xuICB2YXIgaXNCcm93c2VyID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js ***!
  \************************************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImageExifOrientation 1.0.11\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  // test if file is of type image\n  var isJPEG = function isJPEG(file) {\n    return /^image\\/jpeg/.test(file.type);\n  };\n\n  var Marker = {\n    JPEG: 0xffd8,\n    APP1: 0xffe1,\n    EXIF: 0x45786966,\n    TIFF: 0x4949,\n    Orientation: 0x0112,\n    Unknown: 0xff00\n  };\n\n  var getUint16 = function getUint16(view, offset) {\n    var little =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return view.getUint16(offset, little);\n  };\n  var getUint32 = function getUint32(view, offset) {\n    var little =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return view.getUint32(offset, little);\n  };\n\n  var getImageOrientation = function getImageOrientation(file) {\n    return new Promise(function(resolve, reject) {\n      var reader = new FileReader();\n      reader.onload = function(e) {\n        var view = new DataView(e.target.result);\n\n        // Every JPEG file starts from binary value '0xFFD8'\n        if (getUint16(view, 0) !== Marker.JPEG) {\n          // This aint no JPEG\n          resolve(-1);\n          return;\n        }\n\n        var length = view.byteLength;\n        var offset = 2;\n\n        while (offset < length) {\n          var marker = getUint16(view, offset);\n          offset += 2;\n\n          // There's our APP1 Marker\n          if (marker === Marker.APP1) {\n            if (getUint32(view, (offset += 2)) !== Marker.EXIF) {\n              // no EXIF info defined\n              break;\n            }\n\n            // Get TIFF Header\n            var little = getUint16(view, (offset += 6)) === Marker.TIFF;\n            offset += getUint32(view, offset + 4, little);\n\n            var tags = getUint16(view, offset, little);\n            offset += 2;\n\n            for (var i = 0; i < tags; i++) {\n              // found the orientation tag\n              if (\n                getUint16(view, offset + i * 12, little) === Marker.Orientation\n              ) {\n                resolve(getUint16(view, offset + i * 12 + 8, little));\n\n                return;\n              }\n            }\n          } else if ((marker & Marker.Unknown) !== Marker.Unknown) {\n            // Invalid\n            break;\n          } else {\n            offset += getUint16(view, offset);\n          }\n        }\n\n        // Nothing found\n        resolve(-1);\n      };\n\n      // we don't need to read the entire file to get the orientation\n      reader.readAsArrayBuffer(file.slice(0, 64 * 1024));\n    });\n  };\n\n  var IS_BROWSER = (function() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  })();\n  var isBrowser = function isBrowser() {\n    return IS_BROWSER;\n  };\n\n  // 2x1 pixel image 90CW rotated with orientation header\n  var testSrc =\n    'data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';\n\n  // should correct orientation if is presented in landscape, in which case the browser doesn't autocorrect\n  var shouldCorrect = undefined;\n  var testImage = isBrowser() ? new Image() : {};\n  testImage.onload = function() {\n    return (shouldCorrect = testImage.naturalWidth > testImage.naturalHeight);\n  };\n  testImage.src = testSrc;\n\n  var shouldCorrectImageExifOrientation = function shouldCorrectImageExifOrientation() {\n    return shouldCorrect;\n  };\n\n  /**\n   * Read Image Orientation Plugin\n   */\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    var Type = utils.Type,\n      isFile = utils.isFile;\n\n    // subscribe to file load and append required info\n    addFilter('DID_LOAD_ITEM', function(item, _ref2) {\n      var query = _ref2.query;\n      return new Promise(function(resolve, reject) {\n        // get file reference\n        var file = item.file;\n\n        // if this is not a jpeg image we are not interested\n        if (\n          !isFile(file) ||\n          !isJPEG(file) ||\n          !query('GET_ALLOW_IMAGE_EXIF_ORIENTATION') ||\n          !shouldCorrectImageExifOrientation()\n        ) {\n          // continue with the unaltered dataset\n          return resolve(item);\n        }\n\n        // get orientation from exif data\n        getImageOrientation(file).then(function(orientation) {\n          item.setMetadata('exif', { orientation: orientation });\n          resolve(item);\n        });\n      });\n    });\n\n    // Expose plugin options\n    return {\n      options: {\n        // Enable or disable image orientation reading\n        allowImageExifOrientation: [true, Type.BOOLEAN]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser$1 =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser$1) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWV4aWYtb3JpZW50YXRpb24vZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZXhpZi1vcmllbnRhdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FHd0Q7QUFDOUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZXhpZi1vcmllbnRhdGlvbi9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1leGlmLW9yaWVudGF0aW9uLmpzPzgyZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkltYWdlRXhpZk9yaWVudGF0aW9uIDEuMC4xMVxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkltYWdlRXhpZk9yaWVudGF0aW9uID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHRlc3QgaWYgZmlsZSBpcyBvZiB0eXBlIGltYWdlXG4gIHZhciBpc0pQRUcgPSBmdW5jdGlvbiBpc0pQRUcoZmlsZSkge1xuICAgIHJldHVybiAvXmltYWdlXFwvanBlZy8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIHZhciBNYXJrZXIgPSB7XG4gICAgSlBFRzogMHhmZmQ4LFxuICAgIEFQUDE6IDB4ZmZlMSxcbiAgICBFWElGOiAweDQ1Nzg2OTY2LFxuICAgIFRJRkY6IDB4NDk0OSxcbiAgICBPcmllbnRhdGlvbjogMHgwMTEyLFxuICAgIFVua25vd246IDB4ZmYwMFxuICB9O1xuXG4gIHZhciBnZXRVaW50MTYgPSBmdW5jdGlvbiBnZXRVaW50MTYodmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGxpdHRsZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHJldHVybiB2aWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZSk7XG4gIH07XG4gIHZhciBnZXRVaW50MzIgPSBmdW5jdGlvbiBnZXRVaW50MzIodmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGxpdHRsZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZSk7XG4gIH07XG5cbiAgdmFyIGdldEltYWdlT3JpZW50YXRpb24gPSBmdW5jdGlvbiBnZXRJbWFnZU9yaWVudGF0aW9uKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGUudGFyZ2V0LnJlc3VsdCk7XG5cbiAgICAgICAgLy8gRXZlcnkgSlBFRyBmaWxlIHN0YXJ0cyBmcm9tIGJpbmFyeSB2YWx1ZSAnMHhGRkQ4J1xuICAgICAgICBpZiAoZ2V0VWludDE2KHZpZXcsIDApICE9PSBNYXJrZXIuSlBFRykge1xuICAgICAgICAgIC8vIFRoaXMgYWludCBubyBKUEVHXG4gICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDI7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBtYXJrZXIgPSBnZXRVaW50MTYodmlldywgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gMjtcblxuICAgICAgICAgIC8vIFRoZXJlJ3Mgb3VyIEFQUDEgTWFya2VyXG4gICAgICAgICAgaWYgKG1hcmtlciA9PT0gTWFya2VyLkFQUDEpIHtcbiAgICAgICAgICAgIGlmIChnZXRVaW50MzIodmlldywgKG9mZnNldCArPSAyKSkgIT09IE1hcmtlci5FWElGKSB7XG4gICAgICAgICAgICAgIC8vIG5vIEVYSUYgaW5mbyBkZWZpbmVkXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgVElGRiBIZWFkZXJcbiAgICAgICAgICAgIHZhciBsaXR0bGUgPSBnZXRVaW50MTYodmlldywgKG9mZnNldCArPSA2KSkgPT09IE1hcmtlci5USUZGO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGdldFVpbnQzMih2aWV3LCBvZmZzZXQgKyA0LCBsaXR0bGUpO1xuXG4gICAgICAgICAgICB2YXIgdGFncyA9IGdldFVpbnQxNih2aWV3LCBvZmZzZXQsIGxpdHRsZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gZm91bmQgdGhlIG9yaWVudGF0aW9uIHRhZ1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0VWludDE2KHZpZXcsIG9mZnNldCArIGkgKiAxMiwgbGl0dGxlKSA9PT0gTWFya2VyLk9yaWVudGF0aW9uXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZ2V0VWludDE2KHZpZXcsIG9mZnNldCArIGkgKiAxMiArIDgsIGxpdHRsZSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgobWFya2VyICYgTWFya2VyLlVua25vd24pICE9PSBNYXJrZXIuVW5rbm93bikge1xuICAgICAgICAgICAgLy8gSW52YWxpZFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBnZXRVaW50MTYodmlldywgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgfTtcblxuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byByZWFkIHRoZSBlbnRpcmUgZmlsZSB0byBnZXQgdGhlIG9yaWVudGF0aW9uXG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZS5zbGljZSgwLCA2NCAqIDEwMjQpKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgSVNfQlJPV1NFUiA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICApO1xuICB9KSgpO1xuICB2YXIgaXNCcm93c2VyID0gZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiBJU19CUk9XU0VSO1xuICB9O1xuXG4gIC8vIDJ4MSBwaXhlbCBpbWFnZSA5MENXIHJvdGF0ZWQgd2l0aCBvcmllbnRhdGlvbiBoZWFkZXJcbiAgdmFyIHRlc3RTcmMgPVxuICAgICdkYXRhOmltYWdlL2pwZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELzRRQTZSWGhwWmdBQVRVMEFLZ0FBQUFnQUF3RVNBQU1BQUFBQkFBWUFBQUVvQUFNQUFBQUJBQUlBQUFJVEFBTUFBQUFCQUFFQUFBQUFBQUQvMndCREFQLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy93QUFMQ0FBQkFBSUJBU0lBLzhRQUpnQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUF4QUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFQL2FBQWdCQVFBQVB3QkgvOWs9JztcblxuICAvLyBzaG91bGQgY29ycmVjdCBvcmllbnRhdGlvbiBpZiBpcyBwcmVzZW50ZWQgaW4gbGFuZHNjYXBlLCBpbiB3aGljaCBjYXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYXV0b2NvcnJlY3RcbiAgdmFyIHNob3VsZENvcnJlY3QgPSB1bmRlZmluZWQ7XG4gIHZhciB0ZXN0SW1hZ2UgPSBpc0Jyb3dzZXIoKSA/IG5ldyBJbWFnZSgpIDoge307XG4gIHRlc3RJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHNob3VsZENvcnJlY3QgPSB0ZXN0SW1hZ2UubmF0dXJhbFdpZHRoID4gdGVzdEltYWdlLm5hdHVyYWxIZWlnaHQpO1xuICB9O1xuICB0ZXN0SW1hZ2Uuc3JjID0gdGVzdFNyYztcblxuICB2YXIgc2hvdWxkQ29ycmVjdEltYWdlRXhpZk9yaWVudGF0aW9uID0gZnVuY3Rpb24gc2hvdWxkQ29ycmVjdEltYWdlRXhpZk9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiBzaG91bGRDb3JyZWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkIEltYWdlIE9yaWVudGF0aW9uIFBsdWdpblxuICAgKi9cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF9yZWYuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzO1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgIGlzRmlsZSA9IHV0aWxzLmlzRmlsZTtcblxuICAgIC8vIHN1YnNjcmliZSB0byBmaWxlIGxvYWQgYW5kIGFwcGVuZCByZXF1aXJlZCBpbmZvXG4gICAgYWRkRmlsdGVyKCdESURfTE9BRF9JVEVNJywgZnVuY3Rpb24oaXRlbSwgX3JlZjIpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBnZXQgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgdmFyIGZpbGUgPSBpdGVtLmZpbGU7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBqcGVnIGltYWdlIHdlIGFyZSBub3QgaW50ZXJlc3RlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWlzRmlsZShmaWxlKSB8fFxuICAgICAgICAgICFpc0pQRUcoZmlsZSkgfHxcbiAgICAgICAgICAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9FWElGX09SSUVOVEFUSU9OJykgfHxcbiAgICAgICAgICAhc2hvdWxkQ29ycmVjdEltYWdlRXhpZk9yaWVudGF0aW9uKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gY29udGludWUgd2l0aCB0aGUgdW5hbHRlcmVkIGRhdGFzZXRcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBvcmllbnRhdGlvbiBmcm9tIGV4aWYgZGF0YVxuICAgICAgICBnZXRJbWFnZU9yaWVudGF0aW9uKGZpbGUpLnRoZW4oZnVuY3Rpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgICBpdGVtLnNldE1ldGFkYXRhKCdleGlmJywgeyBvcmllbnRhdGlvbjogb3JpZW50YXRpb24gfSk7XG4gICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEV4cG9zZSBwbHVnaW4gb3B0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGltYWdlIG9yaWVudGF0aW9uIHJlYWRpbmdcbiAgICAgICAgYWxsb3dJbWFnZUV4aWZPcmllbnRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIkMSA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIkMSkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js ***!
  \******************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImagePreview 4.6.10\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  // test if file is of type image and can be viewed in canvas\n  var isPreviewableImage = function isPreviewableImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol.for &&\n          Symbol.for('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol === 'function') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var vectorMultiply = function vectorMultiply(v, amount) {\n    return createVector(v.x * amount, v.y * amount);\n  };\n\n  var vectorAdd = function vectorAdd(a, b) {\n    return createVector(a.x + b.x, a.y + b.y);\n  };\n\n  var vectorNormalize = function vectorNormalize(v) {\n    var l = Math.sqrt(v.x * v.x + v.y * v.y);\n    if (l === 0) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    return createVector(v.x / l, v.y / l);\n  };\n\n  var vectorRotate = function vectorRotate(v, radians, origin) {\n    var cos = Math.cos(radians);\n    var sin = Math.sin(radians);\n    var t = createVector(v.x - origin.x, v.y - origin.y);\n    return createVector(\n      origin.x + cos * t.x - sin * t.y,\n      origin.y + sin * t.x + cos * t.y\n    );\n  };\n\n  var createVector = function createVector() {\n    var x =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return { x: x, y: y };\n  };\n\n  var getMarkupValue = function getMarkupValue(value, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var axis = arguments.length > 3 ? arguments[3] : undefined;\n    if (typeof value === 'string') {\n      return parseFloat(value) * scalar;\n    }\n    if (typeof value === 'number') {\n      return value * (axis ? size[axis] : Math.min(size.width, size.height));\n    }\n    return;\n  };\n\n  var getMarkupStyles = function getMarkupStyles(markup, size, scale) {\n    var lineStyle = markup.borderStyle || markup.lineStyle || 'solid';\n    var fill = markup.backgroundColor || markup.fontColor || 'transparent';\n    var stroke = markup.borderColor || markup.lineColor || 'transparent';\n    var strokeWidth = getMarkupValue(\n      markup.borderWidth || markup.lineWidth,\n      size,\n      scale\n    );\n    var lineCap = markup.lineCap || 'round';\n    var lineJoin = markup.lineJoin || 'round';\n    var dashes =\n      typeof lineStyle === 'string'\n        ? ''\n        : lineStyle\n            .map(function(v) {\n              return getMarkupValue(v, size, scale);\n            })\n            .join(',');\n    var opacity = markup.opacity || 1;\n    return {\n      'stroke-linecap': lineCap,\n      'stroke-linejoin': lineJoin,\n      'stroke-width': strokeWidth || 0,\n      'stroke-dasharray': dashes,\n      stroke: stroke,\n      fill: fill,\n      opacity: opacity\n    };\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  var getMarkupRect = function getMarkupRect(rect, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var left =\n      getMarkupValue(rect.x, size, scalar, 'width') ||\n      getMarkupValue(rect.left, size, scalar, 'width');\n    var top =\n      getMarkupValue(rect.y, size, scalar, 'height') ||\n      getMarkupValue(rect.top, size, scalar, 'height');\n    var width = getMarkupValue(rect.width, size, scalar, 'width');\n    var height = getMarkupValue(rect.height, size, scalar, 'height');\n    var right = getMarkupValue(rect.right, size, scalar, 'width');\n    var bottom = getMarkupValue(rect.bottom, size, scalar, 'height');\n\n    if (!isDefined(top)) {\n      if (isDefined(height) && isDefined(bottom)) {\n        top = size.height - height - bottom;\n      } else {\n        top = bottom;\n      }\n    }\n\n    if (!isDefined(left)) {\n      if (isDefined(width) && isDefined(right)) {\n        left = size.width - width - right;\n      } else {\n        left = right;\n      }\n    }\n\n    if (!isDefined(width)) {\n      if (isDefined(left) && isDefined(right)) {\n        width = size.width - left - right;\n      } else {\n        width = 0;\n      }\n    }\n\n    if (!isDefined(height)) {\n      if (isDefined(top) && isDefined(bottom)) {\n        height = size.height - top - bottom;\n      } else {\n        height = 0;\n      }\n    }\n\n    return {\n      x: left || 0,\n      y: top || 0,\n      width: width || 0,\n      height: height || 0\n    };\n  };\n\n  var pointsToPathShape = function pointsToPathShape(points) {\n    return points\n      .map(function(point, index) {\n        return ''\n          .concat(index === 0 ? 'M' : 'L', ' ')\n          .concat(point.x, ' ')\n          .concat(point.y);\n      })\n      .join(' ');\n  };\n\n  var setAttributes = function setAttributes(element, attr) {\n    return Object.keys(attr).forEach(function(key) {\n      return element.setAttribute(key, attr[key]);\n    });\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svg = function svg(tag, attr) {\n    var element = document.createElementNS(ns, tag);\n    if (attr) {\n      setAttributes(element, attr);\n    }\n    return element;\n  };\n\n  var updateRect = function updateRect(element) {\n    return setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles)\n    );\n  };\n\n  var updateEllipse = function updateEllipse(element) {\n    var cx = element.rect.x + element.rect.width * 0.5;\n    var cy = element.rect.y + element.rect.height * 0.5;\n    var rx = element.rect.width * 0.5;\n    var ry = element.rect.height * 0.5;\n    return setAttributes(\n      element,\n      Object.assign(\n        {\n          cx: cx,\n          cy: cy,\n          rx: rx,\n          ry: ry\n        },\n        element.styles\n      )\n    );\n  };\n\n  var IMAGE_FIT_STYLE = {\n    contain: 'xMidYMid meet',\n    cover: 'xMidYMid slice'\n  };\n\n  var updateImage = function updateImage(element, markup) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || 'none'\n      })\n    );\n  };\n\n  var TEXT_ANCHOR = {\n    left: 'start',\n    center: 'middle',\n    right: 'end'\n  };\n\n  var updateText = function updateText(element, markup, size, scale) {\n    var fontSize = getMarkupValue(markup.fontSize, size, scale);\n    var fontFamily = markup.fontFamily || 'sans-serif';\n    var fontWeight = markup.fontWeight || 'normal';\n    var textAlign = TEXT_ANCHOR[markup.textAlign] || 'start';\n\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        'stroke-width': 0,\n        'font-weight': fontWeight,\n        'font-size': fontSize,\n        'font-family': fontFamily,\n        'text-anchor': textAlign\n      })\n    );\n\n    // update text\n    if (element.text !== markup.text) {\n      element.text = markup.text;\n      element.textContent = markup.text.length ? markup.text : ' ';\n    }\n  };\n\n  var updateLine = function updateLine(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        fill: 'none'\n      })\n    );\n\n    var line = element.childNodes[0];\n    var begin = element.childNodes[1];\n    var end = element.childNodes[2];\n\n    var origin = element.rect;\n\n    var target = {\n      x: element.rect.x + element.rect.width,\n      y: element.rect.y + element.rect.height\n    };\n\n    setAttributes(line, {\n      x1: origin.x,\n      y1: origin.y,\n      x2: target.x,\n      y2: target.y\n    });\n\n    if (!markup.lineDecoration) return;\n\n    begin.style.display = 'none';\n    end.style.display = 'none';\n\n    var v = vectorNormalize({\n      x: target.x - origin.x,\n      y: target.y - origin.y\n    });\n\n    var l = getMarkupValue(0.05, size, scale);\n\n    if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n      var arrowBeginRotationPoint = vectorMultiply(v, l);\n      var arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n      var arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n      var arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n      setAttributes(begin, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowBeginA.x, ',')\n          .concat(arrowBeginA.y, ' L')\n          .concat(origin.x, ',')\n          .concat(origin.y, ' L')\n          .concat(arrowBeginB.x, ',')\n          .concat(arrowBeginB.y)\n      });\n    }\n\n    if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n      var arrowEndRotationPoint = vectorMultiply(v, -l);\n      var arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n      var arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n      var arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n      setAttributes(end, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowEndA.x, ',')\n          .concat(arrowEndA.y, ' L')\n          .concat(target.x, ',')\n          .concat(target.y, ' L')\n          .concat(arrowEndB.x, ',')\n          .concat(arrowEndB.y)\n      });\n    }\n  };\n\n  var updatePath = function updatePath(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.styles, {\n        fill: 'none',\n        d: pointsToPathShape(\n          markup.points.map(function(point) {\n            return {\n              x: getMarkupValue(point.x, size, scale, 'width'),\n              y: getMarkupValue(point.y, size, scale, 'height')\n            };\n          })\n        )\n      })\n    );\n  };\n\n  var createShape = function createShape(node) {\n    return function(markup) {\n      return svg(node, { id: markup.id });\n    };\n  };\n\n  var createImage = function createImage(markup) {\n    var shape = svg('image', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round',\n      opacity: '0'\n    });\n\n    shape.onload = function() {\n      shape.setAttribute('opacity', markup.opacity || 1);\n    };\n    shape.setAttributeNS(\n      'http://www.w3.org/1999/xlink',\n      'xlink:href',\n      markup.src\n    );\n    return shape;\n  };\n\n  var createLine = function createLine(markup) {\n    var shape = svg('g', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round'\n    });\n\n    var line = svg('line');\n    shape.appendChild(line);\n\n    var begin = svg('path');\n    shape.appendChild(begin);\n\n    var end = svg('path');\n    shape.appendChild(end);\n\n    return shape;\n  };\n\n  var CREATE_TYPE_ROUTES = {\n    image: createImage,\n    rect: createShape('rect'),\n    ellipse: createShape('ellipse'),\n    text: createShape('text'),\n    path: createShape('path'),\n    line: createLine\n  };\n\n  var UPDATE_TYPE_ROUTES = {\n    rect: updateRect,\n    ellipse: updateEllipse,\n    image: updateImage,\n    text: updateText,\n    path: updatePath,\n    line: updateLine\n  };\n\n  var createMarkupByType = function createMarkupByType(type, markup) {\n    return CREATE_TYPE_ROUTES[type](markup);\n  };\n\n  var updateMarkupByType = function updateMarkupByType(\n    element,\n    type,\n    markup,\n    size,\n    scale\n  ) {\n    if (type !== 'path') {\n      element.rect = getMarkupRect(markup, size, scale);\n    }\n    element.styles = getMarkupStyles(markup, size, scale);\n    UPDATE_TYPE_ROUTES[type](element, markup, size, scale);\n  };\n\n  var MARKUP_RECT = [\n    'x',\n    'y',\n    'left',\n    'top',\n    'right',\n    'bottom',\n    'width',\n    'height'\n  ];\n\n  var toOptionalFraction = function toOptionalFraction(value) {\n    return typeof value === 'string' && /%/.test(value)\n      ? parseFloat(value) / 100\n      : value;\n  };\n\n  // adds default markup properties, clones markup\n  var prepareMarkup = function prepareMarkup(markup) {\n    var _markup = _slicedToArray(markup, 2),\n      type = _markup[0],\n      props = _markup[1];\n\n    var rect = props.points\n      ? {}\n      : MARKUP_RECT.reduce(function(prev, curr) {\n          prev[curr] = toOptionalFraction(props[curr]);\n          return prev;\n        }, {});\n\n    return [\n      type,\n      Object.assign(\n        {\n          zIndex: 0\n        },\n        props,\n        rect\n      )\n    ];\n  };\n\n  var sortMarkupByZIndex = function sortMarkupByZIndex(a, b) {\n    if (a[1].zIndex > b[1].zIndex) {\n      return 1;\n    }\n    if (a[1].zIndex < b[1].zIndex) {\n      return -1;\n    }\n    return 0;\n  };\n\n  var createMarkupView = function createMarkupView(_) {\n    return _.utils.createView({\n      name: 'image-preview-markup',\n      tag: 'svg',\n      ignoreRect: true,\n      mixins: {\n        apis: ['width', 'height', 'crop', 'markup', 'resize', 'dirty']\n      },\n\n      write: function write(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n\n        if (!props.dirty) return;\n        var crop = props.crop,\n          resize = props.resize,\n          markup = props.markup;\n\n        var viewWidth = props.width;\n        var viewHeight = props.height;\n\n        var cropWidth = crop.width;\n        var cropHeight = crop.height;\n\n        if (resize) {\n          var _size = resize.size;\n\n          var outputWidth = _size && _size.width;\n          var outputHeight = _size && _size.height;\n          var outputFit = resize.mode;\n          var outputUpscale = resize.upscale;\n\n          if (outputWidth && !outputHeight) outputHeight = outputWidth;\n          if (outputHeight && !outputWidth) outputWidth = outputHeight;\n\n          var shouldUpscale =\n            cropWidth < outputWidth && cropHeight < outputHeight;\n\n          if (!shouldUpscale || (shouldUpscale && outputUpscale)) {\n            var scalarWidth = outputWidth / cropWidth;\n            var scalarHeight = outputHeight / cropHeight;\n\n            if (outputFit === 'force') {\n              cropWidth = outputWidth;\n              cropHeight = outputHeight;\n            } else {\n              var scalar;\n              if (outputFit === 'cover') {\n                scalar = Math.max(scalarWidth, scalarHeight);\n              } else if (outputFit === 'contain') {\n                scalar = Math.min(scalarWidth, scalarHeight);\n              }\n              cropWidth = cropWidth * scalar;\n              cropHeight = cropHeight * scalar;\n            }\n          }\n        }\n\n        var size = {\n          width: viewWidth,\n          height: viewHeight\n        };\n\n        root.element.setAttribute('width', size.width);\n        root.element.setAttribute('height', size.height);\n\n        var scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);\n\n        // clear\n        root.element.innerHTML = '';\n\n        // get filter\n        var markupFilter = root.query('GET_IMAGE_PREVIEW_MARKUP_FILTER');\n\n        // draw new\n        markup\n          .filter(markupFilter)\n          .map(prepareMarkup)\n          .sort(sortMarkupByZIndex)\n          .forEach(function(markup) {\n            var _markup = _slicedToArray(markup, 2),\n              type = _markup[0],\n              settings = _markup[1];\n\n            // create\n            var element = createMarkupByType(type, settings);\n\n            // update\n            updateMarkupByType(element, type, settings, size, scale);\n\n            // add\n            root.element.appendChild(element);\n          });\n      }\n    });\n  };\n\n  var createVector$1 = function createVector(x, y) {\n    return { x: x, y: y };\n  };\n\n  var vectorDot = function vectorDot(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n\n  var vectorSubtract = function vectorSubtract(a, b) {\n    return createVector$1(a.x - b.x, a.y - b.y);\n  };\n\n  var vectorDistanceSquared = function vectorDistanceSquared(a, b) {\n    return vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));\n  };\n\n  var vectorDistance = function vectorDistance(a, b) {\n    return Math.sqrt(vectorDistanceSquared(a, b));\n  };\n\n  var getOffsetPointOnEdge = function getOffsetPointOnEdge(length, rotation) {\n    var a = length;\n\n    var A = 1.5707963267948966;\n    var B = rotation;\n    var C = 1.5707963267948966 - rotation;\n\n    var sinA = Math.sin(A);\n    var sinB = Math.sin(B);\n    var sinC = Math.sin(C);\n    var cosC = Math.cos(C);\n    var ratio = a / sinA;\n    var b = ratio * sinB;\n    var c = ratio * sinC;\n\n    return createVector$1(cosC * b, cosC * c);\n  };\n\n  var getRotatedRectSize = function getRotatedRectSize(rect, rotation) {\n    var w = rect.width;\n    var h = rect.height;\n\n    var hor = getOffsetPointOnEdge(w, rotation);\n    var ver = getOffsetPointOnEdge(h, rotation);\n\n    var tl = createVector$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));\n\n    var tr = createVector$1(\n      rect.x + rect.width + Math.abs(ver.y),\n      rect.y + Math.abs(ver.x)\n    );\n\n    var bl = createVector$1(\n      rect.x - Math.abs(ver.y),\n      rect.y + rect.height - Math.abs(ver.x)\n    );\n\n    return {\n      width: vectorDistance(tl, tr),\n      height: vectorDistance(tl, bl)\n    };\n  };\n\n  var calculateCanvasSize = function calculateCanvasSize(\n    image,\n    canvasAspectRatio\n  ) {\n    var zoom =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var imageAspectRatio = image.height / image.width;\n\n    // determine actual pixels on x and y axis\n    var canvasWidth = 1;\n    var canvasHeight = canvasAspectRatio;\n    var imgWidth = 1;\n    var imgHeight = imageAspectRatio;\n    if (imgHeight > canvasHeight) {\n      imgHeight = canvasHeight;\n      imgWidth = imgHeight / imageAspectRatio;\n    }\n\n    var scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);\n    var width = image.width / (zoom * scalar * imgWidth);\n    var height = width * canvasAspectRatio;\n\n    return {\n      width: width,\n      height: height\n    };\n  };\n\n  var getImageRectZoomFactor = function getImageRectZoomFactor(\n    imageRect,\n    cropRect,\n    rotation,\n    center\n  ) {\n    // calculate available space round image center position\n    var cx = center.x > 0.5 ? 1 - center.x : center.x;\n    var cy = center.y > 0.5 ? 1 - center.y : center.y;\n    var imageWidth = cx * 2 * imageRect.width;\n    var imageHeight = cy * 2 * imageRect.height;\n\n    // calculate rotated crop rectangle size\n    var rotatedCropSize = getRotatedRectSize(cropRect, rotation);\n\n    // calculate scalar required to fit image\n    return Math.max(\n      rotatedCropSize.width / imageWidth,\n      rotatedCropSize.height / imageHeight\n    );\n  };\n\n  var getCenteredCropRect = function getCenteredCropRect(\n    container,\n    aspectRatio\n  ) {\n    var width = container.width;\n    var height = width * aspectRatio;\n    if (height > container.height) {\n      height = container.height;\n      width = height / aspectRatio;\n    }\n    var x = (container.width - width) * 0.5;\n    var y = (container.height - height) * 0.5;\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  var getCurrentCropSize = function getCurrentCropSize(imageSize) {\n    var crop =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var zoom = crop.zoom,\n      rotation = crop.rotation,\n      center = crop.center,\n      aspectRatio = crop.aspectRatio;\n\n    if (!aspectRatio) aspectRatio = imageSize.height / imageSize.width;\n\n    var canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n\n    var canvasCenter = {\n      x: canvasSize.width * 0.5,\n      y: canvasSize.height * 0.5\n    };\n\n    var stage = {\n      x: 0,\n      y: 0,\n      width: canvasSize.width,\n      height: canvasSize.height,\n      center: canvasCenter\n    };\n\n    var shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n    var stageZoomFactor = getImageRectZoomFactor(\n      imageSize,\n      getCenteredCropRect(stage, aspectRatio),\n      rotation,\n      shouldLimit ? center : { x: 0.5, y: 0.5 }\n    );\n\n    var scale = zoom * stageZoomFactor;\n\n    // start drawing\n    return {\n      widthFloat: canvasSize.width / scale,\n      heightFloat: canvasSize.height / scale,\n      width: Math.round(canvasSize.width / scale),\n      height: Math.round(canvasSize.height / scale)\n    };\n  };\n\n  var IMAGE_SCALE_SPRING_PROPS = {\n    type: 'spring',\n    stiffness: 0.5,\n    damping: 0.45,\n    mass: 10\n  };\n\n  // does horizontal and vertical flipping\n  var createBitmapView = function createBitmapView(_) {\n    return _.utils.createView({\n      name: 'image-bitmap',\n      ignoreRect: true,\n      mixins: { styles: ['scaleX', 'scaleY'] },\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        root.appendChild(props.image);\n      }\n    });\n  };\n\n  // shifts and rotates image\n  var createImageCanvasWrapper = function createImageCanvasWrapper(_) {\n    return _.utils.createView({\n      name: 'image-canvas-wrapper',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['crop', 'width', 'height'],\n\n        styles: [\n          'originX',\n          'originY',\n          'translateX',\n          'translateY',\n          'scaleX',\n          'scaleY',\n          'rotateZ'\n        ],\n\n        animations: {\n          originX: IMAGE_SCALE_SPRING_PROPS,\n          originY: IMAGE_SCALE_SPRING_PROPS,\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateX: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          rotateZ: IMAGE_SCALE_SPRING_PROPS\n        }\n      },\n\n      create: function create(_ref2) {\n        var root = _ref2.root,\n          props = _ref2.props;\n        props.width = props.image.width;\n        props.height = props.image.height;\n        root.ref.bitmap = root.appendChildView(\n          root.createChildView(createBitmapView(_), { image: props.image })\n        );\n      },\n      write: function write(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        var flip = props.crop.flip;\n        var bitmap = root.ref.bitmap;\n        bitmap.scaleX = flip.horizontal ? -1 : 1;\n        bitmap.scaleY = flip.vertical ? -1 : 1;\n      }\n    });\n  };\n\n  // clips canvas to correct aspect ratio\n  var createClipView = function createClipView(_) {\n    return _.utils.createView({\n      name: 'image-clip',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: [\n          'crop',\n          'markup',\n          'resize',\n          'width',\n          'height',\n          'dirty',\n          'background'\n        ],\n\n        styles: ['width', 'height', 'opacity'],\n        animations: {\n          opacity: { type: 'tween', duration: 250 }\n        }\n      },\n\n      didWriteView: function didWriteView(_ref4) {\n        var root = _ref4.root,\n          props = _ref4.props;\n        if (!props.background) return;\n        root.element.style.backgroundColor = props.background;\n      },\n      create: function create(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n\n        root.ref.image = root.appendChildView(\n          root.createChildView(\n            createImageCanvasWrapper(_),\n            Object.assign({}, props)\n          )\n        );\n\n        root.ref.createMarkup = function() {\n          if (root.ref.markup) return;\n          root.ref.markup = root.appendChildView(\n            root.createChildView(createMarkupView(_), Object.assign({}, props))\n          );\n        };\n\n        root.ref.destroyMarkup = function() {\n          if (!root.ref.markup) return;\n          root.removeChildView(root.ref.markup);\n          root.ref.markup = null;\n        };\n\n        // set up transparency grid\n        var transparencyIndicator = root.query(\n          'GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR'\n        );\n        if (transparencyIndicator === null) return;\n\n        // grid pattern\n        if (transparencyIndicator === 'grid') {\n          root.element.dataset.transparencyIndicator = transparencyIndicator;\n        }\n        // basic color\n        else {\n          root.element.dataset.transparencyIndicator = 'color';\n        }\n      },\n      write: function write(_ref6) {\n        var root = _ref6.root,\n          props = _ref6.props,\n          shouldOptimize = _ref6.shouldOptimize;\n        var crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty,\n          width = props.width,\n          height = props.height;\n\n        root.ref.image.crop = crop;\n\n        var stage = {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          center: {\n            x: width * 0.5,\n            y: height * 0.5\n          }\n        };\n\n        var image = {\n          width: root.ref.image.width,\n          height: root.ref.image.height\n        };\n\n        var origin = {\n          x: crop.center.x * image.width,\n          y: crop.center.y * image.height\n        };\n\n        var translation = {\n          x: stage.center.x - image.width * crop.center.x,\n          y: stage.center.y - image.height * crop.center.y\n        };\n\n        var rotation = Math.PI * 2 + (crop.rotation % (Math.PI * 2));\n\n        var cropAspectRatio = crop.aspectRatio || image.height / image.width;\n\n        var shouldLimit =\n          typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n        var stageZoomFactor = getImageRectZoomFactor(\n          image,\n          getCenteredCropRect(stage, cropAspectRatio),\n\n          rotation,\n          shouldLimit ? crop.center : { x: 0.5, y: 0.5 }\n        );\n\n        var scale = crop.zoom * stageZoomFactor;\n\n        // update markup view\n        if (markup && markup.length) {\n          root.ref.createMarkup();\n          root.ref.markup.width = width;\n          root.ref.markup.height = height;\n          root.ref.markup.resize = resize;\n          root.ref.markup.dirty = dirty;\n          root.ref.markup.markup = markup;\n          root.ref.markup.crop = getCurrentCropSize(image, crop);\n        } else if (root.ref.markup) {\n          root.ref.destroyMarkup();\n        }\n\n        // update image view\n        var imageView = root.ref.image;\n\n        // don't update clip layout\n        if (shouldOptimize) {\n          imageView.originX = null;\n          imageView.originY = null;\n          imageView.translateX = null;\n          imageView.translateY = null;\n          imageView.rotateZ = null;\n          imageView.scaleX = null;\n          imageView.scaleY = null;\n          return;\n        }\n\n        imageView.originX = origin.x;\n        imageView.originY = origin.y;\n        imageView.translateX = translation.x;\n        imageView.translateY = translation.y;\n        imageView.rotateZ = rotation;\n        imageView.scaleX = scale;\n        imageView.scaleY = scale;\n      }\n    });\n  };\n\n  var createImageView = function createImageView(_) {\n    return _.utils.createView({\n      name: 'image-preview',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['image', 'crop', 'markup', 'resize', 'dirty', 'background'],\n\n        styles: ['translateY', 'scaleX', 'scaleY', 'opacity'],\n\n        animations: {\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          opacity: { type: 'tween', duration: 400 }\n        }\n      },\n\n      create: function create(_ref7) {\n        var root = _ref7.root,\n          props = _ref7.props;\n        root.ref.clip = root.appendChildView(\n          root.createChildView(createClipView(_), {\n            id: props.id,\n            image: props.image,\n            crop: props.crop,\n            markup: props.markup,\n            resize: props.resize,\n            dirty: props.dirty,\n            background: props.background\n          })\n        );\n      },\n      write: function write(_ref8) {\n        var root = _ref8.root,\n          props = _ref8.props,\n          shouldOptimize = _ref8.shouldOptimize;\n        var clip = root.ref.clip;\n        var image = props.image,\n          crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty;\n\n        clip.crop = crop;\n        clip.markup = markup;\n        clip.resize = resize;\n        clip.dirty = dirty;\n\n        // don't update clip layout\n        clip.opacity = shouldOptimize ? 0 : 1;\n\n        // don't re-render if optimizing or hidden (width will be zero resulting in weird animations)\n        if (shouldOptimize || root.rect.element.hidden) return;\n\n        // calculate scaled preview image size\n        var imageAspectRatio = image.height / image.width;\n        var aspectRatio = crop.aspectRatio || imageAspectRatio;\n\n        // calculate container size\n        var containerWidth = root.rect.inner.width;\n        var containerHeight = root.rect.inner.height;\n\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n\n        if (panelAspectRatio && !allowMultiple) {\n          fixedPreviewHeight = containerWidth * panelAspectRatio;\n          aspectRatio = panelAspectRatio;\n        }\n\n        // determine clip width and height\n        var clipHeight =\n          fixedPreviewHeight !== null\n            ? fixedPreviewHeight\n            : Math.max(\n                minPreviewHeight,\n                Math.min(containerWidth * aspectRatio, maxPreviewHeight)\n              );\n\n        var clipWidth = clipHeight / aspectRatio;\n        if (clipWidth > containerWidth) {\n          clipWidth = containerWidth;\n          clipHeight = clipWidth * aspectRatio;\n        }\n\n        if (clipHeight > containerHeight) {\n          clipHeight = containerHeight;\n          clipWidth = containerHeight / aspectRatio;\n        }\n\n        clip.width = clipWidth;\n        clip.height = clipHeight;\n      }\n    });\n  };\n\n  var SVG_MASK =\n    '<svg width=\"500\" height=\"200\" viewBox=\"0 0 500 200\" preserveAspectRatio=\"none\">\\n    <defs>\\n        <radialGradient id=\"gradient-__UID__\" cx=\".5\" cy=\"1.25\" r=\"1.15\">\\n            <stop offset=\\'50%\\' stop-color=\\'#000000\\'/>\\n            <stop offset=\\'56%\\' stop-color=\\'#0a0a0a\\'/>\\n            <stop offset=\\'63%\\' stop-color=\\'#262626\\'/>\\n            <stop offset=\\'69%\\' stop-color=\\'#4f4f4f\\'/>\\n            <stop offset=\\'75%\\' stop-color=\\'#808080\\'/>\\n            <stop offset=\\'81%\\' stop-color=\\'#b1b1b1\\'/>\\n            <stop offset=\\'88%\\' stop-color=\\'#dadada\\'/>\\n            <stop offset=\\'94%\\' stop-color=\\'#f6f6f6\\'/>\\n            <stop offset=\\'100%\\' stop-color=\\'#ffffff\\'/>\\n        </radialGradient>\\n        <mask id=\"mask-__UID__\">\\n            <rect x=\"0\" y=\"0\" width=\"500\" height=\"200\" fill=\"url(#gradient-__UID__)\"></rect>\\n        </mask>\\n    </defs>\\n    <rect x=\"0\" width=\"500\" height=\"200\" fill=\"currentColor\" mask=\"url(#mask-__UID__)\"></rect>\\n</svg>';\n\n  var SVGMaskUniqueId = 0;\n\n  var createImageOverlayView = function createImageOverlayView(fpAPI) {\n    return fpAPI.utils.createView({\n      name: 'image-preview-overlay',\n      tag: 'div',\n      ignoreRect: true,\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        var mask = SVG_MASK;\n        if (document.querySelector('base')) {\n          var url = window.location.href.replace(window.location.hash, '');\n          mask = mask.replace(/url\\(\\#/g, 'url(' + url + '#');\n        }\n\n        SVGMaskUniqueId++;\n        root.element.classList.add(\n          'filepond--image-preview-overlay-'.concat(props.status)\n        );\n\n        root.element.innerHTML = mask.replace(/__UID__/g, SVGMaskUniqueId);\n      },\n      mixins: {\n        styles: ['opacity'],\n        animations: {\n          opacity: { type: 'spring', mass: 25 }\n        }\n      }\n    });\n  };\n\n  /**\n   * Bitmap Worker\n   */\n  var BitmapWorker = function BitmapWorker() {\n    self.onmessage = function(e) {\n      createImageBitmap(e.data.message.file).then(function(bitmap) {\n        self.postMessage({ id: e.data.id, message: bitmap }, [bitmap]);\n      });\n    };\n  };\n\n  /**\n   * ColorMatrix Worker\n   */\n  var ColorMatrixWorker = function ColorMatrixWorker() {\n    self.onmessage = function(e) {\n      var imageData = e.data.message.imageData;\n      var matrix = e.data.message.colorMatrix;\n\n      var data = imageData.data;\n      var l = data.length;\n\n      var m11 = matrix[0];\n      var m12 = matrix[1];\n      var m13 = matrix[2];\n      var m14 = matrix[3];\n      var m15 = matrix[4];\n\n      var m21 = matrix[5];\n      var m22 = matrix[6];\n      var m23 = matrix[7];\n      var m24 = matrix[8];\n      var m25 = matrix[9];\n\n      var m31 = matrix[10];\n      var m32 = matrix[11];\n      var m33 = matrix[12];\n      var m34 = matrix[13];\n      var m35 = matrix[14];\n\n      var m41 = matrix[15];\n      var m42 = matrix[16];\n      var m43 = matrix[17];\n      var m44 = matrix[18];\n      var m45 = matrix[19];\n\n      var index = 0,\n        r = 0.0,\n        g = 0.0,\n        b = 0.0,\n        a = 0.0;\n\n      for (; index < l; index += 4) {\n        r = data[index] / 255;\n        g = data[index + 1] / 255;\n        b = data[index + 2] / 255;\n        a = data[index + 3] / 255;\n        data[index] = Math.max(\n          0,\n          Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255)\n        );\n        data[index + 1] = Math.max(\n          0,\n          Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255)\n        );\n        data[index + 2] = Math.max(\n          0,\n          Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255)\n        );\n        data[index + 3] = Math.max(\n          0,\n          Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255)\n        );\n      }\n\n      self.postMessage({ id: e.data.id, message: imageData }, [\n        imageData.data.buffer\n      ]);\n    };\n  };\n\n  var getImageSize = function getImageSize(url, cb) {\n    var image = new Image();\n    image.onload = function() {\n      var width = image.naturalWidth;\n      var height = image.naturalHeight;\n      image = null;\n      cb(width, height);\n    };\n    image.src = url;\n  };\n\n  var transforms = {\n    1: function _() {\n      return [1, 0, 0, 1, 0, 0];\n    },\n    2: function _(width) {\n      return [-1, 0, 0, 1, width, 0];\n    },\n    3: function _(width, height) {\n      return [-1, 0, 0, -1, width, height];\n    },\n    4: function _(width, height) {\n      return [1, 0, 0, -1, 0, height];\n    },\n    5: function _() {\n      return [0, 1, 1, 0, 0, 0];\n    },\n    6: function _(width, height) {\n      return [0, 1, -1, 0, height, 0];\n    },\n    7: function _(width, height) {\n      return [0, -1, -1, 0, height, width];\n    },\n    8: function _(width) {\n      return [0, -1, 1, 0, 0, width];\n    }\n  };\n\n  var fixImageOrientation = function fixImageOrientation(\n    ctx,\n    width,\n    height,\n    orientation\n  ) {\n    // no orientation supplied\n    if (orientation === -1) {\n      return;\n    }\n\n    ctx.transform.apply(ctx, transforms[orientation](width, height));\n  };\n\n  // draws the preview image to canvas\n  var createPreviewImage = function createPreviewImage(\n    data,\n    width,\n    height,\n    orientation\n  ) {\n    // can't draw on half pixels\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // draw image\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n\n    // if is rotated incorrectly swap width and height\n    if (orientation >= 5 && orientation <= 8) {\n      var _ref = [height, width];\n      width = _ref[0];\n      height = _ref[1];\n    }\n\n    // correct image orientation\n    fixImageOrientation(ctx, width, height, orientation);\n\n    // draw the image\n    ctx.drawImage(data, 0, 0, width, height);\n\n    return canvas;\n  };\n\n  var isBitmap = function isBitmap(file) {\n    return /^image/.test(file.type) && !/svg/.test(file.type);\n  };\n\n  var MAX_WIDTH = 10;\n  var MAX_HEIGHT = 10;\n\n  var calculateAverageColor = function calculateAverageColor(image) {\n    var scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);\n\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var width = (canvas.width = Math.ceil(image.width * scalar));\n    var height = (canvas.height = Math.ceil(image.height * scalar));\n    ctx.drawImage(image, 0, 0, width, height);\n    var data = null;\n    try {\n      data = ctx.getImageData(0, 0, width, height).data;\n    } catch (e) {\n      return null;\n    }\n    var l = data.length;\n\n    var r = 0;\n    var g = 0;\n    var b = 0;\n    var i = 0;\n\n    for (; i < l; i += 4) {\n      r += data[i] * data[i];\n      g += data[i + 1] * data[i + 1];\n      b += data[i + 2] * data[i + 2];\n    }\n\n    r = averageColor(r, l);\n    g = averageColor(g, l);\n    b = averageColor(b, l);\n\n    return { r: r, g: g, b: b };\n  };\n\n  var averageColor = function averageColor(c, l) {\n    return Math.floor(Math.sqrt(c / (l / 4)));\n  };\n\n  var cloneCanvas = function cloneCanvas(origin, target) {\n    target = target || document.createElement('canvas');\n    target.width = origin.width;\n    target.height = origin.height;\n    var ctx = target.getContext('2d');\n    ctx.drawImage(origin, 0, 0);\n    return target;\n  };\n\n  var cloneImageData = function cloneImageData(imageData) {\n    var id;\n    try {\n      id = new ImageData(imageData.width, imageData.height);\n    } catch (e) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      id = ctx.createImageData(imageData.width, imageData.height);\n    }\n    id.data.set(new Uint8ClampedArray(imageData.data));\n    return id;\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.crossOrigin = 'Anonymous';\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var createImageWrapperView = function createImageWrapperView(_) {\n    // create overlay view\n    var OverlayView = createImageOverlayView(_);\n\n    var ImageView = createImageView(_);\n    var createWorker = _.utils.createWorker;\n\n    var applyFilter = function applyFilter(root, filter, target) {\n      return new Promise(function(resolve) {\n        // will store image data for future filter updates\n        if (!root.ref.imageData) {\n          root.ref.imageData = target\n            .getContext('2d')\n            .getImageData(0, 0, target.width, target.height);\n        }\n\n        // get image data reference\n        var imageData = cloneImageData(root.ref.imageData);\n\n        if (!filter || filter.length !== 20) {\n          target.getContext('2d').putImageData(imageData, 0, 0);\n          return resolve();\n        }\n\n        var worker = createWorker(ColorMatrixWorker);\n        worker.post(\n          {\n            imageData: imageData,\n            colorMatrix: filter\n          },\n\n          function(response) {\n            // apply filtered colors\n            target.getContext('2d').putImageData(response, 0, 0);\n\n            // stop worker\n            worker.terminate();\n\n            // done!\n            resolve();\n          },\n          [imageData.data.buffer]\n        );\n      });\n    };\n\n    var removeImageView = function removeImageView(root, imageView) {\n      root.removeChildView(imageView);\n      imageView.image.width = 1;\n      imageView.image.height = 1;\n      imageView._destroy();\n    };\n\n    // remove an image\n    var shiftImage = function shiftImage(_ref) {\n      var root = _ref.root;\n      var imageView = root.ref.images.shift();\n      imageView.opacity = 0;\n      imageView.translateY = -15;\n      root.ref.imageViewBin.push(imageView);\n      return imageView;\n    };\n\n    // add new image\n    var pushImage = function pushImage(_ref2) {\n      var root = _ref2.root,\n        props = _ref2.props,\n        image = _ref2.image;\n      var id = props.id;\n      var item = root.query('GET_ITEM', { id: id });\n      if (!item) return;\n\n      var crop = item.getMetadata('crop') || {\n        center: {\n          x: 0.5,\n          y: 0.5\n        },\n\n        flip: {\n          horizontal: false,\n          vertical: false\n        },\n\n        zoom: 1,\n        rotation: 0,\n        aspectRatio: null\n      };\n\n      var background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n\n      var markup;\n      var resize;\n      var dirty = false;\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        markup = item.getMetadata('markup') || [];\n        resize = item.getMetadata('resize');\n        dirty = true;\n      }\n\n      // append image presenter\n      var imageView = root.appendChildView(\n        root.createChildView(ImageView, {\n          id: id,\n          image: image,\n          crop: crop,\n          resize: resize,\n          markup: markup,\n          dirty: dirty,\n          background: background,\n          opacity: 0,\n          scaleX: 1.15,\n          scaleY: 1.15,\n          translateY: 15\n        }),\n\n        root.childViews.length\n      );\n\n      root.ref.images.push(imageView);\n\n      // reveal the preview image\n      imageView.opacity = 1;\n      imageView.scaleX = 1;\n      imageView.scaleY = 1;\n      imageView.translateY = 0;\n\n      // the preview is now ready to be drawn\n      setTimeout(function() {\n        root.dispatch('DID_IMAGE_PREVIEW_SHOW', { id: id });\n      }, 250);\n    };\n\n    var updateImage = function updateImage(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n      var imageView = root.ref.images[root.ref.images.length - 1];\n      imageView.crop = item.getMetadata('crop');\n      imageView.background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        imageView.dirty = true;\n        imageView.resize = item.getMetadata('resize');\n        imageView.markup = item.getMetadata('markup');\n      }\n    };\n\n    // replace image preview\n    var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n      var root = _ref4.root,\n        props = _ref4.props,\n        action = _ref4.action;\n      // only filter and crop trigger redraw\n      if (!/crop|filter|markup|resize/.test(action.change.key)) return;\n\n      // no images to update, exit\n      if (!root.ref.images.length) return;\n\n      // no item found, exit\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n\n      // for now, update existing image when filtering\n      if (/filter/.test(action.change.key)) {\n        var imageView = root.ref.images[root.ref.images.length - 1];\n        applyFilter(root, action.change.value, imageView.image);\n        return;\n      }\n\n      if (/crop|markup|resize/.test(action.change.key)) {\n        var crop = item.getMetadata('crop');\n        var image = root.ref.images[root.ref.images.length - 1];\n\n        // if aspect ratio has changed, we need to create a new image\n        if (\n          crop &&\n          crop.aspectRatio &&\n          image.crop &&\n          image.crop.aspectRatio &&\n          Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 0.00001\n        ) {\n          var _imageView = shiftImage({ root: root });\n          pushImage({\n            root: root,\n            props: props,\n            image: cloneCanvas(_imageView.image)\n          });\n        }\n        // if not, we can update the current image\n        else {\n          updateImage({ root: root, props: props });\n        }\n      }\n    };\n\n    var canCreateImageBitmap = function canCreateImageBitmap(file) {\n      // Firefox versions before 58 will freeze when running createImageBitmap\n      // in a Web Worker so we detect those versions and return false for support\n      var userAgent = window.navigator.userAgent;\n      var isFirefox = userAgent.match(/Firefox\\/([0-9]+)\\./);\n      var firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;\n      if (firefoxVersion <= 58) return false;\n\n      return 'createImageBitmap' in window && isBitmap(file);\n    };\n\n    /**\n     * Write handler for when preview container has been created\n     */\n    var didCreatePreviewContainer = function didCreatePreviewContainer(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // determine image size of this item\n      getImageSize(fileURL, function(width, height) {\n        // we can now scale the panel to the final size\n        root.dispatch('DID_IMAGE_PREVIEW_CALCULATE_SIZE', {\n          id: id,\n          width: width,\n          height: height\n        });\n      });\n    };\n\n    var drawPreview = function drawPreview(_ref6) {\n      var root = _ref6.root,\n        props = _ref6.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // fallback\n      var loadPreviewFallback = function loadPreviewFallback() {\n        // let's scale the image in the main thread :(\n        loadImage(fileURL).then(previewImageLoaded);\n      };\n\n      // image is now ready\n      var previewImageLoaded = function previewImageLoaded(imageData) {\n        // the file url is no longer needed\n        URL.revokeObjectURL(fileURL);\n\n        // draw the scaled down version here and use that as source so bitmapdata can be closed\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap if orientation is incorrect\n        var width = imageData.width,\n          height = imageData.height;\n\n        // if no width or height, just return early.\n        if (!width || !height) return;\n\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref7 = [height, width];\n          width = _ref7[0];\n          height = _ref7[1];\n        }\n\n        // scale canvas based on pixel density\n        // we multiply by .75 as that creates smaller but still clear images on screens with high res displays\n        var pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);\n\n        // we want as much pixels to work with as possible,\n        // this multiplies the minimum image resolution,\n        // so when zooming in it doesn't get too blurry\n        var zoomFactor = root.query('GET_IMAGE_PREVIEW_ZOOM_FACTOR');\n\n        // imaeg scale factor\n        var scaleFactor = zoomFactor * pixelDensityFactor;\n\n        // calculate scaled preview image size\n        var previewImageRatio = height / width;\n\n        // calculate image preview height and width\n        var previewContainerWidth = root.rect.element.width;\n        var previewContainerHeight = root.rect.element.height;\n\n        var imageWidth = previewContainerWidth;\n        var imageHeight = imageWidth * previewImageRatio;\n\n        if (previewImageRatio > 1) {\n          imageWidth = Math.min(width, previewContainerWidth * scaleFactor);\n          imageHeight = imageWidth * previewImageRatio;\n        } else {\n          imageHeight = Math.min(height, previewContainerHeight * scaleFactor);\n          imageWidth = imageHeight / previewImageRatio;\n        }\n\n        // transfer to image tag so no canvas memory wasted on iOS\n        var previewImage = createPreviewImage(\n          imageData,\n          imageWidth,\n          imageHeight,\n          orientation\n        );\n\n        // done\n        var done = function done() {\n          // calculate average image color, disabled for now\n          var averageColor = root.query(\n            'GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR'\n          )\n            ? calculateAverageColor(data)\n            : null;\n          item.setMetadata('color', averageColor, true);\n\n          // data has been transferred to canvas ( if was ImageBitmap )\n          if ('close' in imageData) {\n            imageData.close();\n          }\n\n          // show the overlay\n          root.ref.overlayShadow.opacity = 1;\n\n          // create the first image\n          pushImage({ root: root, props: props, image: previewImage });\n        };\n\n        // apply filter\n        var filter = item.getMetadata('filter');\n        if (filter) {\n          applyFilter(root, filter, previewImage).then(done);\n        } else {\n          done();\n        }\n      };\n\n      // if we support scaling using createImageBitmap we use a worker\n      if (canCreateImageBitmap(item.file)) {\n        // let's scale the image in a worker\n        var worker = createWorker(BitmapWorker);\n\n        worker.post(\n          {\n            file: item.file\n          },\n\n          function(imageBitmap) {\n            // destroy worker\n            worker.terminate();\n\n            // no bitmap returned, must be something wrong,\n            // try the oldschool way\n            if (!imageBitmap) {\n              loadPreviewFallback();\n              return;\n            }\n\n            // yay we got our bitmap, let's continue showing the preview\n            previewImageLoaded(imageBitmap);\n          }\n        );\n      } else {\n        // create fallback preview\n        loadPreviewFallback();\n      }\n    };\n\n    /**\n     * Write handler for when the preview image is ready to be animated\n     */\n    var didDrawPreview = function didDrawPreview(_ref8) {\n      var root = _ref8.root;\n      // get last added image\n      var image = root.ref.images[root.ref.images.length - 1];\n      image.translateY = 0;\n      image.scaleX = 1.0;\n      image.scaleY = 1.0;\n      image.opacity = 1;\n    };\n\n    /**\n     * Write handler for when the preview has been loaded\n     */\n    var restoreOverlay = function restoreOverlay(_ref9) {\n      var root = _ref9.root;\n      root.ref.overlayShadow.opacity = 1;\n      root.ref.overlayError.opacity = 0;\n      root.ref.overlaySuccess.opacity = 0;\n    };\n\n    var didThrowError = function didThrowError(_ref10) {\n      var root = _ref10.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlayError.opacity = 1;\n    };\n\n    var didCompleteProcessing = function didCompleteProcessing(_ref11) {\n      var root = _ref11.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlaySuccess.opacity = 1;\n    };\n\n    /**\n     * Constructor\n     */\n    var create = function create(_ref12) {\n      var root = _ref12.root;\n      // image view\n      root.ref.images = [];\n\n      // the preview image data (we need this to filter the image)\n      root.ref.imageData = null;\n\n      // image bin\n      root.ref.imageViewBin = [];\n\n      // image overlays\n      root.ref.overlayShadow = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'idle'\n        })\n      );\n\n      root.ref.overlaySuccess = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'success'\n        })\n      );\n\n      root.ref.overlayError = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'failure'\n        })\n      );\n    };\n\n    return _.utils.createView({\n      name: 'image-preview-wrapper',\n      create: create,\n      styles: ['height'],\n      apis: ['height'],\n      destroy: function destroy(_ref13) {\n        var root = _ref13.root;\n        // we resize the image so memory on iOS 12 is released more quickly (it seems)\n        root.ref.images.forEach(function(imageView) {\n          imageView.image.width = 1;\n          imageView.image.height = 1;\n        });\n      },\n      didWriteView: function didWriteView(_ref14) {\n        var root = _ref14.root;\n        root.ref.images.forEach(function(imageView) {\n          imageView.dirty = false;\n        });\n      },\n      write: _.utils.createRoute(\n        {\n          // image preview stated\n          DID_IMAGE_PREVIEW_DRAW: didDrawPreview,\n          DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,\n          DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,\n          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,\n\n          // file states\n          DID_THROW_ITEM_LOAD_ERROR: didThrowError,\n          DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,\n          DID_THROW_ITEM_INVALID: didThrowError,\n          DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,\n          DID_START_ITEM_PROCESSING: restoreOverlay,\n          DID_REVERT_ITEM_PROCESSING: restoreOverlay\n        },\n\n        function(_ref15) {\n          var root = _ref15.root;\n          // views on death row\n          var viewsToRemove = root.ref.imageViewBin.filter(function(imageView) {\n            return imageView.opacity === 0;\n          });\n\n          // views to retain\n          root.ref.imageViewBin = root.ref.imageViewBin.filter(function(\n            imageView\n          ) {\n            return imageView.opacity > 0;\n          });\n\n          // remove these views\n          viewsToRemove.forEach(function(imageView) {\n            return removeImageView(root, imageView);\n          });\n          viewsToRemove.length = 0;\n        }\n      )\n    });\n  };\n\n  /**\n   * Image Preview Plugin\n   */\n  var plugin = function plugin(fpAPI) {\n    var addFilter = fpAPI.addFilter,\n      utils = fpAPI.utils;\n    var Type = utils.Type,\n      createRoute = utils.createRoute,\n      isFile = utils.isFile;\n\n    // imagePreviewView\n    var imagePreviewView = createImageWrapperView(fpAPI);\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      // only hook up to item view and only if is enabled for this cropper\n      if (!is('file') || !query('GET_ALLOW_IMAGE_PREVIEW')) return;\n\n      // create the image preview plugin, but only do so if the item is an image\n      var didLoadItem = function didLoadItem(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        var id = props.id;\n        var item = query('GET_ITEM', id);\n\n        // item could theoretically have been removed in the mean time\n        if (!item || !isFile(item.file) || item.archived) return;\n\n        // get the file object\n        var file = item.file;\n\n        // exit if this is not an image\n        if (!isPreviewableImage(file)) return;\n\n        // test if is filtered\n        if (!query('GET_IMAGE_PREVIEW_FILTER_ITEM')(item)) return;\n\n        // exit if image size is too high and no createImageBitmap support\n        // this would simply bring the browser to its knees and that is not what we want\n        var supportsCreateImageBitmap = 'createImageBitmap' in (window || {});\n        var maxPreviewFileSize = query('GET_IMAGE_PREVIEW_MAX_FILE_SIZE');\n        if (\n          !supportsCreateImageBitmap &&\n          maxPreviewFileSize &&\n          file.size > maxPreviewFileSize\n        )\n          return;\n\n        // set preview view\n        root.ref.imagePreview = view.appendChildView(\n          view.createChildView(imagePreviewView, { id: id })\n        );\n\n        // update height if is fixed\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (fixedPreviewHeight) {\n          root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n            id: item.id,\n            height: fixedPreviewHeight\n          });\n        }\n\n        // now ready\n        var queue =\n          !supportsCreateImageBitmap &&\n          file.size > query('GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE');\n        root.dispatch('DID_IMAGE_PREVIEW_CONTAINER_CREATE', { id: id }, queue);\n      };\n\n      var rescaleItem = function rescaleItem(root, props) {\n        if (!root.ref.imagePreview) return;\n        var id = props.id;\n\n        // get item\n        var item = root.query('GET_ITEM', { id: id });\n        if (!item) return;\n\n        // if is fixed height or panel has aspect ratio, exit here, height has already been defined\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var itemPanelAspectRatio = root.query('GET_ITEM_PANEL_ASPECT_RATIO');\n        var fixedHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (panelAspectRatio || itemPanelAspectRatio || fixedHeight) return;\n\n        // no data!\n        var _root$ref = root.ref,\n          imageWidth = _root$ref.imageWidth,\n          imageHeight = _root$ref.imageHeight;\n        if (!imageWidth || !imageHeight) return;\n\n        // get height min and max\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap of orientation is incorrect\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref2 = [imageHeight, imageWidth];\n          imageWidth = _ref2[0];\n          imageHeight = _ref2[1];\n        }\n\n        // scale up width and height when we're dealing with an SVG\n        if (!isBitmap(item.file) || root.query('GET_IMAGE_PREVIEW_UPSCALE')) {\n          var scalar = 2048 / imageWidth;\n          imageWidth *= scalar;\n          imageHeight *= scalar;\n        }\n\n        // image aspect ratio\n        var imageAspectRatio = imageHeight / imageWidth;\n\n        // we need the item to get to the crop size\n        var previewAspectRatio =\n          (item.getMetadata('crop') || {}).aspectRatio || imageAspectRatio;\n\n        // preview height range\n        var previewHeightMax = Math.max(\n          minPreviewHeight,\n          Math.min(imageHeight, maxPreviewHeight)\n        );\n\n        var itemWidth = root.rect.element.width;\n        var previewHeight = Math.min(\n          itemWidth * previewAspectRatio,\n          previewHeightMax\n        );\n\n        // request update to panel height\n        root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n          id: item.id,\n          height: previewHeight\n        });\n      };\n\n      var didResizeView = function didResizeView(_ref3) {\n        var root = _ref3.root;\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n        var root = _ref4.root,\n          action = _ref4.action;\n        if (action.change.key !== 'crop') return;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didCalculatePreviewSize = function didCalculatePreviewSize(_ref5) {\n        var root = _ref5.root,\n          action = _ref5.action;\n        // remember dimensions\n        root.ref.imageWidth = action.width;\n        root.ref.imageHeight = action.height;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n        root.ref.shouldDrawPreview = true;\n\n        // as image load could take a while and fire when draw loop is resting we need to give it a kick\n        root.dispatch('KICK');\n      };\n\n      // start writing\n      view.registerWriter(\n        createRoute(\n          {\n            DID_RESIZE_ROOT: didResizeView,\n            DID_STOP_RESIZE: didResizeView,\n            DID_LOAD_ITEM: didLoadItem,\n            DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,\n            DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata\n          },\n\n          function(_ref6) {\n            var root = _ref6.root,\n              props = _ref6.props;\n            // no preview view attached\n            if (!root.ref.imagePreview) return;\n\n            // don't do anything while hidden\n            if (root.rect.element.hidden) return;\n\n            // resize the item panel\n            if (root.ref.shouldRescale) {\n              rescaleItem(root, props);\n              root.ref.shouldRescale = false;\n            }\n\n            if (root.ref.shouldDrawPreview) {\n              // queue till next frame so we're sure the height has been applied this forces the draw image call inside the wrapper view to use the correct height\n              requestAnimationFrame(function() {\n                // this requestAnimationFrame nesting is horrible but it fixes an issue with 100hz displays on Chrome\n                // https://github.com/pqina/filepond-plugin-image-preview/issues/57\n                requestAnimationFrame(function() {\n                  root.dispatch('DID_FINISH_CALCULATE_PREVIEWSIZE', {\n                    id: props.id\n                  });\n                });\n              });\n\n              root.ref.shouldDrawPreview = false;\n            }\n          }\n        )\n      );\n    });\n\n    // expose plugin\n    return {\n      options: {\n        // Enable or disable image preview\n        allowImagePreview: [true, Type.BOOLEAN],\n\n        // filters file items to determine which are shown as preview\n        imagePreviewFilterItem: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ],\n\n        // Fixed preview height\n        imagePreviewHeight: [null, Type.INT],\n\n        // Min image height\n        imagePreviewMinHeight: [44, Type.INT],\n\n        // Max image height\n        imagePreviewMaxHeight: [256, Type.INT],\n\n        // Max size of preview file for when createImageBitmap is not supported\n        imagePreviewMaxFileSize: [null, Type.INT],\n\n        // The amount of extra pixels added to the image preview to allow comfortable zooming\n        imagePreviewZoomFactor: [2, Type.INT],\n\n        // Should we upscale small images to fit the max bounding box of the preview area\n        imagePreviewUpscale: [false, Type.BOOLEAN],\n\n        // Max size of preview file that we allow to try to instant preview if createImageBitmap is not supported, else image is queued for loading\n        imagePreviewMaxInstantPreviewFileSize: [1000000, Type.INT],\n\n        // Style of the transparancy indicator used behind images\n        imagePreviewTransparencyIndicator: [null, Type.STRING],\n\n        // Enables or disables reading average image color\n        imagePreviewCalculateAverageImageColor: [false, Type.BOOLEAN],\n\n        // Enables or disables the previewing of markup\n        imagePreviewMarkupShow: [true, Type.BOOLEAN],\n\n        // Allows filtering of markup to only show certain shapes\n        imagePreviewMarkupFilter: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FHZ0Q7QUFDdEQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLHlCQUF5QjtBQUNyRCxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLCtDQUErQztBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxRQUFRO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5qcz8yY2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXcgNC42LjEwXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyAobW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksXG4gICAgICAoZ2xvYmFsLkZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3ID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHRlc3QgaWYgZmlsZSBpcyBvZiB0eXBlIGltYWdlIGFuZCBjYW4gYmUgdmlld2VkIGluIGNhbnZhc1xuICB2YXIgaXNQcmV2aWV3YWJsZUltYWdlID0gZnVuY3Rpb24gaXNQcmV2aWV3YWJsZUltYWdlKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZS8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgU3ltYm9sLmZvciAmJlxuICAgICAgICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgMHhlYWM3O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICByZWY6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBfb3duZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvcikge1xuICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgIGlmIChtZXRob2QgIT0gbnVsbCkgcmV0dXJuIG1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLndyYXBwZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bc3luY0dlbmVyYXRvcihnZW4pIHtcbiAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFyZzogYXJnLFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHZhciB3cmFwcGVkQXdhaXQgPSB2YWx1ZSBpbnN0YW5jZW9mIF9Bd2FpdFZhbHVlO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgaWYgKHdyYXBwZWRBd2FpdCkge1xuICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRsZShyZXN1bHQuZG9uZSA/ICdyZXR1cm4nIDogJ25vcm1hbCcsIGFyZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJlc3VtZSgndGhyb3cnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR0bGUodHlwZSwgdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICBmcm9udC5yZWplY3QodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgIGlmIChmcm9udCkge1xuICAgICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgIGlmICh0eXBlb2YgZ2VuLnJldHVybiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5yZXR1cm4gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ25leHQnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gIH07XG5cbiAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCdyZXR1cm4nLCBhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IF9Bc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Bd2FpdFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlKGlubmVyLCBhd2FpdFdyYXApIHtcbiAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gcHVtcChrZXksIHZhbHVlKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBhd2FpdFdyYXAodmFsdWUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgaXRlcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpdGVyLnRocm93ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHVtcCgndGhyb3cnLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwdW1wKCdyZXR1cm4nLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChcbiAgICAgICAgICAgIGdlbixcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgICBfbmV4dCxcbiAgICAgICAgICAgIF90aHJvdyxcbiAgICAgICAgICAgICduZXh0JyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICd0aHJvdycsIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRlc2NzKSB7XG4gICAgICB2YXIgZGVzYyA9IGRlc2NzW2tleV07XG4gICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzYyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ltID0gb2JqZWN0U3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1tzeW1dO1xuICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmICgndmFsdWUnIGluIGRlc2MpIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW0sIGRlc2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPVxuICAgICAgT2JqZWN0LmFzc2lnbiB8fFxuICAgICAgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChcbiAgICAgIHJpZ2h0ICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgID8gb2JqXG4gICAgICA6IHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHxcbiAgICAgIF9ub25JdGVyYWJsZVJlc3QoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9uID0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7XG5cbiAgICApIHtcbiAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpdC5uZXh0KCk7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyXG4gICAgICAgID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpXG4gICAgICAgIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKFxuICAgIHRhcmdldCxcbiAgICBwcm9wZXJ0eSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY29udGV4dFxuICApIHtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgfSk7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgIH0sIGRlc2MpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgZGVzYyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cblxuICB2YXIgaWQgPSAwO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgfVxuXG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY0dldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3JcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdmFsdWVcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICBpZiAocmVjZWl2ZXIgIT09IGNsYXNzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUgc3RhdGljIGFjY2VzcyBvZiB3cm9uZyBwcm92ZW5hbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICB2YXIgYXBpID0gX2dldERlY29yYXRvcnNBcGkoKTtcblxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFwaSA9IG1peGluc1tpXShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIH0sIHN1cGVyQ2xhc3MpO1xuICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgIGRlY29yYXRvcnNcbiAgICApO1xuICAgIGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gRi5wcm90b3R5cGU7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWxlbWVudC5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSAnc3RhdGljJyA/IEYgOiBwcm90bztcbiAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50RmluaXNoZXJzRXh0cmFzLmVsZW1lbnQpO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpO1xuICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudC5rZXkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpID49IDA7XG4gICAgICAgICAgaS0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcyhcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhcztcblxuICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChuZXdFeHRyYXNbal0sIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50c1tqXS5rZXkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGVsZW1lbnQucGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvclxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdmaW5pc2hlcicsXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdleHRyYXMnLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgK1xuICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAncHJvdG90eXBlJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ293bidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgK1xuICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAnZWxlbWVudHMnLFxuICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJ0EgbWV0aG9kIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdzZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgZXh0cmFzOiBleHRyYXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArXG4gICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZGVzY3JpcHRvcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnN0cnVjdG9yID0gKDAsIGZpbmlzaGVyc1tpXSkoY29uc3RydWN0b3IpO1xuXG4gICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfSxcbiAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgb2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgJyBwcm9wZXJ0eS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IGRlZi52YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnc2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAga2V5OiBrZXksXG4gICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWNcbiAgICAgICAgPyAnc3RhdGljJ1xuICAgICAgICA6IGRlZi5raW5kID09PSAnZmllbGQnXG4gICAgICAgID8gJ293bidcbiAgICAgICAgOiAncHJvdG90eXBlJyxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgaWYgKGRlZi5raW5kID09PSAnZmllbGQnKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgb3RoZXIua2V5ID09PSBlbGVtZW50LmtleSAmJlxuICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICApO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG90aGVyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgbWV0aG9kcyAoJyArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICAgIHJldHVybiAoXG4gICAgICBkZXNjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbihyZSwgZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbmV3IEJhYmVsUmVnRXhwKHJlLCBncm91cHMpO1xuICAgIH07XG5cbiAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgIHZhciBfc3VwZXIgPSBSZWdFeHAucHJvdG90eXBlO1xuXG4gICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IF9ncm91cHMuZ2V0KHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWxkR3JvdXBzKGFyZ3MsIF90aGlzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIHZlY3Rvck11bHRpcGx5ID0gZnVuY3Rpb24gdmVjdG9yTXVsdGlwbHkodiwgYW1vdW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3Rvcih2LnggKiBhbW91bnQsIHYueSAqIGFtb3VudCk7XG4gIH07XG5cbiAgdmFyIHZlY3RvckFkZCA9IGZ1bmN0aW9uIHZlY3RvckFkZChhLCBiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3RvcihhLnggKyBiLngsIGEueSArIGIueSk7XG4gIH07XG5cbiAgdmFyIHZlY3Rvck5vcm1hbGl6ZSA9IGZ1bmN0aW9uIHZlY3Rvck5vcm1hbGl6ZSh2KSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQodi54ICogdi54ICsgdi55ICogdi55KTtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3Rvcih2LnggLyBsLCB2LnkgLyBsKTtcbiAgfTtcblxuICB2YXIgdmVjdG9yUm90YXRlID0gZnVuY3Rpb24gdmVjdG9yUm90YXRlKHYsIHJhZGlhbnMsIG9yaWdpbikge1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgdmFyIHQgPSBjcmVhdGVWZWN0b3Iodi54IC0gb3JpZ2luLngsIHYueSAtIG9yaWdpbi55KTtcbiAgICByZXR1cm4gY3JlYXRlVmVjdG9yKFxuICAgICAgb3JpZ2luLnggKyBjb3MgKiB0LnggLSBzaW4gKiB0LnksXG4gICAgICBvcmlnaW4ueSArIHNpbiAqIHQueCArIGNvcyAqIHQueVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVZlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVZlY3RvcigpIHtcbiAgICB2YXIgeCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwVmFsdWUgPSBmdW5jdGlvbiBnZXRNYXJrdXBWYWx1ZSh2YWx1ZSwgc2l6ZSkge1xuICAgIHZhciBzY2FsYXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciBheGlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAqIHNjYWxhcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAqIChheGlzID8gc2l6ZVtheGlzXSA6IE1hdGgubWluKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwU3R5bGVzID0gZnVuY3Rpb24gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICB2YXIgbGluZVN0eWxlID0gbWFya3VwLmJvcmRlclN0eWxlIHx8IG1hcmt1cC5saW5lU3R5bGUgfHwgJ3NvbGlkJztcbiAgICB2YXIgZmlsbCA9IG1hcmt1cC5iYWNrZ3JvdW5kQ29sb3IgfHwgbWFya3VwLmZvbnRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBzdHJva2UgPSBtYXJrdXAuYm9yZGVyQ29sb3IgfHwgbWFya3VwLmxpbmVDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBzdHJva2VXaWR0aCA9IGdldE1hcmt1cFZhbHVlKFxuICAgICAgbWFya3VwLmJvcmRlcldpZHRoIHx8IG1hcmt1cC5saW5lV2lkdGgsXG4gICAgICBzaXplLFxuICAgICAgc2NhbGVcbiAgICApO1xuICAgIHZhciBsaW5lQ2FwID0gbWFya3VwLmxpbmVDYXAgfHwgJ3JvdW5kJztcbiAgICB2YXIgbGluZUpvaW4gPSBtYXJrdXAubGluZUpvaW4gfHwgJ3JvdW5kJztcbiAgICB2YXIgZGFzaGVzID1cbiAgICAgIHR5cGVvZiBsaW5lU3R5bGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gJydcbiAgICAgICAgOiBsaW5lU3R5bGVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFya3VwVmFsdWUodiwgc2l6ZSwgc2NhbGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgdmFyIG9wYWNpdHkgPSBtYXJrdXAub3BhY2l0eSB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnOiBsaW5lQ2FwLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbic6IGxpbmVKb2luLFxuICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDAsXG4gICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGRhc2hlcyxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgZmlsbDogZmlsbCxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9O1xuXG4gIHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwUmVjdCA9IGZ1bmN0aW9uIGdldE1hcmt1cFJlY3QocmVjdCwgc2l6ZSkge1xuICAgIHZhciBzY2FsYXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gICAgdmFyIGxlZnQgPVxuICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC54LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpIHx8XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LmxlZnQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgdmFyIHRvcCA9XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LnksIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpIHx8XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LnRvcCwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG4gICAgdmFyIHdpZHRoID0gZ2V0TWFya3VwVmFsdWUocmVjdC53aWR0aCwgc2l6ZSwgc2NhbGFyLCAnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gZ2V0TWFya3VwVmFsdWUocmVjdC5oZWlnaHQsIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuICAgIHZhciByaWdodCA9IGdldE1hcmt1cFZhbHVlKHJlY3QucmlnaHQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgdmFyIGJvdHRvbSA9IGdldE1hcmt1cFZhbHVlKHJlY3QuYm90dG9tLCBzaXplLCBzY2FsYXIsICdoZWlnaHQnKTtcblxuICAgIGlmICghaXNEZWZpbmVkKHRvcCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICB0b3AgPSBzaXplLmhlaWdodCAtIGhlaWdodCAtIGJvdHRvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9IGJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChsZWZ0KSkge1xuICAgICAgaWYgKGlzRGVmaW5lZCh3aWR0aCkgJiYgaXNEZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgICBsZWZ0ID0gc2l6ZS53aWR0aCAtIHdpZHRoIC0gcmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0RlZmluZWQod2lkdGgpKSB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGxlZnQpICYmIGlzRGVmaW5lZChyaWdodCkpIHtcbiAgICAgICAgd2lkdGggPSBzaXplLndpZHRoIC0gbGVmdCAtIHJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQodG9wKSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodCAtIHRvcCAtIGJvdHRvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxlZnQgfHwgMCxcbiAgICAgIHk6IHRvcCB8fCAwLFxuICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwXG4gICAgfTtcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9QYXRoU2hhcGUgPSBmdW5jdGlvbiBwb2ludHNUb1BhdGhTaGFwZShwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzXG4gICAgICAubWFwKGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAuY29uY2F0KGluZGV4ID09PSAwID8gJ00nIDogJ0wnLCAnICcpXG4gICAgICAgICAgLmNvbmNhdChwb2ludC54LCAnICcpXG4gICAgICAgICAgLmNvbmNhdChwb2ludC55KTtcbiAgICAgIH0pXG4gICAgICAuam9pbignICcpO1xuICB9O1xuXG4gIHZhciBzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyW2tleV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBzdmcgPSBmdW5jdGlvbiBzdmcodGFnLCBhdHRyKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZyk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cik7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuXG4gIHZhciB1cGRhdGVSZWN0ID0gZnVuY3Rpb24gdXBkYXRlUmVjdChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcylcbiAgICApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVFbGxpcHNlID0gZnVuY3Rpb24gdXBkYXRlRWxsaXBzZShlbGVtZW50KSB7XG4gICAgdmFyIGN4ID0gZWxlbWVudC5yZWN0LnggKyBlbGVtZW50LnJlY3Qud2lkdGggKiAwLjU7XG4gICAgdmFyIGN5ID0gZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICAgIHZhciByeCA9IGVsZW1lbnQucmVjdC53aWR0aCAqIDAuNTtcbiAgICB2YXIgcnkgPSBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICByeTogcnlcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudC5zdHlsZXNcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHZhciBJTUFHRV9GSVRfU1RZTEUgPSB7XG4gICAgY29udGFpbjogJ3hNaWRZTWlkIG1lZXQnLFxuICAgIGNvdmVyOiAneE1pZFlNaWQgc2xpY2UnXG4gIH07XG5cbiAgdmFyIHVwZGF0ZUltYWdlID0gZnVuY3Rpb24gdXBkYXRlSW1hZ2UoZWxlbWVudCwgbWFya3VwKSB7XG4gICAgc2V0QXR0cmlidXRlcyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50LnJlY3QsIGVsZW1lbnQuc3R5bGVzLCB7XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IElNQUdFX0ZJVF9TVFlMRVttYXJrdXAuZml0XSB8fCAnbm9uZSdcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgVEVYVF9BTkNIT1IgPSB7XG4gICAgbGVmdDogJ3N0YXJ0JyxcbiAgICBjZW50ZXI6ICdtaWRkbGUnLFxuICAgIHJpZ2h0OiAnZW5kJ1xuICB9O1xuXG4gIHZhciB1cGRhdGVUZXh0ID0gZnVuY3Rpb24gdXBkYXRlVGV4dChlbGVtZW50LCBtYXJrdXAsIHNpemUsIHNjYWxlKSB7XG4gICAgdmFyIGZvbnRTaXplID0gZ2V0TWFya3VwVmFsdWUobWFya3VwLmZvbnRTaXplLCBzaXplLCBzY2FsZSk7XG4gICAgdmFyIGZvbnRGYW1pbHkgPSBtYXJrdXAuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7XG4gICAgdmFyIGZvbnRXZWlnaHQgPSBtYXJrdXAuZm9udFdlaWdodCB8fCAnbm9ybWFsJztcbiAgICB2YXIgdGV4dEFsaWduID0gVEVYVF9BTkNIT1JbbWFya3VwLnRleHRBbGlnbl0gfHwgJ3N0YXJ0JztcblxuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAnZm9udC1mYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgICAndGV4dC1hbmNob3InOiB0ZXh0QWxpZ25cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIHVwZGF0ZSB0ZXh0XG4gICAgaWYgKGVsZW1lbnQudGV4dCAhPT0gbWFya3VwLnRleHQpIHtcbiAgICAgIGVsZW1lbnQudGV4dCA9IG1hcmt1cC50ZXh0O1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IG1hcmt1cC50ZXh0Lmxlbmd0aCA/IG1hcmt1cC50ZXh0IDogJyAnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlTGluZSA9IGZ1bmN0aW9uIHVwZGF0ZUxpbmUoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHZhciBsaW5lID0gZWxlbWVudC5jaGlsZE5vZGVzWzBdO1xuICAgIHZhciBiZWdpbiA9IGVsZW1lbnQuY2hpbGROb2Rlc1sxXTtcbiAgICB2YXIgZW5kID0gZWxlbWVudC5jaGlsZE5vZGVzWzJdO1xuXG4gICAgdmFyIG9yaWdpbiA9IGVsZW1lbnQucmVjdDtcblxuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICB4OiBlbGVtZW50LnJlY3QueCArIGVsZW1lbnQucmVjdC53aWR0aCxcbiAgICAgIHk6IGVsZW1lbnQucmVjdC55ICsgZWxlbWVudC5yZWN0LmhlaWdodFxuICAgIH07XG5cbiAgICBzZXRBdHRyaWJ1dGVzKGxpbmUsIHtcbiAgICAgIHgxOiBvcmlnaW4ueCxcbiAgICAgIHkxOiBvcmlnaW4ueSxcbiAgICAgIHgyOiB0YXJnZXQueCxcbiAgICAgIHkyOiB0YXJnZXQueVxuICAgIH0pO1xuXG4gICAgaWYgKCFtYXJrdXAubGluZURlY29yYXRpb24pIHJldHVybjtcblxuICAgIGJlZ2luLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZW5kLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB2YXIgdiA9IHZlY3Rvck5vcm1hbGl6ZSh7XG4gICAgICB4OiB0YXJnZXQueCAtIG9yaWdpbi54LFxuICAgICAgeTogdGFyZ2V0LnkgLSBvcmlnaW4ueVxuICAgIH0pO1xuXG4gICAgdmFyIGwgPSBnZXRNYXJrdXBWYWx1ZSgwLjA1LCBzaXplLCBzY2FsZSk7XG5cbiAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWJlZ2luJykgIT09IC0xKSB7XG4gICAgICB2YXIgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCBsKTtcbiAgICAgIHZhciBhcnJvd0JlZ2luQ2VudGVyID0gdmVjdG9yQWRkKG9yaWdpbiwgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQpO1xuICAgICAgdmFyIGFycm93QmVnaW5BID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgMiwgYXJyb3dCZWdpbkNlbnRlcik7XG4gICAgICB2YXIgYXJyb3dCZWdpbkIgPSB2ZWN0b3JSb3RhdGUob3JpZ2luLCAtMiwgYXJyb3dCZWdpbkNlbnRlcik7XG5cbiAgICAgIHNldEF0dHJpYnV0ZXMoYmVnaW4sIHtcbiAgICAgICAgc3R5bGU6ICdkaXNwbGF5OmJsb2NrOycsXG4gICAgICAgIGQ6ICdNJ1xuICAgICAgICAgIC5jb25jYXQoYXJyb3dCZWdpbkEueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQoYXJyb3dCZWdpbkEueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KG9yaWdpbi54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChvcmlnaW4ueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5CLngsICcsJylcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5CLnkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWVuZCcpICE9PSAtMSkge1xuICAgICAgdmFyIGFycm93RW5kUm90YXRpb25Qb2ludCA9IHZlY3Rvck11bHRpcGx5KHYsIC1sKTtcbiAgICAgIHZhciBhcnJvd0VuZENlbnRlciA9IHZlY3RvckFkZCh0YXJnZXQsIGFycm93RW5kUm90YXRpb25Qb2ludCk7XG4gICAgICB2YXIgYXJyb3dFbmRBID0gdmVjdG9yUm90YXRlKHRhcmdldCwgMiwgYXJyb3dFbmRDZW50ZXIpO1xuICAgICAgdmFyIGFycm93RW5kQiA9IHZlY3RvclJvdGF0ZSh0YXJnZXQsIC0yLCBhcnJvd0VuZENlbnRlcik7XG5cbiAgICAgIHNldEF0dHJpYnV0ZXMoZW5kLCB7XG4gICAgICAgIHN0eWxlOiAnZGlzcGxheTpibG9jazsnLFxuICAgICAgICBkOiAnTSdcbiAgICAgICAgICAuY29uY2F0KGFycm93RW5kQS54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEEueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KHRhcmdldC54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdCh0YXJnZXQueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KGFycm93RW5kQi54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEIueSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlUGF0aCA9IGZ1bmN0aW9uIHVwZGF0ZVBhdGgoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5zdHlsZXMsIHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICBkOiBwb2ludHNUb1BhdGhTaGFwZShcbiAgICAgICAgICBtYXJrdXAucG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogZ2V0TWFya3VwVmFsdWUocG9pbnQueCwgc2l6ZSwgc2NhbGUsICd3aWR0aCcpLFxuICAgICAgICAgICAgICB5OiBnZXRNYXJrdXBWYWx1ZShwb2ludC55LCBzaXplLCBzY2FsZSwgJ2hlaWdodCcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiBjcmVhdGVTaGFwZShub2RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1hcmt1cCkge1xuICAgICAgcmV0dXJuIHN2Zyhub2RlLCB7IGlkOiBtYXJrdXAuaWQgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZShtYXJrdXApIHtcbiAgICB2YXIgc2hhcGUgPSBzdmcoJ2ltYWdlJywge1xuICAgICAgaWQ6IG1hcmt1cC5pZCxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJyxcbiAgICAgIG9wYWNpdHk6ICcwJ1xuICAgIH0pO1xuXG4gICAgc2hhcGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCBtYXJrdXAub3BhY2l0eSB8fCAxKTtcbiAgICB9O1xuICAgIHNoYXBlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgJ3hsaW5rOmhyZWYnLFxuICAgICAgbWFya3VwLnNyY1xuICAgICk7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHZhciBjcmVhdGVMaW5lID0gZnVuY3Rpb24gY3JlYXRlTGluZShtYXJrdXApIHtcbiAgICB2YXIgc2hhcGUgPSBzdmcoJ2cnLCB7XG4gICAgICBpZDogbWFya3VwLmlkLFxuICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnXG4gICAgfSk7XG5cbiAgICB2YXIgbGluZSA9IHN2ZygnbGluZScpO1xuICAgIHNoYXBlLmFwcGVuZENoaWxkKGxpbmUpO1xuXG4gICAgdmFyIGJlZ2luID0gc3ZnKCdwYXRoJyk7XG4gICAgc2hhcGUuYXBwZW5kQ2hpbGQoYmVnaW4pO1xuXG4gICAgdmFyIGVuZCA9IHN2ZygncGF0aCcpO1xuICAgIHNoYXBlLmFwcGVuZENoaWxkKGVuZCk7XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgdmFyIENSRUFURV9UWVBFX1JPVVRFUyA9IHtcbiAgICBpbWFnZTogY3JlYXRlSW1hZ2UsXG4gICAgcmVjdDogY3JlYXRlU2hhcGUoJ3JlY3QnKSxcbiAgICBlbGxpcHNlOiBjcmVhdGVTaGFwZSgnZWxsaXBzZScpLFxuICAgIHRleHQ6IGNyZWF0ZVNoYXBlKCd0ZXh0JyksXG4gICAgcGF0aDogY3JlYXRlU2hhcGUoJ3BhdGgnKSxcbiAgICBsaW5lOiBjcmVhdGVMaW5lXG4gIH07XG5cbiAgdmFyIFVQREFURV9UWVBFX1JPVVRFUyA9IHtcbiAgICByZWN0OiB1cGRhdGVSZWN0LFxuICAgIGVsbGlwc2U6IHVwZGF0ZUVsbGlwc2UsXG4gICAgaW1hZ2U6IHVwZGF0ZUltYWdlLFxuICAgIHRleHQ6IHVwZGF0ZVRleHQsXG4gICAgcGF0aDogdXBkYXRlUGF0aCxcbiAgICBsaW5lOiB1cGRhdGVMaW5lXG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1hcmt1cEJ5VHlwZSA9IGZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEJ5VHlwZSh0eXBlLCBtYXJrdXApIHtcbiAgICByZXR1cm4gQ1JFQVRFX1RZUEVfUk9VVEVTW3R5cGVdKG1hcmt1cCk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZU1hcmt1cEJ5VHlwZSA9IGZ1bmN0aW9uIHVwZGF0ZU1hcmt1cEJ5VHlwZShcbiAgICBlbGVtZW50LFxuICAgIHR5cGUsXG4gICAgbWFya3VwLFxuICAgIHNpemUsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgaWYgKHR5cGUgIT09ICdwYXRoJykge1xuICAgICAgZWxlbWVudC5yZWN0ID0gZ2V0TWFya3VwUmVjdChtYXJrdXAsIHNpemUsIHNjYWxlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZXMgPSBnZXRNYXJrdXBTdHlsZXMobWFya3VwLCBzaXplLCBzY2FsZSk7XG4gICAgVVBEQVRFX1RZUEVfUk9VVEVTW3R5cGVdKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xuICB9O1xuXG4gIHZhciBNQVJLVVBfUkVDVCA9IFtcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICdsZWZ0JyxcbiAgICAndG9wJyxcbiAgICAncmlnaHQnLFxuICAgICdib3R0b20nLFxuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCdcbiAgXTtcblxuICB2YXIgdG9PcHRpb25hbEZyYWN0aW9uID0gZnVuY3Rpb24gdG9PcHRpb25hbEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgLyUvLnRlc3QodmFsdWUpXG4gICAgICA/IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgICA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIGFkZHMgZGVmYXVsdCBtYXJrdXAgcHJvcGVydGllcywgY2xvbmVzIG1hcmt1cFxuICB2YXIgcHJlcGFyZU1hcmt1cCA9IGZ1bmN0aW9uIHByZXBhcmVNYXJrdXAobWFya3VwKSB7XG4gICAgdmFyIF9tYXJrdXAgPSBfc2xpY2VkVG9BcnJheShtYXJrdXAsIDIpLFxuICAgICAgdHlwZSA9IF9tYXJrdXBbMF0sXG4gICAgICBwcm9wcyA9IF9tYXJrdXBbMV07XG5cbiAgICB2YXIgcmVjdCA9IHByb3BzLnBvaW50c1xuICAgICAgPyB7fVxuICAgICAgOiBNQVJLVVBfUkVDVC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICAgIHByZXZbY3Vycl0gPSB0b09wdGlvbmFsRnJhY3Rpb24ocHJvcHNbY3Vycl0pO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICB6SW5kZXg6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlY3RcbiAgICAgIClcbiAgICBdO1xuICB9O1xuXG4gIHZhciBzb3J0TWFya3VwQnlaSW5kZXggPSBmdW5jdGlvbiBzb3J0TWFya3VwQnlaSW5kZXgoYSwgYikge1xuICAgIGlmIChhWzFdLnpJbmRleCA+IGJbMV0uekluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGFbMV0uekluZGV4IDwgYlsxXS56SW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1hcmt1cFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVNYXJrdXBWaWV3KF8pIHtcbiAgICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3LW1hcmt1cCcsXG4gICAgICB0YWc6ICdzdmcnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdjcm9wJywgJ21hcmt1cCcsICdyZXNpemUnLCAnZGlydHknXVxuICAgICAgfSxcblxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIGlmICghcHJvcHMuZGlydHkpIHJldHVybjtcbiAgICAgICAgdmFyIGNyb3AgPSBwcm9wcy5jcm9wLFxuICAgICAgICAgIHJlc2l6ZSA9IHByb3BzLnJlc2l6ZSxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXA7XG5cbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHByb3BzLndpZHRoO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9IHByb3BzLmhlaWdodDtcblxuICAgICAgICB2YXIgY3JvcFdpZHRoID0gY3JvcC53aWR0aDtcbiAgICAgICAgdmFyIGNyb3BIZWlnaHQgPSBjcm9wLmhlaWdodDtcblxuICAgICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgICAgdmFyIF9zaXplID0gcmVzaXplLnNpemU7XG5cbiAgICAgICAgICB2YXIgb3V0cHV0V2lkdGggPSBfc2l6ZSAmJiBfc2l6ZS53aWR0aDtcbiAgICAgICAgICB2YXIgb3V0cHV0SGVpZ2h0ID0gX3NpemUgJiYgX3NpemUuaGVpZ2h0O1xuICAgICAgICAgIHZhciBvdXRwdXRGaXQgPSByZXNpemUubW9kZTtcbiAgICAgICAgICB2YXIgb3V0cHV0VXBzY2FsZSA9IHJlc2l6ZS51cHNjYWxlO1xuXG4gICAgICAgICAgaWYgKG91dHB1dFdpZHRoICYmICFvdXRwdXRIZWlnaHQpIG91dHB1dEhlaWdodCA9IG91dHB1dFdpZHRoO1xuICAgICAgICAgIGlmIChvdXRwdXRIZWlnaHQgJiYgIW91dHB1dFdpZHRoKSBvdXRwdXRXaWR0aCA9IG91dHB1dEhlaWdodDtcblxuICAgICAgICAgIHZhciBzaG91bGRVcHNjYWxlID1cbiAgICAgICAgICAgIGNyb3BXaWR0aCA8IG91dHB1dFdpZHRoICYmIGNyb3BIZWlnaHQgPCBvdXRwdXRIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoIXNob3VsZFVwc2NhbGUgfHwgKHNob3VsZFVwc2NhbGUgJiYgb3V0cHV0VXBzY2FsZSkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsYXJXaWR0aCA9IG91dHB1dFdpZHRoIC8gY3JvcFdpZHRoO1xuICAgICAgICAgICAgdmFyIHNjYWxhckhlaWdodCA9IG91dHB1dEhlaWdodCAvIGNyb3BIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXRGaXQgPT09ICdmb3JjZScpIHtcbiAgICAgICAgICAgICAgY3JvcFdpZHRoID0gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBvdXRwdXRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2NhbGFyO1xuICAgICAgICAgICAgICBpZiAob3V0cHV0Rml0ID09PSAnY292ZXInKSB7XG4gICAgICAgICAgICAgICAgc2NhbGFyID0gTWF0aC5tYXgoc2NhbGFyV2lkdGgsIHNjYWxhckhlaWdodCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0Rml0ID09PSAnY29udGFpbicpIHtcbiAgICAgICAgICAgICAgICBzY2FsYXIgPSBNYXRoLm1pbihzY2FsYXJXaWR0aCwgc2NhbGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjcm9wV2lkdGggPSBjcm9wV2lkdGggKiBzY2FsYXI7XG4gICAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBjcm9wSGVpZ2h0ICogc2NhbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgIHdpZHRoOiB2aWV3V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWV3SGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLndpZHRoKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHZpZXdXaWR0aCAvIGNyb3BXaWR0aCwgdmlld0hlaWdodCAvIGNyb3BIZWlnaHQpO1xuXG4gICAgICAgIC8vIGNsZWFyXG4gICAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAvLyBnZXQgZmlsdGVyXG4gICAgICAgIHZhciBtYXJrdXBGaWx0ZXIgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVJLVVBfRklMVEVSJyk7XG5cbiAgICAgICAgLy8gZHJhdyBuZXdcbiAgICAgICAgbWFya3VwXG4gICAgICAgICAgLmZpbHRlcihtYXJrdXBGaWx0ZXIpXG4gICAgICAgICAgLm1hcChwcmVwYXJlTWFya3VwKVxuICAgICAgICAgIC5zb3J0KHNvcnRNYXJrdXBCeVpJbmRleClcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBfbWFya3VwID0gX3NsaWNlZFRvQXJyYXkobWFya3VwLCAyKSxcbiAgICAgICAgICAgICAgdHlwZSA9IF9tYXJrdXBbMF0sXG4gICAgICAgICAgICAgIHNldHRpbmdzID0gX21hcmt1cFsxXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZU1hcmt1cEJ5VHlwZSh0eXBlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICAgICAgdXBkYXRlTWFya3VwQnlUeXBlKGVsZW1lbnQsIHR5cGUsIHNldHRpbmdzLCBzaXplLCBzY2FsZSk7XG5cbiAgICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVWZWN0b3IkMSA9IGZ1bmN0aW9uIGNyZWF0ZVZlY3Rvcih4LCB5KSB7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICB9O1xuXG4gIHZhciB2ZWN0b3JEb3QgPSBmdW5jdGlvbiB2ZWN0b3JEb3QoYSwgYikge1xuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG4gIH07XG5cbiAgdmFyIHZlY3RvclN1YnRyYWN0ID0gZnVuY3Rpb24gdmVjdG9yU3VidHJhY3QoYSwgYikge1xuICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMShhLnggLSBiLngsIGEueSAtIGIueSk7XG4gIH07XG5cbiAgdmFyIHZlY3RvckRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uIHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XG4gICAgcmV0dXJuIHZlY3RvckRvdCh2ZWN0b3JTdWJ0cmFjdChhLCBiKSwgdmVjdG9yU3VidHJhY3QoYSwgYikpO1xuICB9O1xuXG4gIHZhciB2ZWN0b3JEaXN0YW5jZSA9IGZ1bmN0aW9uIHZlY3RvckRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSk7XG4gIH07XG5cbiAgdmFyIGdldE9mZnNldFBvaW50T25FZGdlID0gZnVuY3Rpb24gZ2V0T2Zmc2V0UG9pbnRPbkVkZ2UobGVuZ3RoLCByb3RhdGlvbikge1xuICAgIHZhciBhID0gbGVuZ3RoO1xuXG4gICAgdmFyIEEgPSAxLjU3MDc5NjMyNjc5NDg5NjY7XG4gICAgdmFyIEIgPSByb3RhdGlvbjtcbiAgICB2YXIgQyA9IDEuNTcwNzk2MzI2Nzk0ODk2NiAtIHJvdGF0aW9uO1xuXG4gICAgdmFyIHNpbkEgPSBNYXRoLnNpbihBKTtcbiAgICB2YXIgc2luQiA9IE1hdGguc2luKEIpO1xuICAgIHZhciBzaW5DID0gTWF0aC5zaW4oQyk7XG4gICAgdmFyIGNvc0MgPSBNYXRoLmNvcyhDKTtcbiAgICB2YXIgcmF0aW8gPSBhIC8gc2luQTtcbiAgICB2YXIgYiA9IHJhdGlvICogc2luQjtcbiAgICB2YXIgYyA9IHJhdGlvICogc2luQztcblxuICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMShjb3NDICogYiwgY29zQyAqIGMpO1xuICB9O1xuXG4gIHZhciBnZXRSb3RhdGVkUmVjdFNpemUgPSBmdW5jdGlvbiBnZXRSb3RhdGVkUmVjdFNpemUocmVjdCwgcm90YXRpb24pIHtcbiAgICB2YXIgdyA9IHJlY3Qud2lkdGg7XG4gICAgdmFyIGggPSByZWN0LmhlaWdodDtcblxuICAgIHZhciBob3IgPSBnZXRPZmZzZXRQb2ludE9uRWRnZSh3LCByb3RhdGlvbik7XG4gICAgdmFyIHZlciA9IGdldE9mZnNldFBvaW50T25FZGdlKGgsIHJvdGF0aW9uKTtcblxuICAgIHZhciB0bCA9IGNyZWF0ZVZlY3RvciQxKHJlY3QueCArIE1hdGguYWJzKGhvci54KSwgcmVjdC55IC0gTWF0aC5hYnMoaG9yLnkpKTtcblxuICAgIHZhciB0ciA9IGNyZWF0ZVZlY3RvciQxKFxuICAgICAgcmVjdC54ICsgcmVjdC53aWR0aCArIE1hdGguYWJzKHZlci55KSxcbiAgICAgIHJlY3QueSArIE1hdGguYWJzKHZlci54KVxuICAgICk7XG5cbiAgICB2YXIgYmwgPSBjcmVhdGVWZWN0b3IkMShcbiAgICAgIHJlY3QueCAtIE1hdGguYWJzKHZlci55KSxcbiAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gTWF0aC5hYnModmVyLngpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdmVjdG9yRGlzdGFuY2UodGwsIHRyKSxcbiAgICAgIGhlaWdodDogdmVjdG9yRGlzdGFuY2UodGwsIGJsKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUNhbnZhc1NpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVDYW52YXNTaXplKFxuICAgIGltYWdlLFxuICAgIGNhbnZhc0FzcGVjdFJhdGlvXG4gICkge1xuICAgIHZhciB6b29tID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAvLyBkZXRlcm1pbmUgYWN0dWFsIHBpeGVscyBvbiB4IGFuZCB5IGF4aXNcbiAgICB2YXIgY2FudmFzV2lkdGggPSAxO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBjYW52YXNBc3BlY3RSYXRpbztcbiAgICB2YXIgaW1nV2lkdGggPSAxO1xuICAgIHZhciBpbWdIZWlnaHQgPSBpbWFnZUFzcGVjdFJhdGlvO1xuICAgIGlmIChpbWdIZWlnaHQgPiBjYW52YXNIZWlnaHQpIHtcbiAgICAgIGltZ0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIGltZ1dpZHRoID0gaW1nSGVpZ2h0IC8gaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgc2NhbGFyID0gTWF0aC5tYXgoY2FudmFzV2lkdGggLyBpbWdXaWR0aCwgY2FudmFzSGVpZ2h0IC8gaW1nSGVpZ2h0KTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCAvICh6b29tICogc2NhbGFyICogaW1nV2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSB3aWR0aCAqIGNhbnZhc0FzcGVjdFJhdGlvO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0SW1hZ2VSZWN0Wm9vbUZhY3RvciA9IGZ1bmN0aW9uIGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgaW1hZ2VSZWN0LFxuICAgIGNyb3BSZWN0LFxuICAgIHJvdGF0aW9uLFxuICAgIGNlbnRlclxuICApIHtcbiAgICAvLyBjYWxjdWxhdGUgYXZhaWxhYmxlIHNwYWNlIHJvdW5kIGltYWdlIGNlbnRlciBwb3NpdGlvblxuICAgIHZhciBjeCA9IGNlbnRlci54ID4gMC41ID8gMSAtIGNlbnRlci54IDogY2VudGVyLng7XG4gICAgdmFyIGN5ID0gY2VudGVyLnkgPiAwLjUgPyAxIC0gY2VudGVyLnkgOiBjZW50ZXIueTtcbiAgICB2YXIgaW1hZ2VXaWR0aCA9IGN4ICogMiAqIGltYWdlUmVjdC53aWR0aDtcbiAgICB2YXIgaW1hZ2VIZWlnaHQgPSBjeSAqIDIgKiBpbWFnZVJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgY3JvcCByZWN0YW5nbGUgc2l6ZVxuICAgIHZhciByb3RhdGVkQ3JvcFNpemUgPSBnZXRSb3RhdGVkUmVjdFNpemUoY3JvcFJlY3QsIHJvdGF0aW9uKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBzY2FsYXIgcmVxdWlyZWQgdG8gZml0IGltYWdlXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgcm90YXRlZENyb3BTaXplLndpZHRoIC8gaW1hZ2VXaWR0aCxcbiAgICAgIHJvdGF0ZWRDcm9wU2l6ZS5oZWlnaHQgLyBpbWFnZUhlaWdodFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGdldENlbnRlcmVkQ3JvcFJlY3QgPSBmdW5jdGlvbiBnZXRDZW50ZXJlZENyb3BSZWN0KFxuICAgIGNvbnRhaW5lcixcbiAgICBhc3BlY3RSYXRpb1xuICApIHtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXIud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG4gICAgaWYgKGhlaWdodCA+IGNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCAvIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICB2YXIgeCA9IChjb250YWluZXIud2lkdGggLSB3aWR0aCkgKiAwLjU7XG4gICAgdmFyIHkgPSAoY29udGFpbmVyLmhlaWdodCAtIGhlaWdodCkgKiAwLjU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldEN1cnJlbnRDcm9wU2l6ZSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRDcm9wU2l6ZShpbWFnZVNpemUpIHtcbiAgICB2YXIgY3JvcCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB6b29tID0gY3JvcC56b29tLFxuICAgICAgcm90YXRpb24gPSBjcm9wLnJvdGF0aW9uLFxuICAgICAgY2VudGVyID0gY3JvcC5jZW50ZXIsXG4gICAgICBhc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW87XG5cbiAgICBpZiAoIWFzcGVjdFJhdGlvKSBhc3BlY3RSYXRpbyA9IGltYWdlU2l6ZS5oZWlnaHQgLyBpbWFnZVNpemUud2lkdGg7XG5cbiAgICB2YXIgY2FudmFzU2l6ZSA9IGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2VTaXplLCBhc3BlY3RSYXRpbywgem9vbSk7XG5cbiAgICB2YXIgY2FudmFzQ2VudGVyID0ge1xuICAgICAgeDogY2FudmFzU2l6ZS53aWR0aCAqIDAuNSxcbiAgICAgIHk6IGNhbnZhc1NpemUuaGVpZ2h0ICogMC41XG4gICAgfTtcblxuICAgIHZhciBzdGFnZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGNhbnZhc1NpemUud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgY2VudGVyOiBjYW52YXNDZW50ZXJcbiAgICB9O1xuXG4gICAgdmFyIHNob3VsZExpbWl0ID0gdHlwZW9mIGNyb3Auc2NhbGVUb0ZpdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY3JvcC5zY2FsZVRvRml0O1xuXG4gICAgdmFyIHN0YWdlWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgICBpbWFnZVNpemUsXG4gICAgICBnZXRDZW50ZXJlZENyb3BSZWN0KHN0YWdlLCBhc3BlY3RSYXRpbyksXG4gICAgICByb3RhdGlvbixcbiAgICAgIHNob3VsZExpbWl0ID8gY2VudGVyIDogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgKTtcblxuICAgIHZhciBzY2FsZSA9IHpvb20gKiBzdGFnZVpvb21GYWN0b3I7XG5cbiAgICAvLyBzdGFydCBkcmF3aW5nXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoRmxvYXQ6IGNhbnZhc1NpemUud2lkdGggLyBzY2FsZSxcbiAgICAgIGhlaWdodEZsb2F0OiBjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlLFxuICAgICAgd2lkdGg6IE1hdGgucm91bmQoY2FudmFzU2l6ZS53aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZChjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyA9IHtcbiAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICBzdGlmZm5lc3M6IDAuNSxcbiAgICBkYW1waW5nOiAwLjQ1LFxuICAgIG1hc3M6IDEwXG4gIH07XG5cbiAgLy8gZG9lcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBmbGlwcGluZ1xuICB2YXIgY3JlYXRlQml0bWFwVmlldyA9IGZ1bmN0aW9uIGNyZWF0ZUJpdG1hcFZpZXcoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLWJpdG1hcCcsXG4gICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgbWl4aW5zOiB7IHN0eWxlczogWydzY2FsZVgnLCAnc2NhbGVZJ10gfSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHByb3BzLmltYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBzaGlmdHMgYW5kIHJvdGF0ZXMgaW1hZ2VcbiAgdmFyIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlcihfKSB7XG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtY2FudmFzLXdyYXBwZXInLFxuICAgICAgdGFnOiAnZGl2JyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydjcm9wJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuXG4gICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICdvcmlnaW5YJyxcbiAgICAgICAgICAnb3JpZ2luWScsXG4gICAgICAgICAgJ3RyYW5zbGF0ZVgnLFxuICAgICAgICAgICd0cmFuc2xhdGVZJyxcbiAgICAgICAgICAnc2NhbGVYJyxcbiAgICAgICAgICAnc2NhbGVZJyxcbiAgICAgICAgICAncm90YXRlWidcbiAgICAgICAgXSxcblxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgb3JpZ2luWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIG9yaWdpblk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVg6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICB0cmFuc2xhdGVYOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgdHJhbnNsYXRlWTogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIHJvdGF0ZVo6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QU1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgcHJvcHMud2lkdGggPSBwcm9wcy5pbWFnZS53aWR0aDtcbiAgICAgICAgcHJvcHMuaGVpZ2h0ID0gcHJvcHMuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICByb290LnJlZi5iaXRtYXAgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVCaXRtYXBWaWV3KF8pLCB7IGltYWdlOiBwcm9wcy5pbWFnZSB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgdmFyIGZsaXAgPSBwcm9wcy5jcm9wLmZsaXA7XG4gICAgICAgIHZhciBiaXRtYXAgPSByb290LnJlZi5iaXRtYXA7XG4gICAgICAgIGJpdG1hcC5zY2FsZVggPSBmbGlwLmhvcml6b250YWwgPyAtMSA6IDE7XG4gICAgICAgIGJpdG1hcC5zY2FsZVkgPSBmbGlwLnZlcnRpY2FsID8gLTEgOiAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGNsaXBzIGNhbnZhcyB0byBjb3JyZWN0IGFzcGVjdCByYXRpb1xuICB2YXIgY3JlYXRlQ2xpcFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVDbGlwVmlldyhfKSB7XG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtY2xpcCcsXG4gICAgICB0YWc6ICdkaXYnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbXG4gICAgICAgICAgJ2Nyb3AnLFxuICAgICAgICAgICdtYXJrdXAnLFxuICAgICAgICAgICdyZXNpemUnLFxuICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgJ2RpcnR5JyxcbiAgICAgICAgICAnYmFja2dyb3VuZCdcbiAgICAgICAgXSxcblxuICAgICAgICBzdHlsZXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpZFdyaXRlVmlldzogZnVuY3Rpb24gZGlkV3JpdGVWaWV3KF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY0LnByb3BzO1xuICAgICAgICBpZiAoIXByb3BzLmJhY2tncm91bmQpIHJldHVybjtcbiAgICAgICAgcm9vdC5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHByb3BzLmJhY2tncm91bmQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHM7XG5cbiAgICAgICAgcm9vdC5yZWYuaW1hZ2UgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlcihfKSxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICByb290LnJlZi5jcmVhdGVNYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocm9vdC5yZWYubWFya3VwKSByZXR1cm47XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVNYXJrdXBWaWV3KF8pLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByb290LnJlZi5kZXN0cm95TWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFyb290LnJlZi5tYXJrdXApIHJldHVybjtcbiAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5tYXJrdXApO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cCA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcGFyZW5jeSBncmlkXG4gICAgICAgIHZhciB0cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSByb290LnF1ZXJ5KFxuICAgICAgICAgICdHRVRfSU1BR0VfUFJFVklFV19UUkFOU1BBUkVOQ1lfSU5ESUNBVE9SJ1xuICAgICAgICApO1xuICAgICAgICBpZiAodHJhbnNwYXJlbmN5SW5kaWNhdG9yID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gZ3JpZCBwYXR0ZXJuXG4gICAgICAgIGlmICh0cmFuc3BhcmVuY3lJbmRpY2F0b3IgPT09ICdncmlkJykge1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnRyYW5zcGFyZW5jeUluZGljYXRvciA9IHRyYW5zcGFyZW5jeUluZGljYXRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiYXNpYyBjb2xvclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC50cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSAnY29sb3InO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzLFxuICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjYuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgIHZhciBjcm9wID0gcHJvcHMuY3JvcCxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXAsXG4gICAgICAgICAgcmVzaXplID0gcHJvcHMucmVzaXplLFxuICAgICAgICAgIGRpcnR5ID0gcHJvcHMuZGlydHksXG4gICAgICAgICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG5cbiAgICAgICAgcm9vdC5yZWYuaW1hZ2UuY3JvcCA9IGNyb3A7XG5cbiAgICAgICAgdmFyIHN0YWdlID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB4OiB3aWR0aCAqIDAuNSxcbiAgICAgICAgICAgIHk6IGhlaWdodCAqIDAuNVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB7XG4gICAgICAgICAgd2lkdGg6IHJvb3QucmVmLmltYWdlLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcm9vdC5yZWYuaW1hZ2UuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgICB4OiBjcm9wLmNlbnRlci54ICogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgeTogY3JvcC5jZW50ZXIueSAqIGltYWdlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiBzdGFnZS5jZW50ZXIueCAtIGltYWdlLndpZHRoICogY3JvcC5jZW50ZXIueCxcbiAgICAgICAgICB5OiBzdGFnZS5jZW50ZXIueSAtIGltYWdlLmhlaWdodCAqIGNyb3AuY2VudGVyLnlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLlBJICogMiArIChjcm9wLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyKSk7XG5cbiAgICAgICAgdmFyIGNyb3BBc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW8gfHwgaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAgICAgdmFyIHNob3VsZExpbWl0ID1cbiAgICAgICAgICB0eXBlb2YgY3JvcC5zY2FsZVRvRml0ID09PSAndW5kZWZpbmVkJyB8fCBjcm9wLnNjYWxlVG9GaXQ7XG5cbiAgICAgICAgdmFyIHN0YWdlWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgZ2V0Q2VudGVyZWRDcm9wUmVjdChzdGFnZSwgY3JvcEFzcGVjdFJhdGlvKSxcblxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNob3VsZExpbWl0ID8gY3JvcC5jZW50ZXIgOiB7IHg6IDAuNSwgeTogMC41IH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgc2NhbGUgPSBjcm9wLnpvb20gKiBzdGFnZVpvb21GYWN0b3I7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcmt1cCB2aWV3XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLmxlbmd0aCkge1xuICAgICAgICAgIHJvb3QucmVmLmNyZWF0ZU1hcmt1cCgpO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwLnJlc2l6ZSA9IHJlc2l6ZTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAuZGlydHkgPSBkaXJ0eTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAubWFya3VwID0gbWFya3VwO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC5jcm9wID0gZ2V0Q3VycmVudENyb3BTaXplKGltYWdlLCBjcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb290LnJlZi5tYXJrdXApIHtcbiAgICAgICAgICByb290LnJlZi5kZXN0cm95TWFya3VwKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgaW1hZ2Ugdmlld1xuICAgICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2U7XG5cbiAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNsaXAgbGF5b3V0XG4gICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgIGltYWdlVmlldy5vcmlnaW5YID0gbnVsbDtcbiAgICAgICAgICBpbWFnZVZpZXcub3JpZ2luWSA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICBpbWFnZVZpZXcucm90YXRlWiA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWCA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblggPSBvcmlnaW4ueDtcbiAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVggPSB0cmFuc2xhdGlvbi54O1xuICAgICAgICBpbWFnZVZpZXcudHJhbnNsYXRlWSA9IHRyYW5zbGF0aW9uLnk7XG4gICAgICAgIGltYWdlVmlldy5yb3RhdGVaID0gcm90YXRpb247XG4gICAgICAgIGltYWdlVmlldy5zY2FsZVggPSBzY2FsZTtcbiAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWSA9IHNjYWxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVJbWFnZVZpZXcgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZVZpZXcoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLXByZXZpZXcnLFxuICAgICAgdGFnOiAnZGl2JyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydpbWFnZScsICdjcm9wJywgJ21hcmt1cCcsICdyZXNpemUnLCAnZGlydHknLCAnYmFja2dyb3VuZCddLFxuXG4gICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICBzY2FsZVg6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNDAwIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZjcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICAgIHJvb3QucmVmLmNsaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVDbGlwVmlldyhfKSwge1xuICAgICAgICAgICAgaWQ6IHByb3BzLmlkLFxuICAgICAgICAgICAgaW1hZ2U6IHByb3BzLmltYWdlLFxuICAgICAgICAgICAgY3JvcDogcHJvcHMuY3JvcCxcbiAgICAgICAgICAgIG1hcmt1cDogcHJvcHMubWFya3VwLFxuICAgICAgICAgICAgcmVzaXplOiBwcm9wcy5yZXNpemUsXG4gICAgICAgICAgICBkaXJ0eTogcHJvcHMuZGlydHksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjgucHJvcHMsXG4gICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmOC5zaG91bGRPcHRpbWl6ZTtcbiAgICAgICAgdmFyIGNsaXAgPSByb290LnJlZi5jbGlwO1xuICAgICAgICB2YXIgaW1hZ2UgPSBwcm9wcy5pbWFnZSxcbiAgICAgICAgICBjcm9wID0gcHJvcHMuY3JvcCxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXAsXG4gICAgICAgICAgcmVzaXplID0gcHJvcHMucmVzaXplLFxuICAgICAgICAgIGRpcnR5ID0gcHJvcHMuZGlydHk7XG5cbiAgICAgICAgY2xpcC5jcm9wID0gY3JvcDtcbiAgICAgICAgY2xpcC5tYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGNsaXAucmVzaXplID0gcmVzaXplO1xuICAgICAgICBjbGlwLmRpcnR5ID0gZGlydHk7XG5cbiAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNsaXAgbGF5b3V0XG4gICAgICAgIGNsaXAub3BhY2l0eSA9IHNob3VsZE9wdGltaXplID8gMCA6IDE7XG5cbiAgICAgICAgLy8gZG9uJ3QgcmUtcmVuZGVyIGlmIG9wdGltaXppbmcgb3IgaGlkZGVuICh3aWR0aCB3aWxsIGJlIHplcm8gcmVzdWx0aW5nIGluIHdlaXJkIGFuaW1hdGlvbnMpXG4gICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSB8fCByb290LnJlY3QuZWxlbWVudC5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVkIHByZXZpZXcgaW1hZ2Ugc2l6ZVxuICAgICAgICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBjcm9wLmFzcGVjdFJhdGlvIHx8IGltYWdlQXNwZWN0UmF0aW87XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGNvbnRhaW5lciBzaXplXG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHJvb3QucmVjdC5pbm5lci53aWR0aDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHJvb3QucmVjdC5pbm5lci5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGZpeGVkUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgICB2YXIgbWluUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01JTl9IRUlHSFQnKTtcbiAgICAgICAgdmFyIG1heFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSEVJR0hUJyk7XG5cbiAgICAgICAgdmFyIHBhbmVsQXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIHZhciBhbGxvd011bHRpcGxlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG5cbiAgICAgICAgaWYgKHBhbmVsQXNwZWN0UmF0aW8gJiYgIWFsbG93TXVsdGlwbGUpIHtcbiAgICAgICAgICBmaXhlZFByZXZpZXdIZWlnaHQgPSBjb250YWluZXJXaWR0aCAqIHBhbmVsQXNwZWN0UmF0aW87XG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBwYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGNsaXAgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICB2YXIgY2xpcEhlaWdodCA9XG4gICAgICAgICAgZml4ZWRQcmV2aWV3SGVpZ2h0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGZpeGVkUHJldmlld0hlaWdodFxuICAgICAgICAgICAgOiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBtaW5QcmV2aWV3SGVpZ2h0LFxuICAgICAgICAgICAgICAgIE1hdGgubWluKGNvbnRhaW5lcldpZHRoICogYXNwZWN0UmF0aW8sIG1heFByZXZpZXdIZWlnaHQpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgdmFyIGNsaXBXaWR0aCA9IGNsaXBIZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgaWYgKGNsaXBXaWR0aCA+IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgY2xpcFdpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgY2xpcEhlaWdodCA9IGNsaXBXaWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaXBIZWlnaHQgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICBjbGlwSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGNsaXBXaWR0aCA9IGNvbnRhaW5lckhlaWdodCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xpcC53aWR0aCA9IGNsaXBXaWR0aDtcbiAgICAgICAgY2xpcC5oZWlnaHQgPSBjbGlwSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBTVkdfTUFTSyA9XG4gICAgJzxzdmcgd2lkdGg9XCI1MDBcIiBoZWlnaHQ9XCIyMDBcIiB2aWV3Qm94PVwiMCAwIDUwMCAyMDBcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiPlxcbiAgICA8ZGVmcz5cXG4gICAgICAgIDxyYWRpYWxHcmFkaWVudCBpZD1cImdyYWRpZW50LV9fVUlEX19cIiBjeD1cIi41XCIgY3k9XCIxLjI1XCIgcj1cIjEuMTVcIj5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnNTAlXFwnIHN0b3AtY29sb3I9XFwnIzAwMDAwMFxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzU2JVxcJyBzdG9wLWNvbG9yPVxcJyMwYTBhMGFcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc2MyVcXCcgc3RvcC1jb2xvcj1cXCcjMjYyNjI2XFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnNjklXFwnIHN0b3AtY29sb3I9XFwnIzRmNGY0ZlxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzc1JVxcJyBzdG9wLWNvbG9yPVxcJyM4MDgwODBcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc4MSVcXCcgc3RvcC1jb2xvcj1cXCcjYjFiMWIxXFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnODglXFwnIHN0b3AtY29sb3I9XFwnI2RhZGFkYVxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzk0JVxcJyBzdG9wLWNvbG9yPVxcJyNmNmY2ZjZcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCcxMDAlXFwnIHN0b3AtY29sb3I9XFwnI2ZmZmZmZlxcJy8+XFxuICAgICAgICA8L3JhZGlhbEdyYWRpZW50PlxcbiAgICAgICAgPG1hc2sgaWQ9XCJtYXNrLV9fVUlEX19cIj5cXG4gICAgICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI1MDBcIiBoZWlnaHQ9XCIyMDBcIiBmaWxsPVwidXJsKCNncmFkaWVudC1fX1VJRF9fKVwiPjwvcmVjdD5cXG4gICAgICAgIDwvbWFzaz5cXG4gICAgPC9kZWZzPlxcbiAgICA8cmVjdCB4PVwiMFwiIHdpZHRoPVwiNTAwXCIgaGVpZ2h0PVwiMjAwXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIG1hc2s9XCJ1cmwoI21hc2stX19VSURfXylcIj48L3JlY3Q+XFxuPC9zdmc+JztcblxuICB2YXIgU1ZHTWFza1VuaXF1ZUlkID0gMDtcblxuICB2YXIgY3JlYXRlSW1hZ2VPdmVybGF5VmlldyA9IGZ1bmN0aW9uIGNyZWF0ZUltYWdlT3ZlcmxheVZpZXcoZnBBUEkpIHtcbiAgICByZXR1cm4gZnBBUEkudXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtcHJldmlldy1vdmVybGF5JyxcbiAgICAgIHRhZzogJ2RpdicsXG4gICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHZhciBtYXNrID0gU1ZHX01BU0s7XG4gICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJykpIHtcbiAgICAgICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaGFzaCwgJycpO1xuICAgICAgICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UoL3VybFxcKFxcIy9nLCAndXJsKCcgKyB1cmwgKyAnIycpO1xuICAgICAgICB9XG5cbiAgICAgICAgU1ZHTWFza1VuaXF1ZUlkKys7XG4gICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFxuICAgICAgICAgICdmaWxlcG9uZC0taW1hZ2UtcHJldmlldy1vdmVybGF5LScuY29uY2F0KHByb3BzLnN0YXR1cylcbiAgICAgICAgKTtcblxuICAgICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gbWFzay5yZXBsYWNlKC9fX1VJRF9fL2csIFNWR01hc2tVbmlxdWVJZCk7XG4gICAgICB9LFxuICAgICAgbWl4aW5zOiB7XG4gICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICdzcHJpbmcnLCBtYXNzOiAyNSB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQml0bWFwIFdvcmtlclxuICAgKi9cbiAgdmFyIEJpdG1hcFdvcmtlciA9IGZ1bmN0aW9uIEJpdG1hcFdvcmtlcigpIHtcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGUuZGF0YS5tZXNzYWdlLmZpbGUpLnRoZW4oZnVuY3Rpb24oYml0bWFwKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBpZDogZS5kYXRhLmlkLCBtZXNzYWdlOiBiaXRtYXAgfSwgW2JpdG1hcF0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ29sb3JNYXRyaXggV29ya2VyXG4gICAqL1xuICB2YXIgQ29sb3JNYXRyaXhXb3JrZXIgPSBmdW5jdGlvbiBDb2xvck1hdHJpeFdvcmtlcigpIHtcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBlLmRhdGEubWVzc2FnZS5pbWFnZURhdGE7XG4gICAgICB2YXIgbWF0cml4ID0gZS5kYXRhLm1lc3NhZ2UuY29sb3JNYXRyaXg7XG5cbiAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICB2YXIgbTExID0gbWF0cml4WzBdO1xuICAgICAgdmFyIG0xMiA9IG1hdHJpeFsxXTtcbiAgICAgIHZhciBtMTMgPSBtYXRyaXhbMl07XG4gICAgICB2YXIgbTE0ID0gbWF0cml4WzNdO1xuICAgICAgdmFyIG0xNSA9IG1hdHJpeFs0XTtcblxuICAgICAgdmFyIG0yMSA9IG1hdHJpeFs1XTtcbiAgICAgIHZhciBtMjIgPSBtYXRyaXhbNl07XG4gICAgICB2YXIgbTIzID0gbWF0cml4WzddO1xuICAgICAgdmFyIG0yNCA9IG1hdHJpeFs4XTtcbiAgICAgIHZhciBtMjUgPSBtYXRyaXhbOV07XG5cbiAgICAgIHZhciBtMzEgPSBtYXRyaXhbMTBdO1xuICAgICAgdmFyIG0zMiA9IG1hdHJpeFsxMV07XG4gICAgICB2YXIgbTMzID0gbWF0cml4WzEyXTtcbiAgICAgIHZhciBtMzQgPSBtYXRyaXhbMTNdO1xuICAgICAgdmFyIG0zNSA9IG1hdHJpeFsxNF07XG5cbiAgICAgIHZhciBtNDEgPSBtYXRyaXhbMTVdO1xuICAgICAgdmFyIG00MiA9IG1hdHJpeFsxNl07XG4gICAgICB2YXIgbTQzID0gbWF0cml4WzE3XTtcbiAgICAgIHZhciBtNDQgPSBtYXRyaXhbMThdO1xuICAgICAgdmFyIG00NSA9IG1hdHJpeFsxOV07XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIHIgPSAwLjAsXG4gICAgICAgIGcgPSAwLjAsXG4gICAgICAgIGIgPSAwLjAsXG4gICAgICAgIGEgPSAwLjA7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IGw7IGluZGV4ICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaW5kZXhdIC8gMjU1O1xuICAgICAgICBnID0gZGF0YVtpbmRleCArIDFdIC8gMjU1O1xuICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdIC8gMjU1O1xuICAgICAgICBhID0gZGF0YVtpbmRleCArIDNdIC8gMjU1O1xuICAgICAgICBkYXRhW2luZGV4XSA9IE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oKHIgKiBtMTEgKyBnICogbTEyICsgYiAqIG0xMyArIGEgKiBtMTQgKyBtMTUpICogMjU1LCAyNTUpXG4gICAgICAgICk7XG4gICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oKHIgKiBtMjEgKyBnICogbTIyICsgYiAqIG0yMyArIGEgKiBtMjQgKyBtMjUpICogMjU1LCAyNTUpXG4gICAgICAgICk7XG4gICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oKHIgKiBtMzEgKyBnICogbTMyICsgYiAqIG0zMyArIGEgKiBtMzQgKyBtMzUpICogMjU1LCAyNTUpXG4gICAgICAgICk7XG4gICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oKHIgKiBtNDEgKyBnICogbTQyICsgYiAqIG00MyArIGEgKiBtNDQgKyBtNDUpICogMjU1LCAyNTUpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBpZDogZS5kYXRhLmlkLCBtZXNzYWdlOiBpbWFnZURhdGEgfSwgW1xuICAgICAgICBpbWFnZURhdGEuZGF0YS5idWZmZXJcbiAgICAgIF0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldEltYWdlU2l6ZSA9IGZ1bmN0aW9uIGdldEltYWdlU2l6ZSh1cmwsIGNiKSB7XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgIGNiKHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm1zID0ge1xuICAgIDE6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH0sXG4gICAgMjogZnVuY3Rpb24gXyh3aWR0aCkge1xuICAgICAgcmV0dXJuIFstMSwgMCwgMCwgMSwgd2lkdGgsIDBdO1xuICAgIH0sXG4gICAgMzogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMSwgd2lkdGgsIGhlaWdodF07XG4gICAgfSxcbiAgICA0OiBmdW5jdGlvbiBfKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgLTEsIDAsIGhlaWdodF07XG4gICAgfSxcbiAgICA1OiBmdW5jdGlvbiBfKCkge1xuICAgICAgcmV0dXJuIFswLCAxLCAxLCAwLCAwLCAwXTtcbiAgICB9LFxuICAgIDY6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIFswLCAxLCAtMSwgMCwgaGVpZ2h0LCAwXTtcbiAgICB9LFxuICAgIDc6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIFswLCAtMSwgLTEsIDAsIGhlaWdodCwgd2lkdGhdO1xuICAgIH0sXG4gICAgODogZnVuY3Rpb24gXyh3aWR0aCkge1xuICAgICAgcmV0dXJuIFswLCAtMSwgMSwgMCwgMCwgd2lkdGhdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZml4SW1hZ2VPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIGZpeEltYWdlT3JpZW50YXRpb24oXG4gICAgY3R4LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBvcmllbnRhdGlvblxuICApIHtcbiAgICAvLyBubyBvcmllbnRhdGlvbiBzdXBwbGllZFxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdHJhbnNmb3Jtc1tvcmllbnRhdGlvbl0od2lkdGgsIGhlaWdodCkpO1xuICB9O1xuXG4gIC8vIGRyYXdzIHRoZSBwcmV2aWV3IGltYWdlIHRvIGNhbnZhc1xuICB2YXIgY3JlYXRlUHJldmlld0ltYWdlID0gZnVuY3Rpb24gY3JlYXRlUHJldmlld0ltYWdlKFxuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9yaWVudGF0aW9uXG4gICkge1xuICAgIC8vIGNhbid0IGRyYXcgb24gaGFsZiBwaXhlbHNcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcblxuICAgIC8vIGRyYXcgaW1hZ2VcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBpZiBpcyByb3RhdGVkIGluY29ycmVjdGx5IHN3YXAgd2lkdGggYW5kIGhlaWdodFxuICAgIGlmIChvcmllbnRhdGlvbiA+PSA1ICYmIG9yaWVudGF0aW9uIDw9IDgpIHtcbiAgICAgIHZhciBfcmVmID0gW2hlaWdodCwgd2lkdGhdO1xuICAgICAgd2lkdGggPSBfcmVmWzBdO1xuICAgICAgaGVpZ2h0ID0gX3JlZlsxXTtcbiAgICB9XG5cbiAgICAvLyBjb3JyZWN0IGltYWdlIG9yaWVudGF0aW9uXG4gICAgZml4SW1hZ2VPcmllbnRhdGlvbihjdHgsIHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKTtcblxuICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgY3R4LmRyYXdJbWFnZShkYXRhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG5cbiAgdmFyIGlzQml0bWFwID0gZnVuY3Rpb24gaXNCaXRtYXAoZmlsZSkge1xuICAgIHJldHVybiAvXmltYWdlLy50ZXN0KGZpbGUudHlwZSkgJiYgIS9zdmcvLnRlc3QoZmlsZS50eXBlKTtcbiAgfTtcblxuICB2YXIgTUFYX1dJRFRIID0gMTA7XG4gIHZhciBNQVhfSEVJR0hUID0gMTA7XG5cbiAgdmFyIGNhbGN1bGF0ZUF2ZXJhZ2VDb2xvciA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUF2ZXJhZ2VDb2xvcihpbWFnZSkge1xuICAgIHZhciBzY2FsYXIgPSBNYXRoLm1pbihNQVhfV0lEVEggLyBpbWFnZS53aWR0aCwgTUFYX0hFSUdIVCAvIGltYWdlLmhlaWdodCk7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciB3aWR0aCA9IChjYW52YXMud2lkdGggPSBNYXRoLmNlaWwoaW1hZ2Uud2lkdGggKiBzY2FsYXIpKTtcbiAgICB2YXIgaGVpZ2h0ID0gKGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaW1hZ2UuaGVpZ2h0ICogc2NhbGFyKSk7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGRhdGEgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBnID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIHIgKz0gZGF0YVtpXSAqIGRhdGFbaV07XG4gICAgICBnICs9IGRhdGFbaSArIDFdICogZGF0YVtpICsgMV07XG4gICAgICBiICs9IGRhdGFbaSArIDJdICogZGF0YVtpICsgMl07XG4gICAgfVxuXG4gICAgciA9IGF2ZXJhZ2VDb2xvcihyLCBsKTtcbiAgICBnID0gYXZlcmFnZUNvbG9yKGcsIGwpO1xuICAgIGIgPSBhdmVyYWdlQ29sb3IoYiwgbCk7XG5cbiAgICByZXR1cm4geyByOiByLCBnOiBnLCBiOiBiIH07XG4gIH07XG5cbiAgdmFyIGF2ZXJhZ2VDb2xvciA9IGZ1bmN0aW9uIGF2ZXJhZ2VDb2xvcihjLCBsKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5zcXJ0KGMgLyAobCAvIDQpKSk7XG4gIH07XG5cbiAgdmFyIGNsb25lQ2FudmFzID0gZnVuY3Rpb24gY2xvbmVDYW52YXMob3JpZ2luLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGFyZ2V0LndpZHRoID0gb3JpZ2luLndpZHRoO1xuICAgIHRhcmdldC5oZWlnaHQgPSBvcmlnaW4uaGVpZ2h0O1xuICAgIHZhciBjdHggPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKG9yaWdpbiwgMCwgMCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICB2YXIgY2xvbmVJbWFnZURhdGEgPSBmdW5jdGlvbiBjbG9uZUltYWdlRGF0YShpbWFnZURhdGEpIHtcbiAgICB2YXIgaWQ7XG4gICAgdHJ5IHtcbiAgICAgIGlkID0gbmV3IEltYWdlRGF0YShpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlkID0gY3R4LmNyZWF0ZUltYWdlRGF0YShpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgIH1cbiAgICBpZC5kYXRhLnNldChuZXcgVWludDhDbGFtcGVkQXJyYXkoaW1hZ2VEYXRhLmRhdGEpKTtcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgdmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgfTtcbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9O1xuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSW1hZ2VXcmFwcGVyVmlldyA9IGZ1bmN0aW9uIGNyZWF0ZUltYWdlV3JhcHBlclZpZXcoXykge1xuICAgIC8vIGNyZWF0ZSBvdmVybGF5IHZpZXdcbiAgICB2YXIgT3ZlcmxheVZpZXcgPSBjcmVhdGVJbWFnZU92ZXJsYXlWaWV3KF8pO1xuXG4gICAgdmFyIEltYWdlVmlldyA9IGNyZWF0ZUltYWdlVmlldyhfKTtcbiAgICB2YXIgY3JlYXRlV29ya2VyID0gXy51dGlscy5jcmVhdGVXb3JrZXI7XG5cbiAgICB2YXIgYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiBhcHBseUZpbHRlcihyb290LCBmaWx0ZXIsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgLy8gd2lsbCBzdG9yZSBpbWFnZSBkYXRhIGZvciBmdXR1cmUgZmlsdGVyIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFyb290LnJlZi5pbWFnZURhdGEpIHtcbiAgICAgICAgICByb290LnJlZi5pbWFnZURhdGEgPSB0YXJnZXRcbiAgICAgICAgICAgIC5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgaW1hZ2UgZGF0YSByZWZlcmVuY2VcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNsb25lSW1hZ2VEYXRhKHJvb3QucmVmLmltYWdlRGF0YSk7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgICB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlciA9IGNyZWF0ZVdvcmtlcihDb2xvck1hdHJpeFdvcmtlcik7XG4gICAgICAgIHdvcmtlci5wb3N0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICAgICAgY29sb3JNYXRyaXg6IGZpbHRlclxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgZmlsdGVyZWQgY29sb3JzXG4gICAgICAgICAgICB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEocmVzcG9uc2UsIDAsIDApO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHdvcmtlclxuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgW2ltYWdlRGF0YS5kYXRhLmJ1ZmZlcl1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlSW1hZ2VWaWV3ID0gZnVuY3Rpb24gcmVtb3ZlSW1hZ2VWaWV3KHJvb3QsIGltYWdlVmlldykge1xuICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcoaW1hZ2VWaWV3KTtcbiAgICAgIGltYWdlVmlldy5pbWFnZS53aWR0aCA9IDE7XG4gICAgICBpbWFnZVZpZXcuaW1hZ2UuaGVpZ2h0ID0gMTtcbiAgICAgIGltYWdlVmlldy5fZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICAvLyByZW1vdmUgYW4gaW1hZ2VcbiAgICB2YXIgc2hpZnRJbWFnZSA9IGZ1bmN0aW9uIHNoaWZ0SW1hZ2UoX3JlZikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2VzLnNoaWZ0KCk7XG4gICAgICBpbWFnZVZpZXcub3BhY2l0eSA9IDA7XG4gICAgICBpbWFnZVZpZXcudHJhbnNsYXRlWSA9IC0xNTtcbiAgICAgIHJvb3QucmVmLmltYWdlVmlld0Jpbi5wdXNoKGltYWdlVmlldyk7XG4gICAgICByZXR1cm4gaW1hZ2VWaWV3O1xuICAgIH07XG5cbiAgICAvLyBhZGQgbmV3IGltYWdlXG4gICAgdmFyIHB1c2hJbWFnZSA9IGZ1bmN0aW9uIHB1c2hJbWFnZShfcmVmMikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgICBpbWFnZSA9IF9yZWYyLmltYWdlO1xuICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogaWQgfSk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgdmFyIGNyb3AgPSBpdGVtLmdldE1ldGFkYXRhKCdjcm9wJykgfHwge1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgeTogMC41XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcDoge1xuICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIHpvb206IDEsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBhc3BlY3RSYXRpbzogbnVsbFxuICAgICAgfTtcblxuICAgICAgdmFyIGJhY2tncm91bmQgPSByb290LnF1ZXJ5KFxuICAgICAgICAnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfQkFDS0dST1VORF9DT0xPUidcbiAgICAgICk7XG5cbiAgICAgIHZhciBtYXJrdXA7XG4gICAgICB2YXIgcmVzaXplO1xuICAgICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFSS1VQX1NIT1cnKSkge1xuICAgICAgICBtYXJrdXAgPSBpdGVtLmdldE1ldGFkYXRhKCdtYXJrdXAnKSB8fCBbXTtcbiAgICAgICAgcmVzaXplID0gaXRlbS5nZXRNZXRhZGF0YSgncmVzaXplJyk7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwZW5kIGltYWdlIHByZXNlbnRlclxuICAgICAgdmFyIGltYWdlVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhJbWFnZVZpZXcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgIGNyb3A6IGNyb3AsXG4gICAgICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICAgICAgbWFya3VwOiBtYXJrdXAsXG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBzY2FsZVg6IDEuMTUsXG4gICAgICAgICAgc2NhbGVZOiAxLjE1LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDE1XG4gICAgICAgIH0pLFxuXG4gICAgICAgIHJvb3QuY2hpbGRWaWV3cy5sZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIHJvb3QucmVmLmltYWdlcy5wdXNoKGltYWdlVmlldyk7XG5cbiAgICAgIC8vIHJldmVhbCB0aGUgcHJldmlldyBpbWFnZVxuICAgICAgaW1hZ2VWaWV3Lm9wYWNpdHkgPSAxO1xuICAgICAgaW1hZ2VWaWV3LnNjYWxlWCA9IDE7XG4gICAgICBpbWFnZVZpZXcuc2NhbGVZID0gMTtcbiAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gMDtcblxuICAgICAgLy8gdGhlIHByZXZpZXcgaXMgbm93IHJlYWR5IHRvIGJlIGRyYXduXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfSU1BR0VfUFJFVklFV19TSE9XJywgeyBpZDogaWQgfSk7XG4gICAgICB9LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlSW1hZ2UgPSBmdW5jdGlvbiB1cGRhdGVJbWFnZShfcmVmMykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGltYWdlVmlldy5jcm9wID0gaXRlbS5nZXRNZXRhZGF0YSgnY3JvcCcpO1xuICAgICAgaW1hZ2VWaWV3LmJhY2tncm91bmQgPSByb290LnF1ZXJ5KFxuICAgICAgICAnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfQkFDS0dST1VORF9DT0xPUidcbiAgICAgICk7XG5cbiAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVJLVVBfU0hPVycpKSB7XG4gICAgICAgIGltYWdlVmlldy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGltYWdlVmlldy5yZXNpemUgPSBpdGVtLmdldE1ldGFkYXRhKCdyZXNpemUnKTtcbiAgICAgICAgaW1hZ2VWaWV3Lm1hcmt1cCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ21hcmt1cCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXBsYWNlIGltYWdlIHByZXZpZXdcbiAgICB2YXIgZGlkVXBkYXRlSXRlbU1ldGFkYXRhID0gZnVuY3Rpb24gZGlkVXBkYXRlSXRlbU1ldGFkYXRhKF9yZWY0KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjQucHJvcHMsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgIC8vIG9ubHkgZmlsdGVyIGFuZCBjcm9wIHRyaWdnZXIgcmVkcmF3XG4gICAgICBpZiAoIS9jcm9wfGZpbHRlcnxtYXJrdXB8cmVzaXplLy50ZXN0KGFjdGlvbi5jaGFuZ2Uua2V5KSkgcmV0dXJuO1xuXG4gICAgICAvLyBubyBpbWFnZXMgdG8gdXBkYXRlLCBleGl0XG4gICAgICBpZiAoIXJvb3QucmVmLmltYWdlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgLy8gbm8gaXRlbSBmb3VuZCwgZXhpdFxuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgIC8vIGZvciBub3csIHVwZGF0ZSBleGlzdGluZyBpbWFnZSB3aGVuIGZpbHRlcmluZ1xuICAgICAgaWYgKC9maWx0ZXIvLnRlc3QoYWN0aW9uLmNoYW5nZS5rZXkpKSB7XG4gICAgICAgIHZhciBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBhcHBseUZpbHRlcihyb290LCBhY3Rpb24uY2hhbmdlLnZhbHVlLCBpbWFnZVZpZXcuaW1hZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgvY3JvcHxtYXJrdXB8cmVzaXplLy50ZXN0KGFjdGlvbi5jaGFuZ2Uua2V5KSkge1xuICAgICAgICB2YXIgY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKTtcbiAgICAgICAgdmFyIGltYWdlID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBjcm9wICYmXG4gICAgICAgICAgY3JvcC5hc3BlY3RSYXRpbyAmJlxuICAgICAgICAgIGltYWdlLmNyb3AgJiZcbiAgICAgICAgICBpbWFnZS5jcm9wLmFzcGVjdFJhdGlvICYmXG4gICAgICAgICAgTWF0aC5hYnMoY3JvcC5hc3BlY3RSYXRpbyAtIGltYWdlLmNyb3AuYXNwZWN0UmF0aW8pID4gMC4wMDAwMVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgX2ltYWdlVmlldyA9IHNoaWZ0SW1hZ2UoeyByb290OiByb290IH0pO1xuICAgICAgICAgIHB1c2hJbWFnZSh7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgaW1hZ2U6IGNsb25lQ2FudmFzKF9pbWFnZVZpZXcuaW1hZ2UpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90LCB3ZSBjYW4gdXBkYXRlIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZUltYWdlKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjYW5DcmVhdGVJbWFnZUJpdG1hcCA9IGZ1bmN0aW9uIGNhbkNyZWF0ZUltYWdlQml0bWFwKGZpbGUpIHtcbiAgICAgIC8vIEZpcmVmb3ggdmVyc2lvbnMgYmVmb3JlIDU4IHdpbGwgZnJlZXplIHdoZW4gcnVubmluZyBjcmVhdGVJbWFnZUJpdG1hcFxuICAgICAgLy8gaW4gYSBXZWIgV29ya2VyIHNvIHdlIGRldGVjdCB0aG9zZSB2ZXJzaW9ucyBhbmQgcmV0dXJuIGZhbHNlIGZvciBzdXBwb3J0XG4gICAgICB2YXIgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICB2YXIgaXNGaXJlZm94ID0gdXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKTtcbiAgICAgIHZhciBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IHBhcnNlSW50KGlzRmlyZWZveFsxXSkgOiBudWxsO1xuICAgICAgaWYgKGZpcmVmb3hWZXJzaW9uIDw9IDU4KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiAnY3JlYXRlSW1hZ2VCaXRtYXAnIGluIHdpbmRvdyAmJiBpc0JpdG1hcChmaWxlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgaGFuZGxlciBmb3Igd2hlbiBwcmV2aWV3IGNvbnRhaW5lciBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICovXG4gICAgdmFyIGRpZENyZWF0ZVByZXZpZXdDb250YWluZXIgPSBmdW5jdGlvbiBkaWRDcmVhdGVQcmV2aWV3Q29udGFpbmVyKF9yZWY1KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjUucHJvcHM7XG4gICAgICB2YXIgaWQgPSBwcm9wcy5pZDtcblxuICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIGZpbGUgZGF0YSB0byBkZXRlcm1pbmUgdGhlIGV2ZW50dWFsIGltYWdlIHNpemVcbiAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBpZCk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgLy8gZ2V0IHVybCB0byBmaWxlICh3ZSdsbCByZXZva2UgaXQgbGF0ZXIgb24gd2hlbiBkb25lKVxuICAgICAgdmFyIGZpbGVVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGl0ZW0uZmlsZSk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpbWFnZSBzaXplIG9mIHRoaXMgaXRlbVxuICAgICAgZ2V0SW1hZ2VTaXplKGZpbGVVUkwsIGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG5vdyBzY2FsZSB0aGUgcGFuZWwgdG8gdGhlIGZpbmFsIHNpemVcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0lNQUdFX1BSRVZJRVdfQ0FMQ1VMQVRFX1NJWkUnLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1ByZXZpZXcgPSBmdW5jdGlvbiBkcmF3UHJldmlldyhfcmVmNikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzO1xuICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBmaWxlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoZSBldmVudHVhbCBpbWFnZSBzaXplXG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgaWQpO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgIC8vIGdldCB1cmwgdG8gZmlsZSAod2UnbGwgcmV2b2tlIGl0IGxhdGVyIG9uIHdoZW4gZG9uZSlcbiAgICAgIHZhciBmaWxlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpdGVtLmZpbGUpO1xuXG4gICAgICAvLyBmYWxsYmFja1xuICAgICAgdmFyIGxvYWRQcmV2aWV3RmFsbGJhY2sgPSBmdW5jdGlvbiBsb2FkUHJldmlld0ZhbGxiYWNrKCkge1xuICAgICAgICAvLyBsZXQncyBzY2FsZSB0aGUgaW1hZ2UgaW4gdGhlIG1haW4gdGhyZWFkIDooXG4gICAgICAgIGxvYWRJbWFnZShmaWxlVVJMKS50aGVuKHByZXZpZXdJbWFnZUxvYWRlZCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBpbWFnZSBpcyBub3cgcmVhZHlcbiAgICAgIHZhciBwcmV2aWV3SW1hZ2VMb2FkZWQgPSBmdW5jdGlvbiBwcmV2aWV3SW1hZ2VMb2FkZWQoaW1hZ2VEYXRhKSB7XG4gICAgICAgIC8vIHRoZSBmaWxlIHVybCBpcyBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZVVSTCk7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgc2NhbGVkIGRvd24gdmVyc2lvbiBoZXJlIGFuZCB1c2UgdGhhdCBhcyBzb3VyY2Ugc28gYml0bWFwZGF0YSBjYW4gYmUgY2xvc2VkXG4gICAgICAgIC8vIG9yaWVudGF0aW9uIGluZm9cbiAgICAgICAgdmFyIGV4aWYgPSBpdGVtLmdldE1ldGFkYXRhKCdleGlmJykgfHwge307XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IGV4aWYub3JpZW50YXRpb24gfHwgLTE7XG5cbiAgICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBhY3Rpb24sIGFuZCBzd2FwIGlmIG9yaWVudGF0aW9uIGlzIGluY29ycmVjdFxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgICAvLyBpZiBubyB3aWR0aCBvciBoZWlnaHQsIGp1c3QgcmV0dXJuIGVhcmx5LlxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHJldHVybjtcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgICAgICAgdmFyIF9yZWY3ID0gW2hlaWdodCwgd2lkdGhdO1xuICAgICAgICAgIHdpZHRoID0gX3JlZjdbMF07XG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjdbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FsZSBjYW52YXMgYmFzZWQgb24gcGl4ZWwgZGVuc2l0eVxuICAgICAgICAvLyB3ZSBtdWx0aXBseSBieSAuNzUgYXMgdGhhdCBjcmVhdGVzIHNtYWxsZXIgYnV0IHN0aWxsIGNsZWFyIGltYWdlcyBvbiBzY3JlZW5zIHdpdGggaGlnaCByZXMgZGlzcGxheXNcbiAgICAgICAgdmFyIHBpeGVsRGVuc2l0eUZhY3RvciA9IE1hdGgubWF4KDEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMC43NSk7XG5cbiAgICAgICAgLy8gd2Ugd2FudCBhcyBtdWNoIHBpeGVscyB0byB3b3JrIHdpdGggYXMgcG9zc2libGUsXG4gICAgICAgIC8vIHRoaXMgbXVsdGlwbGllcyB0aGUgbWluaW11bSBpbWFnZSByZXNvbHV0aW9uLFxuICAgICAgICAvLyBzbyB3aGVuIHpvb21pbmcgaW4gaXQgZG9lc24ndCBnZXQgdG9vIGJsdXJyeVxuICAgICAgICB2YXIgem9vbUZhY3RvciA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX1pPT01fRkFDVE9SJyk7XG5cbiAgICAgICAgLy8gaW1hZWcgc2NhbGUgZmFjdG9yXG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHpvb21GYWN0b3IgKiBwaXhlbERlbnNpdHlGYWN0b3I7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNjYWxlZCBwcmV2aWV3IGltYWdlIHNpemVcbiAgICAgICAgdmFyIHByZXZpZXdJbWFnZVJhdGlvID0gaGVpZ2h0IC8gd2lkdGg7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGltYWdlIHByZXZpZXcgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICB2YXIgcHJldmlld0NvbnRhaW5lcldpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgIHZhciBwcmV2aWV3Q29udGFpbmVySGVpZ2h0ID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBpbWFnZVdpZHRoID0gcHJldmlld0NvbnRhaW5lcldpZHRoO1xuICAgICAgICB2YXIgaW1hZ2VIZWlnaHQgPSBpbWFnZVdpZHRoICogcHJldmlld0ltYWdlUmF0aW87XG5cbiAgICAgICAgaWYgKHByZXZpZXdJbWFnZVJhdGlvID4gMSkge1xuICAgICAgICAgIGltYWdlV2lkdGggPSBNYXRoLm1pbih3aWR0aCwgcHJldmlld0NvbnRhaW5lcldpZHRoICogc2NhbGVGYWN0b3IpO1xuICAgICAgICAgIGltYWdlSGVpZ2h0ID0gaW1hZ2VXaWR0aCAqIHByZXZpZXdJbWFnZVJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlSGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBwcmV2aWV3Q29udGFpbmVySGVpZ2h0ICogc2NhbGVGYWN0b3IpO1xuICAgICAgICAgIGltYWdlV2lkdGggPSBpbWFnZUhlaWdodCAvIHByZXZpZXdJbWFnZVJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmZXIgdG8gaW1hZ2UgdGFnIHNvIG5vIGNhbnZhcyBtZW1vcnkgd2FzdGVkIG9uIGlPU1xuICAgICAgICB2YXIgcHJldmlld0ltYWdlID0gY3JlYXRlUHJldmlld0ltYWdlKFxuICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICBpbWFnZVdpZHRoLFxuICAgICAgICAgIGltYWdlSGVpZ2h0LFxuICAgICAgICAgIG9yaWVudGF0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZG9uZVxuICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgaW1hZ2UgY29sb3IsIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgICB2YXIgYXZlcmFnZUNvbG9yID0gcm9vdC5xdWVyeShcbiAgICAgICAgICAgICdHRVRfSU1BR0VfUFJFVklFV19DQUxDVUxBVEVfQVZFUkFHRV9JTUFHRV9DT0xPUidcbiAgICAgICAgICApXG4gICAgICAgICAgICA/IGNhbGN1bGF0ZUF2ZXJhZ2VDb2xvcihkYXRhKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoJ2NvbG9yJywgYXZlcmFnZUNvbG9yLCB0cnVlKTtcblxuICAgICAgICAgIC8vIGRhdGEgaGFzIGJlZW4gdHJhbnNmZXJyZWQgdG8gY2FudmFzICggaWYgd2FzIEltYWdlQml0bWFwIClcbiAgICAgICAgICBpZiAoJ2Nsb3NlJyBpbiBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGltYWdlRGF0YS5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNob3cgdGhlIG92ZXJsYXlcbiAgICAgICAgICByb290LnJlZi5vdmVybGF5U2hhZG93Lm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBmaXJzdCBpbWFnZVxuICAgICAgICAgIHB1c2hJbWFnZSh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgaW1hZ2U6IHByZXZpZXdJbWFnZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhcHBseSBmaWx0ZXJcbiAgICAgICAgdmFyIGZpbHRlciA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2ZpbHRlcicpO1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgYXBwbHlGaWx0ZXIocm9vdCwgZmlsdGVyLCBwcmV2aWV3SW1hZ2UpLnRoZW4oZG9uZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBpZiB3ZSBzdXBwb3J0IHNjYWxpbmcgdXNpbmcgY3JlYXRlSW1hZ2VCaXRtYXAgd2UgdXNlIGEgd29ya2VyXG4gICAgICBpZiAoY2FuQ3JlYXRlSW1hZ2VCaXRtYXAoaXRlbS5maWxlKSkge1xuICAgICAgICAvLyBsZXQncyBzY2FsZSB0aGUgaW1hZ2UgaW4gYSB3b3JrZXJcbiAgICAgICAgdmFyIHdvcmtlciA9IGNyZWF0ZVdvcmtlcihCaXRtYXBXb3JrZXIpO1xuXG4gICAgICAgIHdvcmtlci5wb3N0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpbGU6IGl0ZW0uZmlsZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgLy8gZGVzdHJveSB3b3JrZXJcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgICAgICAgLy8gbm8gYml0bWFwIHJldHVybmVkLCBtdXN0IGJlIHNvbWV0aGluZyB3cm9uZyxcbiAgICAgICAgICAgIC8vIHRyeSB0aGUgb2xkc2Nob29sIHdheVxuICAgICAgICAgICAgaWYgKCFpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgICBsb2FkUHJldmlld0ZhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8geWF5IHdlIGdvdCBvdXIgYml0bWFwLCBsZXQncyBjb250aW51ZSBzaG93aW5nIHRoZSBwcmV2aWV3XG4gICAgICAgICAgICBwcmV2aWV3SW1hZ2VMb2FkZWQoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBmYWxsYmFjayBwcmV2aWV3XG4gICAgICAgIGxvYWRQcmV2aWV3RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgaGFuZGxlciBmb3Igd2hlbiB0aGUgcHJldmlldyBpbWFnZSBpcyByZWFkeSB0byBiZSBhbmltYXRlZFxuICAgICAqL1xuICAgIHZhciBkaWREcmF3UHJldmlldyA9IGZ1bmN0aW9uIGRpZERyYXdQcmV2aWV3KF9yZWY4KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3Q7XG4gICAgICAvLyBnZXQgbGFzdCBhZGRlZCBpbWFnZVxuICAgICAgdmFyIGltYWdlID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGltYWdlLnRyYW5zbGF0ZVkgPSAwO1xuICAgICAgaW1hZ2Uuc2NhbGVYID0gMS4wO1xuICAgICAgaW1hZ2Uuc2NhbGVZID0gMS4wO1xuICAgICAgaW1hZ2Uub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyaXRlIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHByZXZpZXcgaGFzIGJlZW4gbG9hZGVkXG4gICAgICovXG4gICAgdmFyIHJlc3RvcmVPdmVybGF5ID0gZnVuY3Rpb24gcmVzdG9yZU92ZXJsYXkoX3JlZjkpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDE7XG4gICAgICByb290LnJlZi5vdmVybGF5RXJyb3Iub3BhY2l0eSA9IDA7XG4gICAgICByb290LnJlZi5vdmVybGF5U3VjY2Vzcy5vcGFjaXR5ID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFRocm93RXJyb3IgPSBmdW5jdGlvbiBkaWRUaHJvd0Vycm9yKF9yZWYxMCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDAuMjU7XG4gICAgICByb290LnJlZi5vdmVybGF5RXJyb3Iub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIHZhciBkaWRDb21wbGV0ZVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRDb21wbGV0ZVByb2Nlc3NpbmcoX3JlZjExKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMS5yb290O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMC4yNTtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTdWNjZXNzLm9wYWNpdHkgPSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZjEyKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMi5yb290O1xuICAgICAgLy8gaW1hZ2Ugdmlld1xuICAgICAgcm9vdC5yZWYuaW1hZ2VzID0gW107XG5cbiAgICAgIC8vIHRoZSBwcmV2aWV3IGltYWdlIGRhdGEgKHdlIG5lZWQgdGhpcyB0byBmaWx0ZXIgdGhlIGltYWdlKVxuICAgICAgcm9vdC5yZWYuaW1hZ2VEYXRhID0gbnVsbDtcblxuICAgICAgLy8gaW1hZ2UgYmluXG4gICAgICByb290LnJlZi5pbWFnZVZpZXdCaW4gPSBbXTtcblxuICAgICAgLy8gaW1hZ2Ugb3ZlcmxheXNcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoT3ZlcmxheVZpZXcsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHN0YXR1czogJ2lkbGUnXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByb290LnJlZi5vdmVybGF5U3VjY2VzcyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhPdmVybGF5Vmlldywge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhPdmVybGF5Vmlldywge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgc3RhdHVzOiAnZmFpbHVyZSdcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLXByZXZpZXctd3JhcHBlcicsXG4gICAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICAgIHN0eWxlczogWydoZWlnaHQnXSxcbiAgICAgIGFwaXM6IFsnaGVpZ2h0J10sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYxMy5yb290O1xuICAgICAgICAvLyB3ZSByZXNpemUgdGhlIGltYWdlIHNvIG1lbW9yeSBvbiBpT1MgMTIgaXMgcmVsZWFzZWQgbW9yZSBxdWlja2x5IChpdCBzZWVtcylcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24oaW1hZ2VWaWV3KSB7XG4gICAgICAgICAgaW1hZ2VWaWV3LmltYWdlLndpZHRoID0gMTtcbiAgICAgICAgICBpbWFnZVZpZXcuaW1hZ2UuaGVpZ2h0ID0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGlkV3JpdGVWaWV3OiBmdW5jdGlvbiBkaWRXcml0ZVZpZXcoX3JlZjE0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjE0LnJvb3Q7XG4gICAgICAgIHJvb3QucmVmLmltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKGltYWdlVmlldykge1xuICAgICAgICAgIGltYWdlVmlldy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogXy51dGlscy5jcmVhdGVSb3V0ZShcbiAgICAgICAge1xuICAgICAgICAgIC8vIGltYWdlIHByZXZpZXcgc3RhdGVkXG4gICAgICAgICAgRElEX0lNQUdFX1BSRVZJRVdfRFJBVzogZGlkRHJhd1ByZXZpZXcsXG4gICAgICAgICAgRElEX0lNQUdFX1BSRVZJRVdfQ09OVEFJTkVSX0NSRUFURTogZGlkQ3JlYXRlUHJldmlld0NvbnRhaW5lcixcbiAgICAgICAgICBESURfRklOSVNIX0NBTENVTEFURV9QUkVWSUVXU0laRTogZHJhd1ByZXZpZXcsXG4gICAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEFEQVRBOiBkaWRVcGRhdGVJdGVtTWV0YWRhdGEsXG5cbiAgICAgICAgICAvLyBmaWxlIHN0YXRlc1xuICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGRpZFRocm93RXJyb3IsXG4gICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogZGlkVGhyb3dFcnJvcixcbiAgICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGRpZENvbXBsZXRlUHJvY2Vzc2luZyxcbiAgICAgICAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiByZXN0b3JlT3ZlcmxheSxcbiAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogcmVzdG9yZU92ZXJsYXlcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbihfcmVmMTUpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxNS5yb290O1xuICAgICAgICAgIC8vIHZpZXdzIG9uIGRlYXRoIHJvd1xuICAgICAgICAgIHZhciB2aWV3c1RvUmVtb3ZlID0gcm9vdC5yZWYuaW1hZ2VWaWV3QmluLmZpbHRlcihmdW5jdGlvbihpbWFnZVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVZpZXcub3BhY2l0eSA9PT0gMDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHZpZXdzIHRvIHJldGFpblxuICAgICAgICAgIHJvb3QucmVmLmltYWdlVmlld0JpbiA9IHJvb3QucmVmLmltYWdlVmlld0Jpbi5maWx0ZXIoZnVuY3Rpb24oXG4gICAgICAgICAgICBpbWFnZVZpZXdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVZpZXcub3BhY2l0eSA+IDA7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdGhlc2Ugdmlld3NcbiAgICAgICAgICB2aWV3c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24oaW1hZ2VWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlSW1hZ2VWaWV3KHJvb3QsIGltYWdlVmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlld3NUb1JlbW92ZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEltYWdlIFByZXZpZXcgUGx1Z2luXG4gICAqL1xuICB2YXIgcGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKGZwQVBJKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IGZwQVBJLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gZnBBUEkudXRpbHM7XG4gICAgdmFyIFR5cGUgPSB1dGlscy5UeXBlLFxuICAgICAgY3JlYXRlUm91dGUgPSB1dGlscy5jcmVhdGVSb3V0ZSxcbiAgICAgIGlzRmlsZSA9IHV0aWxzLmlzRmlsZTtcblxuICAgIC8vIGltYWdlUHJldmlld1ZpZXdcbiAgICB2YXIgaW1hZ2VQcmV2aWV3VmlldyA9IGNyZWF0ZUltYWdlV3JhcHBlclZpZXcoZnBBUEkpO1xuXG4gICAgLy8gY2FsbGVkIGZvciBlYWNoIHZpZXcgdGhhdCBpcyBjcmVhdGVkIHJpZ2h0IGFmdGVyIHRoZSAnY3JlYXRlJyBtZXRob2RcbiAgICBhZGRGaWx0ZXIoJ0NSRUFURV9WSUVXJywgZnVuY3Rpb24odmlld0FQSSkge1xuICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjcmVhdGVkIHZpZXdcbiAgICAgIHZhciBpcyA9IHZpZXdBUEkuaXMsXG4gICAgICAgIHZpZXcgPSB2aWV3QVBJLnZpZXcsXG4gICAgICAgIHF1ZXJ5ID0gdmlld0FQSS5xdWVyeTtcblxuICAgICAgLy8gb25seSBob29rIHVwIHRvIGl0ZW0gdmlldyBhbmQgb25seSBpZiBpcyBlbmFibGVkIGZvciB0aGlzIGNyb3BwZXJcbiAgICAgIGlmICghaXMoJ2ZpbGUnKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9QUkVWSUVXJykpIHJldHVybjtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBpbWFnZSBwcmV2aWV3IHBsdWdpbiwgYnV0IG9ubHkgZG8gc28gaWYgdGhlIGl0ZW0gaXMgYW4gaW1hZ2VcbiAgICAgIHZhciBkaWRMb2FkSXRlbSA9IGZ1bmN0aW9uIGRpZExvYWRJdGVtKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICB2YXIgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWVyeSgnR0VUX0lURU0nLCBpZCk7XG5cbiAgICAgICAgLy8gaXRlbSBjb3VsZCB0aGVvcmV0aWNhbGx5IGhhdmUgYmVlbiByZW1vdmVkIGluIHRoZSBtZWFuIHRpbWVcbiAgICAgICAgaWYgKCFpdGVtIHx8ICFpc0ZpbGUoaXRlbS5maWxlKSB8fCBpdGVtLmFyY2hpdmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBmaWxlIG9iamVjdFxuICAgICAgICB2YXIgZmlsZSA9IGl0ZW0uZmlsZTtcblxuICAgICAgICAvLyBleGl0IGlmIHRoaXMgaXMgbm90IGFuIGltYWdlXG4gICAgICAgIGlmICghaXNQcmV2aWV3YWJsZUltYWdlKGZpbGUpKSByZXR1cm47XG5cbiAgICAgICAgLy8gdGVzdCBpZiBpcyBmaWx0ZXJlZFxuICAgICAgICBpZiAoIXF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19GSUxURVJfSVRFTScpKGl0ZW0pKSByZXR1cm47XG5cbiAgICAgICAgLy8gZXhpdCBpZiBpbWFnZSBzaXplIGlzIHRvbyBoaWdoIGFuZCBubyBjcmVhdGVJbWFnZUJpdG1hcCBzdXBwb3J0XG4gICAgICAgIC8vIHRoaXMgd291bGQgc2ltcGx5IGJyaW5nIHRoZSBicm93c2VyIHRvIGl0cyBrbmVlcyBhbmQgdGhhdCBpcyBub3Qgd2hhdCB3ZSB3YW50XG4gICAgICAgIHZhciBzdXBwb3J0c0NyZWF0ZUltYWdlQml0bWFwID0gJ2NyZWF0ZUltYWdlQml0bWFwJyBpbiAod2luZG93IHx8IHt9KTtcbiAgICAgICAgdmFyIG1heFByZXZpZXdGaWxlU2l6ZSA9IHF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc3VwcG9ydHNDcmVhdGVJbWFnZUJpdG1hcCAmJlxuICAgICAgICAgIG1heFByZXZpZXdGaWxlU2l6ZSAmJlxuICAgICAgICAgIGZpbGUuc2l6ZSA+IG1heFByZXZpZXdGaWxlU2l6ZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCBwcmV2aWV3IHZpZXdcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VQcmV2aWV3ID0gdmlldy5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgdmlldy5jcmVhdGVDaGlsZFZpZXcoaW1hZ2VQcmV2aWV3VmlldywgeyBpZDogaWQgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgaGVpZ2h0IGlmIGlzIGZpeGVkXG4gICAgICAgIHZhciBmaXhlZFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19IRUlHSFQnKTtcbiAgICAgICAgaWYgKGZpeGVkUHJldmlld0hlaWdodCkge1xuICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9VUERBVEVfUEFORUxfSEVJR0hUJywge1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBoZWlnaHQ6IGZpeGVkUHJldmlld0hlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHJlYWR5XG4gICAgICAgIHZhciBxdWV1ZSA9XG4gICAgICAgICAgIXN1cHBvcnRzQ3JlYXRlSW1hZ2VCaXRtYXAgJiZcbiAgICAgICAgICBmaWxlLnNpemUgPiBxdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFYX0lOU1RBTlRfUFJFVklFV19GSUxFX1NJWkUnKTtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0lNQUdFX1BSRVZJRVdfQ09OVEFJTkVSX0NSRUFURScsIHsgaWQ6IGlkIH0sIHF1ZXVlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXNjYWxlSXRlbSA9IGZ1bmN0aW9uIHJlc2NhbGVJdGVtKHJvb3QsIHByb3BzKSB7XG4gICAgICAgIGlmICghcm9vdC5yZWYuaW1hZ2VQcmV2aWV3KSByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgICAgIC8vIGdldCBpdGVtXG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgICAgLy8gaWYgaXMgZml4ZWQgaGVpZ2h0IG9yIHBhbmVsIGhhcyBhc3BlY3QgcmF0aW8sIGV4aXQgaGVyZSwgaGVpZ2h0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZFxuICAgICAgICB2YXIgcGFuZWxBc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgdmFyIGl0ZW1QYW5lbEFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIHZhciBmaXhlZEhlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgICBpZiAocGFuZWxBc3BlY3RSYXRpbyB8fCBpdGVtUGFuZWxBc3BlY3RSYXRpbyB8fCBmaXhlZEhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIG5vIGRhdGEhXG4gICAgICAgIHZhciBfcm9vdCRyZWYgPSByb290LnJlZixcbiAgICAgICAgICBpbWFnZVdpZHRoID0gX3Jvb3QkcmVmLmltYWdlV2lkdGgsXG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBfcm9vdCRyZWYuaW1hZ2VIZWlnaHQ7XG4gICAgICAgIGlmICghaW1hZ2VXaWR0aCB8fCAhaW1hZ2VIZWlnaHQpIHJldHVybjtcblxuICAgICAgICAvLyBnZXQgaGVpZ2h0IG1pbiBhbmQgbWF4XG4gICAgICAgIHZhciBtaW5QcmV2aWV3SGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUlOX0hFSUdIVCcpO1xuICAgICAgICB2YXIgbWF4UHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BWF9IRUlHSFQnKTtcblxuICAgICAgICAvLyBvcmllbnRhdGlvbiBpbmZvXG4gICAgICAgIHZhciBleGlmID0gaXRlbS5nZXRNZXRhZGF0YSgnZXhpZicpIHx8IHt9O1xuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBleGlmLm9yaWVudGF0aW9uIHx8IC0xO1xuXG4gICAgICAgIC8vIGdldCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gYWN0aW9uLCBhbmQgc3dhcCBvZiBvcmllbnRhdGlvbiBpcyBpbmNvcnJlY3RcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID49IDUgJiYgb3JpZW50YXRpb24gPD0gOCkge1xuICAgICAgICAgIHZhciBfcmVmMiA9IFtpbWFnZUhlaWdodCwgaW1hZ2VXaWR0aF07XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IF9yZWYyWzBdO1xuICAgICAgICAgIGltYWdlSGVpZ2h0ID0gX3JlZjJbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FsZSB1cCB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gd2UncmUgZGVhbGluZyB3aXRoIGFuIFNWR1xuICAgICAgICBpZiAoIWlzQml0bWFwKGl0ZW0uZmlsZSkgfHwgcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfVVBTQ0FMRScpKSB7XG4gICAgICAgICAgdmFyIHNjYWxhciA9IDIwNDggLyBpbWFnZVdpZHRoO1xuICAgICAgICAgIGltYWdlV2lkdGggKj0gc2NhbGFyO1xuICAgICAgICAgIGltYWdlSGVpZ2h0ICo9IHNjYWxhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGltYWdlIGFzcGVjdCByYXRpb1xuICAgICAgICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlSGVpZ2h0IC8gaW1hZ2VXaWR0aDtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRoZSBpdGVtIHRvIGdldCB0byB0aGUgY3JvcCBzaXplXG4gICAgICAgIHZhciBwcmV2aWV3QXNwZWN0UmF0aW8gPVxuICAgICAgICAgIChpdGVtLmdldE1ldGFkYXRhKCdjcm9wJykgfHwge30pLmFzcGVjdFJhdGlvIHx8IGltYWdlQXNwZWN0UmF0aW87XG5cbiAgICAgICAgLy8gcHJldmlldyBoZWlnaHQgcmFuZ2VcbiAgICAgICAgdmFyIHByZXZpZXdIZWlnaHRNYXggPSBNYXRoLm1heChcbiAgICAgICAgICBtaW5QcmV2aWV3SGVpZ2h0LFxuICAgICAgICAgIE1hdGgubWluKGltYWdlSGVpZ2h0LCBtYXhQcmV2aWV3SGVpZ2h0KVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBpdGVtV2lkdGggPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIHByZXZpZXdIZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICBpdGVtV2lkdGggKiBwcmV2aWV3QXNwZWN0UmF0aW8sXG4gICAgICAgICAgcHJldmlld0hlaWdodE1heFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJlcXVlc3QgdXBkYXRlIHRvIHBhbmVsIGhlaWdodFxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfVVBEQVRFX1BBTkVMX0hFSUdIVCcsIHtcbiAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICBoZWlnaHQ6IHByZXZpZXdIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlkUmVzaXplVmlldyA9IGZ1bmN0aW9uIGRpZFJlc2l6ZVZpZXcoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290O1xuICAgICAgICAvLyBhY3Rpb25zIGluIG5leHQgd3JpdGUgb3BlcmF0aW9uXG4gICAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSA9IGZ1bmN0aW9uIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgICBpZiAoYWN0aW9uLmNoYW5nZS5rZXkgIT09ICdjcm9wJykgcmV0dXJuO1xuXG4gICAgICAgIC8vIGFjdGlvbnMgaW4gbmV4dCB3cml0ZSBvcGVyYXRpb25cbiAgICAgICAgcm9vdC5yZWYuc2hvdWxkUmVzY2FsZSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlkQ2FsY3VsYXRlUHJldmlld1NpemUgPSBmdW5jdGlvbiBkaWRDYWxjdWxhdGVQcmV2aWV3U2l6ZShfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgYWN0aW9uID0gX3JlZjUuYWN0aW9uO1xuICAgICAgICAvLyByZW1lbWJlciBkaW1lbnNpb25zXG4gICAgICAgIHJvb3QucmVmLmltYWdlV2lkdGggPSBhY3Rpb24ud2lkdGg7XG4gICAgICAgIHJvb3QucmVmLmltYWdlSGVpZ2h0ID0gYWN0aW9uLmhlaWdodDtcblxuICAgICAgICAvLyBhY3Rpb25zIGluIG5leHQgd3JpdGUgb3BlcmF0aW9uXG4gICAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSB0cnVlO1xuICAgICAgICByb290LnJlZi5zaG91bGREcmF3UHJldmlldyA9IHRydWU7XG5cbiAgICAgICAgLy8gYXMgaW1hZ2UgbG9hZCBjb3VsZCB0YWtlIGEgd2hpbGUgYW5kIGZpcmUgd2hlbiBkcmF3IGxvb3AgaXMgcmVzdGluZyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBraWNrXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0tJQ0snKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHN0YXJ0IHdyaXRpbmdcbiAgICAgIHZpZXcucmVnaXN0ZXJXcml0ZXIoXG4gICAgICAgIGNyZWF0ZVJvdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIERJRF9SRVNJWkVfUk9PVDogZGlkUmVzaXplVmlldyxcbiAgICAgICAgICAgIERJRF9TVE9QX1JFU0laRTogZGlkUmVzaXplVmlldyxcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtLFxuICAgICAgICAgICAgRElEX0lNQUdFX1BSRVZJRVdfQ0FMQ1VMQVRFX1NJWkU6IGRpZENhbGN1bGF0ZVByZXZpZXdTaXplLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEFEQVRBOiBkaWRVcGRhdGVJdGVtTWV0YWRhdGFcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmNi5wcm9wcztcbiAgICAgICAgICAgIC8vIG5vIHByZXZpZXcgdmlldyBhdHRhY2hlZFxuICAgICAgICAgICAgaWYgKCFyb290LnJlZi5pbWFnZVByZXZpZXcpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgd2hpbGUgaGlkZGVuXG4gICAgICAgICAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHJlc2l6ZSB0aGUgaXRlbSBwYW5lbFxuICAgICAgICAgICAgaWYgKHJvb3QucmVmLnNob3VsZFJlc2NhbGUpIHtcbiAgICAgICAgICAgICAgcmVzY2FsZUl0ZW0ocm9vdCwgcHJvcHMpO1xuICAgICAgICAgICAgICByb290LnJlZi5zaG91bGRSZXNjYWxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyb290LnJlZi5zaG91bGREcmF3UHJldmlldykge1xuICAgICAgICAgICAgICAvLyBxdWV1ZSB0aWxsIG5leHQgZnJhbWUgc28gd2UncmUgc3VyZSB0aGUgaGVpZ2h0IGhhcyBiZWVuIGFwcGxpZWQgdGhpcyBmb3JjZXMgdGhlIGRyYXcgaW1hZ2UgY2FsbCBpbnNpZGUgdGhlIHdyYXBwZXIgdmlldyB0byB1c2UgdGhlIGNvcnJlY3QgaGVpZ2h0XG4gICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBuZXN0aW5nIGlzIGhvcnJpYmxlIGJ1dCBpdCBmaXhlcyBhbiBpc3N1ZSB3aXRoIDEwMGh6IGRpc3BsYXlzIG9uIENocm9tZVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcWluYS9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9pc3N1ZXMvNTdcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRklOSVNIX0NBTENVTEFURV9QUkVWSUVXU0laRScsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHByb3BzLmlkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcm9vdC5yZWYuc2hvdWxkRHJhd1ByZXZpZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgcGx1Z2luXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgaW1hZ2UgcHJldmlld1xuICAgICAgICBhbGxvd0ltYWdlUHJldmlldzogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gZmlsdGVycyBmaWxlIGl0ZW1zIHRvIGRldGVybWluZSB3aGljaCBhcmUgc2hvd24gYXMgcHJldmlld1xuICAgICAgICBpbWFnZVByZXZpZXdGaWx0ZXJJdGVtOiBbXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFR5cGUuRlVOQ1RJT05cbiAgICAgICAgXSxcblxuICAgICAgICAvLyBGaXhlZCBwcmV2aWV3IGhlaWdodFxuICAgICAgICBpbWFnZVByZXZpZXdIZWlnaHQ6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWluIGltYWdlIGhlaWdodFxuICAgICAgICBpbWFnZVByZXZpZXdNaW5IZWlnaHQ6IFs0NCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIE1heCBpbWFnZSBoZWlnaHRcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWF4SGVpZ2h0OiBbMjU2LCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWF4IHNpemUgb2YgcHJldmlldyBmaWxlIGZvciB3aGVuIGNyZWF0ZUltYWdlQml0bWFwIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWF4RmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBleHRyYSBwaXhlbHMgYWRkZWQgdG8gdGhlIGltYWdlIHByZXZpZXcgdG8gYWxsb3cgY29tZm9ydGFibGUgem9vbWluZ1xuICAgICAgICBpbWFnZVByZXZpZXdab29tRmFjdG9yOiBbMiwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIFNob3VsZCB3ZSB1cHNjYWxlIHNtYWxsIGltYWdlcyB0byBmaXQgdGhlIG1heCBib3VuZGluZyBib3ggb2YgdGhlIHByZXZpZXcgYXJlYVxuICAgICAgICBpbWFnZVByZXZpZXdVcHNjYWxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gTWF4IHNpemUgb2YgcHJldmlldyBmaWxlIHRoYXQgd2UgYWxsb3cgdG8gdHJ5IHRvIGluc3RhbnQgcHJldmlldyBpZiBjcmVhdGVJbWFnZUJpdG1hcCBpcyBub3Qgc3VwcG9ydGVkLCBlbHNlIGltYWdlIGlzIHF1ZXVlZCBmb3IgbG9hZGluZ1xuICAgICAgICBpbWFnZVByZXZpZXdNYXhJbnN0YW50UHJldmlld0ZpbGVTaXplOiBbMTAwMDAwMCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIFN0eWxlIG9mIHRoZSB0cmFuc3BhcmFuY3kgaW5kaWNhdG9yIHVzZWQgYmVoaW5kIGltYWdlc1xuICAgICAgICBpbWFnZVByZXZpZXdUcmFuc3BhcmVuY3lJbmRpY2F0b3I6IFtudWxsLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyByZWFkaW5nIGF2ZXJhZ2UgaW1hZ2UgY29sb3JcbiAgICAgICAgaW1hZ2VQcmV2aWV3Q2FsY3VsYXRlQXZlcmFnZUltYWdlQ29sb3I6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBwcmV2aWV3aW5nIG9mIG1hcmt1cFxuICAgICAgICBpbWFnZVByZXZpZXdNYXJrdXBTaG93OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBBbGxvd3MgZmlsdGVyaW5nIG9mIG1hcmt1cCB0byBvbmx5IHNob3cgY2VydGFpbiBzaGFwZXNcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWFya3VwRmlsdGVyOiBbXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFR5cGUuRlVOQ1RJT05cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgdmFyIGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-resize/dist/filepond-plugin-image-resize.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-resize/dist/filepond-plugin-image-resize.js ***!
  \****************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImageResize 2.0.10\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? (module.exports = factory())\n        : 0;\n})(this, function() {\n    'use strict';\n\n    // test if file is of type image\n    var isImage = function isImage(file) {\n        return /^image/.test(file.type);\n    };\n\n    var getImageSize = function getImageSize(url, cb) {\n        var image = new Image();\n        image.onload = function() {\n            var width = image.naturalWidth;\n            var height = image.naturalHeight;\n            image = null;\n            cb({ width: width, height: height });\n        };\n        image.onerror = function() {\n            return cb(null);\n        };\n        image.src = url;\n    };\n\n    /**\n     * Image Auto Resize Plugin\n     */\n    var plugin = function plugin(_ref) {\n        var addFilter = _ref.addFilter,\n            utils = _ref.utils;\n        var Type = utils.Type;\n\n        // subscribe to file load and append required transformations\n        addFilter('DID_LOAD_ITEM', function(item, _ref2) {\n            var query = _ref2.query;\n            return new Promise(function(resolve, reject) {\n                // get file reference\n                var file = item.file;\n\n                // if this is not an image we do not have any business cropping it\n                if (!isImage(file) || !query('GET_ALLOW_IMAGE_RESIZE')) {\n                    // continue with the unaltered dataset\n                    return resolve(item);\n                }\n\n                var mode = query('GET_IMAGE_RESIZE_MODE');\n                var width = query('GET_IMAGE_RESIZE_TARGET_WIDTH');\n                var height = query('GET_IMAGE_RESIZE_TARGET_HEIGHT');\n                var upscale = query('GET_IMAGE_RESIZE_UPSCALE');\n\n                // no resizing to be done\n                if (width === null && height === null) return resolve(item);\n\n                var targetWidth = width === null ? height : width;\n                var targetHeight = height === null ? targetWidth : height;\n\n                // if should not upscale, we need to determine the size of the file\n                var fileURL = URL.createObjectURL(file);\n                getImageSize(fileURL, function(size) {\n                    URL.revokeObjectURL(fileURL);\n\n                    // something went wrong\n                    if (!size) return resolve(item);\n                    var imageWidth = size.width,\n                        imageHeight = size.height;\n\n                    // get exif orientation\n                    var orientation = (item.getMetadata('exif') || {}).orientation || -1;\n\n                    // swap width and height if orientation needs correcting\n                    if (orientation >= 5 && orientation <= 8) {\n                        var _ref3 = [imageHeight, imageWidth];\n                        imageWidth = _ref3[0];\n                        imageHeight = _ref3[1];\n                    }\n\n                    // image is already perfect size, no transformations required\n                    if (imageWidth === targetWidth && imageHeight === targetHeight)\n                        return resolve(item);\n\n                    // already contained?\n                    // can't upscale image, so if already at correct scale, exit\n                    if (!upscale) {\n                        // covering target size\n                        if (mode === 'cover') {\n                            // if one of edges is smaller than target size, exit\n                            if (imageWidth <= targetWidth || imageHeight <= targetHeight)\n                                return resolve(item);\n                        }\n\n                        // not covering target size, if image is contained in target size, exit\n                        else if (imageWidth <= targetWidth && imageHeight <= targetWidth) {\n                            return resolve(item);\n                        }\n                    }\n\n                    // the image needs to be resized\n                    item.setMetadata('resize', {\n                        mode: mode,\n                        upscale: upscale,\n                        size: {\n                            width: targetWidth,\n                            height: targetHeight,\n                        },\n                    });\n\n                    resolve(item);\n                });\n            });\n        });\n\n        // Expose plugin options\n        return {\n            options: {\n                // Enable or disable image resizing\n                allowImageResize: [true, Type.BOOLEAN],\n\n                // the method of rescaling\n                // - force => force set size\n                // - cover => pick biggest dimension\n                // - contain => pick smaller dimension\n                imageResizeMode: ['cover', Type.STRING],\n\n                // set to false to disable upscaling of image smaller than the target width / height\n                imageResizeUpscale: [true, Type.BOOLEAN],\n\n                // target width\n                imageResizeTargetWidth: [null, Type.INT],\n\n                // target height\n                imageResizeTargetHeight: [null, Type.INT],\n            },\n        };\n    };\n\n    // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n    var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    if (isBrowser) {\n        document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n    }\n\n    return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXJlc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1yZXNpemUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEU7QUFDQSxVQUFVLENBRTJFO0FBQ3JGLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCOztBQUVyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcmVzaXplL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXJlc2l6ZS5qcz8zNTA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVJlc2l6ZSAyLjAuMTBcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICAgICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSwgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkltYWdlUmVzaXplID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyB0ZXN0IGlmIGZpbGUgaXMgb2YgdHlwZSBpbWFnZVxuICAgIHZhciBpc0ltYWdlID0gZnVuY3Rpb24gaXNJbWFnZShmaWxlKSB7XG4gICAgICAgIHJldHVybiAvXmltYWdlLy50ZXN0KGZpbGUudHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRJbWFnZVNpemUodXJsLCBjYikge1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgICAgICAgIGNiKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEltYWdlIEF1dG8gUmVzaXplIFBsdWdpblxuICAgICAqL1xuICAgIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgICAgICB2YXIgYWRkRmlsdGVyID0gX3JlZi5hZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlscyA9IF9yZWYudXRpbHM7XG4gICAgICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gZmlsZSBsb2FkIGFuZCBhcHBlbmQgcmVxdWlyZWQgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIGFkZEZpbHRlcignRElEX0xPQURfSVRFTScsIGZ1bmN0aW9uKGl0ZW0sIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmMi5xdWVyeTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGl0ZW0uZmlsZTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGFuIGltYWdlIHdlIGRvIG5vdCBoYXZlIGFueSBidXNpbmVzcyBjcm9wcGluZyBpdFxuICAgICAgICAgICAgICAgIGlmICghaXNJbWFnZShmaWxlKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9SRVNJWkUnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3aXRoIHRoZSB1bmFsdGVyZWQgZGF0YXNldFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IHF1ZXJ5KCdHRVRfSU1BR0VfUkVTSVpFX01PREUnKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBxdWVyeSgnR0VUX0lNQUdFX1JFU0laRV9UQVJHRVRfV0lEVEgnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcXVlcnkoJ0dFVF9JTUFHRV9SRVNJWkVfVEFSR0VUX0hFSUdIVCcpO1xuICAgICAgICAgICAgICAgIHZhciB1cHNjYWxlID0gcXVlcnkoJ0dFVF9JTUFHRV9SRVNJWkVfVVBTQ0FMRScpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gcmVzaXppbmcgdG8gYmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gbnVsbCAmJiBoZWlnaHQgPT09IG51bGwpIHJldHVybiByZXNvbHZlKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFdpZHRoID0gd2lkdGggPT09IG51bGwgPyBoZWlnaHQgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gaGVpZ2h0ID09PSBudWxsID8gdGFyZ2V0V2lkdGggOiBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBzaG91bGQgbm90IHVwc2NhbGUsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgIGdldEltYWdlU2l6ZShmaWxlVVJMLCBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZVVSTCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXplKSByZXR1cm4gcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlV2lkdGggPSBzaXplLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VIZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgZXhpZiBvcmllbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSAoaXRlbS5nZXRNZXRhZGF0YSgnZXhpZicpIHx8IHt9KS5vcmllbnRhdGlvbiB8fCAtMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIHdpZHRoIGFuZCBoZWlnaHQgaWYgb3JpZW50YXRpb24gbmVlZHMgY29ycmVjdGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBbaW1hZ2VIZWlnaHQsIGltYWdlV2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IF9yZWYzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VIZWlnaHQgPSBfcmVmM1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGltYWdlIGlzIGFscmVhZHkgcGVyZmVjdCBzaXplLCBubyB0cmFuc2Zvcm1hdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlV2lkdGggPT09IHRhcmdldFdpZHRoICYmIGltYWdlSGVpZ2h0ID09PSB0YXJnZXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNvbnRhaW5lZD9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgdXBzY2FsZSBpbWFnZSwgc28gaWYgYWxyZWFkeSBhdCBjb3JyZWN0IHNjYWxlLCBleGl0XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY292ZXJpbmcgdGFyZ2V0IHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnY292ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb25lIG9mIGVkZ2VzIGlzIHNtYWxsZXIgdGhhbiB0YXJnZXQgc2l6ZSwgZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVdpZHRoIDw9IHRhcmdldFdpZHRoIHx8IGltYWdlSGVpZ2h0IDw9IHRhcmdldEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjb3ZlcmluZyB0YXJnZXQgc2l6ZSwgaWYgaW1hZ2UgaXMgY29udGFpbmVkIGluIHRhcmdldCBzaXplLCBleGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWFnZVdpZHRoIDw9IHRhcmdldFdpZHRoICYmIGltYWdlSGVpZ2h0IDw9IHRhcmdldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldE1ldGFkYXRhKCdyZXNpemUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBzY2FsZTogdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEV4cG9zZSBwbHVnaW4gb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGltYWdlIHJlc2l6aW5nXG4gICAgICAgICAgICAgICAgYWxsb3dJbWFnZVJlc2l6ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbWV0aG9kIG9mIHJlc2NhbGluZ1xuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2UgPT4gZm9yY2Ugc2V0IHNpemVcbiAgICAgICAgICAgICAgICAvLyAtIGNvdmVyID0+IHBpY2sgYmlnZ2VzdCBkaW1lbnNpb25cbiAgICAgICAgICAgICAgICAvLyAtIGNvbnRhaW4gPT4gcGljayBzbWFsbGVyIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIGltYWdlUmVzaXplTW9kZTogWydjb3ZlcicsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAgICAgICAgIC8vIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIHVwc2NhbGluZyBvZiBpbWFnZSBzbWFsbGVyIHRoYW4gdGhlIHRhcmdldCB3aWR0aCAvIGhlaWdodFxuICAgICAgICAgICAgICAgIGltYWdlUmVzaXplVXBzY2FsZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgd2lkdGhcbiAgICAgICAgICAgICAgICBpbWFnZVJlc2l6ZVRhcmdldFdpZHRoOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodFxuICAgICAgICAgICAgICAgIGltYWdlUmVzaXplVGFyZ2V0SGVpZ2h0OiBbbnVsbCwgVHlwZS5JTlRdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-resize/dist/filepond-plugin-image-resize.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-transform/dist/filepond-plugin-image-transform.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-transform/dist/filepond-plugin-image-transform.js ***!
  \**********************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImageTransform 3.8.7\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? (module.exports = factory())\n        : 0;\n})(this, function() {\n    'use strict';\n\n    // test if file is of type image\n    var isImage = function isImage(file) {\n        return /^image/.test(file.type);\n    };\n\n    var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n        return name.substr(0, name.lastIndexOf('.')) || name;\n    };\n\n    // only handles image/jpg, image/jpeg, image/png, and image/svg+xml for now\n    var ExtensionMap = {\n        jpeg: 'jpg',\n        'svg+xml': 'svg',\n    };\n\n    var renameFileToMatchMimeType = function renameFileToMatchMimeType(filename, mimeType) {\n        var name = getFilenameWithoutExtension(filename);\n        var type = mimeType.split('/')[1];\n        var extension = ExtensionMap[type] || type;\n        return ''.concat(name, '.').concat(extension);\n    };\n\n    // returns all the valid output formats we can encode towards\n    var getValidOutputMimeType = function getValidOutputMimeType(type) {\n        return /jpeg|png|svg\\+xml/.test(type) ? type : 'image/jpeg';\n    };\n\n    // test if file is of type image\n    var isImage$1 = function isImage(file) {\n        return /^image/.test(file.type);\n    };\n\n    var MATRICES = {\n        1: function _() {\n            return [1, 0, 0, 1, 0, 0];\n        },\n        2: function _(width) {\n            return [-1, 0, 0, 1, width, 0];\n        },\n        3: function _(width, height) {\n            return [-1, 0, 0, -1, width, height];\n        },\n        4: function _(width, height) {\n            return [1, 0, 0, -1, 0, height];\n        },\n        5: function _() {\n            return [0, 1, 1, 0, 0, 0];\n        },\n        6: function _(width, height) {\n            return [0, 1, -1, 0, height, 0];\n        },\n        7: function _(width, height) {\n            return [0, -1, -1, 0, height, width];\n        },\n        8: function _(width) {\n            return [0, -1, 1, 0, 0, width];\n        },\n    };\n\n    var getImageOrientationMatrix = function getImageOrientationMatrix(width, height, orientation) {\n        if (orientation === -1) {\n            orientation = 1;\n        }\n        return MATRICES[orientation](width, height);\n    };\n\n    var createVector = function createVector(x, y) {\n        return { x: x, y: y };\n    };\n\n    var vectorDot = function vectorDot(a, b) {\n        return a.x * b.x + a.y * b.y;\n    };\n\n    var vectorSubtract = function vectorSubtract(a, b) {\n        return createVector(a.x - b.x, a.y - b.y);\n    };\n\n    var vectorDistanceSquared = function vectorDistanceSquared(a, b) {\n        return vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));\n    };\n\n    var vectorDistance = function vectorDistance(a, b) {\n        return Math.sqrt(vectorDistanceSquared(a, b));\n    };\n\n    var getOffsetPointOnEdge = function getOffsetPointOnEdge(length, rotation) {\n        var a = length;\n\n        var A = 1.5707963267948966;\n        var B = rotation;\n        var C = 1.5707963267948966 - rotation;\n\n        var sinA = Math.sin(A);\n        var sinB = Math.sin(B);\n        var sinC = Math.sin(C);\n        var cosC = Math.cos(C);\n        var ratio = a / sinA;\n        var b = ratio * sinB;\n        var c = ratio * sinC;\n\n        return createVector(cosC * b, cosC * c);\n    };\n\n    var getRotatedRectSize = function getRotatedRectSize(rect, rotation) {\n        var w = rect.width;\n        var h = rect.height;\n\n        var hor = getOffsetPointOnEdge(w, rotation);\n        var ver = getOffsetPointOnEdge(h, rotation);\n\n        var tl = createVector(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));\n\n        var tr = createVector(rect.x + rect.width + Math.abs(ver.y), rect.y + Math.abs(ver.x));\n\n        var bl = createVector(rect.x - Math.abs(ver.y), rect.y + rect.height - Math.abs(ver.x));\n\n        return {\n            width: vectorDistance(tl, tr),\n            height: vectorDistance(tl, bl),\n        };\n    };\n\n    var getImageRectZoomFactor = function getImageRectZoomFactor(imageRect, cropRect) {\n        var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var center =\n            arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { x: 0.5, y: 0.5 };\n\n        // calculate available space round image center position\n        var cx = center.x > 0.5 ? 1 - center.x : center.x;\n        var cy = center.y > 0.5 ? 1 - center.y : center.y;\n        var imageWidth = cx * 2 * imageRect.width;\n        var imageHeight = cy * 2 * imageRect.height;\n\n        // calculate rotated crop rectangle size\n        var rotatedCropSize = getRotatedRectSize(cropRect, rotation);\n\n        return Math.max(rotatedCropSize.width / imageWidth, rotatedCropSize.height / imageHeight);\n    };\n\n    var getCenteredCropRect = function getCenteredCropRect(container, aspectRatio) {\n        var width = container.width;\n        var height = width * aspectRatio;\n        if (height > container.height) {\n            height = container.height;\n            width = height / aspectRatio;\n        }\n        var x = (container.width - width) * 0.5;\n        var y = (container.height - height) * 0.5;\n\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n        };\n    };\n\n    var calculateCanvasSize = function calculateCanvasSize(image, canvasAspectRatio) {\n        var zoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n        var imageAspectRatio = image.height / image.width;\n\n        // determine actual pixels on x and y axis\n        var canvasWidth = 1;\n        var canvasHeight = canvasAspectRatio;\n        var imgWidth = 1;\n        var imgHeight = imageAspectRatio;\n        if (imgHeight > canvasHeight) {\n            imgHeight = canvasHeight;\n            imgWidth = imgHeight / imageAspectRatio;\n        }\n\n        var scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);\n        var width = image.width / (zoom * scalar * imgWidth);\n        var height = width * canvasAspectRatio;\n\n        return {\n            width: width,\n            height: height,\n        };\n    };\n\n    var canvasRelease = function canvasRelease(canvas) {\n        canvas.width = 1;\n        canvas.height = 1;\n        var ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, 1, 1);\n    };\n\n    var isFlipped = function isFlipped(flip) {\n        return flip && (flip.horizontal || flip.vertical);\n    };\n\n    var getBitmap = function getBitmap(image, orientation, flip) {\n        if (orientation <= 1 && !isFlipped(flip)) {\n            image.width = image.naturalWidth;\n            image.height = image.naturalHeight;\n            return image;\n        }\n\n        var canvas = document.createElement('canvas');\n        var width = image.naturalWidth;\n        var height = image.naturalHeight;\n\n        // if is rotated incorrectly swap width and height\n        var swapped = orientation >= 5 && orientation <= 8;\n        if (swapped) {\n            canvas.width = height;\n            canvas.height = width;\n        } else {\n            canvas.width = width;\n            canvas.height = height;\n        }\n\n        // draw the image but first fix orientation and set correct flip\n        var ctx = canvas.getContext('2d');\n\n        // get base transformation matrix\n        if (orientation) {\n            ctx.transform.apply(ctx, getImageOrientationMatrix(width, height, orientation));\n        }\n\n        if (isFlipped(flip)) {\n            // flip horizontal\n            // [-1, 0, 0, 1, width, 0]\n            var matrix = [1, 0, 0, 1, 0, 0];\n            if ((!swapped && flip.horizontal) || swapped & flip.vertical) {\n                matrix[0] = -1;\n                matrix[4] = width;\n            }\n\n            // flip vertical\n            // [1, 0, 0, -1, 0, height]\n            if ((!swapped && flip.vertical) || (swapped && flip.horizontal)) {\n                matrix[3] = -1;\n                matrix[5] = height;\n            }\n\n            ctx.transform.apply(ctx, matrix);\n        }\n\n        ctx.drawImage(image, 0, 0, width, height);\n\n        return canvas;\n    };\n\n    var imageToImageData = function imageToImageData(imageElement, orientation) {\n        var crop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var canvasMemoryLimit = options.canvasMemoryLimit,\n            _options$background = options.background,\n            background = _options$background === void 0 ? null : _options$background;\n\n        var zoom = crop.zoom || 1;\n\n        // fixes possible image orientation problems by drawing the image on the correct canvas\n        var bitmap = getBitmap(imageElement, orientation, crop.flip);\n        var imageSize = {\n            width: bitmap.width,\n            height: bitmap.height,\n        };\n\n        var aspectRatio = crop.aspectRatio || imageSize.height / imageSize.width;\n\n        var canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n\n        if (canvasMemoryLimit) {\n            var requiredMemory = canvasSize.width * canvasSize.height;\n            if (requiredMemory > canvasMemoryLimit) {\n                var scalar = Math.sqrt(canvasMemoryLimit) / Math.sqrt(requiredMemory);\n                imageSize.width = Math.floor(imageSize.width * scalar);\n                imageSize.height = Math.floor(imageSize.height * scalar);\n                canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n            }\n        }\n\n        var canvas = document.createElement('canvas');\n\n        var canvasCenter = {\n            x: canvasSize.width * 0.5,\n            y: canvasSize.height * 0.5,\n        };\n\n        var stage = {\n            x: 0,\n            y: 0,\n            width: canvasSize.width,\n            height: canvasSize.height,\n            center: canvasCenter,\n        };\n\n        var shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n        var scale =\n            zoom *\n            getImageRectZoomFactor(\n                imageSize,\n                getCenteredCropRect(stage, aspectRatio),\n                crop.rotation,\n                shouldLimit ? crop.center : { x: 0.5, y: 0.5 }\n            );\n\n        // start drawing\n        canvas.width = Math.round(canvasSize.width / scale);\n        canvas.height = Math.round(canvasSize.height / scale);\n\n        canvasCenter.x /= scale;\n        canvasCenter.y /= scale;\n\n        var imageOffset = {\n            x: canvasCenter.x - imageSize.width * (crop.center ? crop.center.x : 0.5),\n            y: canvasCenter.y - imageSize.height * (crop.center ? crop.center.y : 0.5),\n        };\n\n        var ctx = canvas.getContext('2d');\n        if (background) {\n            ctx.fillStyle = background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // move to draw offset\n        ctx.translate(canvasCenter.x, canvasCenter.y);\n        ctx.rotate(crop.rotation || 0);\n\n        // draw the image\n        ctx.drawImage(\n            bitmap,\n            imageOffset.x - canvasCenter.x,\n            imageOffset.y - canvasCenter.y,\n            imageSize.width,\n            imageSize.height\n        );\n\n        // get data from canvas\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n        // release canvas\n        canvasRelease(canvas);\n\n        // return data\n        return imageData;\n    };\n\n    /**\n     * Polyfill toBlob for Edge\n     */\n    var IS_BROWSER = (function() {\n        return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    })();\n    if (IS_BROWSER) {\n        if (!HTMLCanvasElement.prototype.toBlob) {\n            Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n                value: function value(callback, type, quality) {\n                    var dataURL = this.toDataURL(type, quality).split(',')[1];\n                    setTimeout(function() {\n                        var binStr = atob(dataURL);\n                        var len = binStr.length;\n                        var arr = new Uint8Array(len);\n                        for (var i = 0; i < len; i++) {\n                            arr[i] = binStr.charCodeAt(i);\n                        }\n                        callback(new Blob([arr], { type: type || 'image/png' }));\n                    });\n                },\n            });\n        }\n    }\n\n    var canvasToBlob = function canvasToBlob(canvas, options) {\n        var beforeCreateBlob =\n            arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        return new Promise(function(resolve) {\n            var promisedImage = beforeCreateBlob ? beforeCreateBlob(canvas) : canvas;\n            Promise.resolve(promisedImage).then(function(canvas) {\n                canvas.toBlob(resolve, options.type, options.quality);\n            });\n        });\n    };\n\n    var vectorMultiply = function vectorMultiply(v, amount) {\n        return createVector$1(v.x * amount, v.y * amount);\n    };\n\n    var vectorAdd = function vectorAdd(a, b) {\n        return createVector$1(a.x + b.x, a.y + b.y);\n    };\n\n    var vectorNormalize = function vectorNormalize(v) {\n        var l = Math.sqrt(v.x * v.x + v.y * v.y);\n        if (l === 0) {\n            return {\n                x: 0,\n                y: 0,\n            };\n        }\n        return createVector$1(v.x / l, v.y / l);\n    };\n\n    var vectorRotate = function vectorRotate(v, radians, origin) {\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var t = createVector$1(v.x - origin.x, v.y - origin.y);\n        return createVector$1(origin.x + cos * t.x - sin * t.y, origin.y + sin * t.x + cos * t.y);\n    };\n\n    var createVector$1 = function createVector() {\n        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        return { x: x, y: y };\n    };\n\n    var getMarkupValue = function getMarkupValue(value, size) {\n        var scalar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var axis = arguments.length > 3 ? arguments[3] : undefined;\n        if (typeof value === 'string') {\n            return parseFloat(value) * scalar;\n        }\n        if (typeof value === 'number') {\n            return value * (axis ? size[axis] : Math.min(size.width, size.height));\n        }\n        return;\n    };\n\n    var getMarkupStyles = function getMarkupStyles(markup, size, scale) {\n        var lineStyle = markup.borderStyle || markup.lineStyle || 'solid';\n        var fill = markup.backgroundColor || markup.fontColor || 'transparent';\n        var stroke = markup.borderColor || markup.lineColor || 'transparent';\n        var strokeWidth = getMarkupValue(markup.borderWidth || markup.lineWidth, size, scale);\n        var lineCap = markup.lineCap || 'round';\n        var lineJoin = markup.lineJoin || 'round';\n        var dashes =\n            typeof lineStyle === 'string'\n                ? ''\n                : lineStyle\n                      .map(function(v) {\n                          return getMarkupValue(v, size, scale);\n                      })\n                      .join(',');\n        var opacity = markup.opacity || 1;\n        return {\n            'stroke-linecap': lineCap,\n            'stroke-linejoin': lineJoin,\n            'stroke-width': strokeWidth || 0,\n            'stroke-dasharray': dashes,\n            stroke: stroke,\n            fill: fill,\n            opacity: opacity,\n        };\n    };\n\n    var isDefined = function isDefined(value) {\n        return value != null;\n    };\n\n    var getMarkupRect = function getMarkupRect(rect, size) {\n        var scalar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n        var left =\n            getMarkupValue(rect.x, size, scalar, 'width') ||\n            getMarkupValue(rect.left, size, scalar, 'width');\n        var top =\n            getMarkupValue(rect.y, size, scalar, 'height') ||\n            getMarkupValue(rect.top, size, scalar, 'height');\n        var width = getMarkupValue(rect.width, size, scalar, 'width');\n        var height = getMarkupValue(rect.height, size, scalar, 'height');\n        var right = getMarkupValue(rect.right, size, scalar, 'width');\n        var bottom = getMarkupValue(rect.bottom, size, scalar, 'height');\n\n        if (!isDefined(top)) {\n            if (isDefined(height) && isDefined(bottom)) {\n                top = size.height - height - bottom;\n            } else {\n                top = bottom;\n            }\n        }\n\n        if (!isDefined(left)) {\n            if (isDefined(width) && isDefined(right)) {\n                left = size.width - width - right;\n            } else {\n                left = right;\n            }\n        }\n\n        if (!isDefined(width)) {\n            if (isDefined(left) && isDefined(right)) {\n                width = size.width - left - right;\n            } else {\n                width = 0;\n            }\n        }\n\n        if (!isDefined(height)) {\n            if (isDefined(top) && isDefined(bottom)) {\n                height = size.height - top - bottom;\n            } else {\n                height = 0;\n            }\n        }\n\n        return {\n            x: left || 0,\n            y: top || 0,\n            width: width || 0,\n            height: height || 0,\n        };\n    };\n\n    var pointsToPathShape = function pointsToPathShape(points) {\n        return points\n            .map(function(point, index) {\n                return ''\n                    .concat(index === 0 ? 'M' : 'L', ' ')\n                    .concat(point.x, ' ')\n                    .concat(point.y);\n            })\n            .join(' ');\n    };\n\n    var setAttributes = function setAttributes(element, attr) {\n        return Object.keys(attr).forEach(function(key) {\n            return element.setAttribute(key, attr[key]);\n        });\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var svg = function svg(tag, attr) {\n        var element = document.createElementNS(ns, tag);\n        if (attr) {\n            setAttributes(element, attr);\n        }\n        return element;\n    };\n\n    var updateRect = function updateRect(element) {\n        return setAttributes(element, Object.assign({}, element.rect, element.styles));\n    };\n\n    var updateEllipse = function updateEllipse(element) {\n        var cx = element.rect.x + element.rect.width * 0.5;\n        var cy = element.rect.y + element.rect.height * 0.5;\n        var rx = element.rect.width * 0.5;\n        var ry = element.rect.height * 0.5;\n        return setAttributes(\n            element,\n            Object.assign(\n                {\n                    cx: cx,\n                    cy: cy,\n                    rx: rx,\n                    ry: ry,\n                },\n                element.styles\n            )\n        );\n    };\n\n    var IMAGE_FIT_STYLE = {\n        contain: 'xMidYMid meet',\n        cover: 'xMidYMid slice',\n    };\n\n    var updateImage = function updateImage(element, markup) {\n        setAttributes(\n            element,\n            Object.assign({}, element.rect, element.styles, {\n                preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || 'none',\n            })\n        );\n    };\n\n    var TEXT_ANCHOR = {\n        left: 'start',\n        center: 'middle',\n        right: 'end',\n    };\n\n    var updateText = function updateText(element, markup, size, scale) {\n        var fontSize = getMarkupValue(markup.fontSize, size, scale);\n        var fontFamily = markup.fontFamily || 'sans-serif';\n        var fontWeight = markup.fontWeight || 'normal';\n        var textAlign = TEXT_ANCHOR[markup.textAlign] || 'start';\n\n        setAttributes(\n            element,\n            Object.assign({}, element.rect, element.styles, {\n                'stroke-width': 0,\n                'font-weight': fontWeight,\n                'font-size': fontSize,\n                'font-family': fontFamily,\n                'text-anchor': textAlign,\n            })\n        );\n\n        // update text\n        if (element.text !== markup.text) {\n            element.text = markup.text;\n            element.textContent = markup.text.length ? markup.text : ' ';\n        }\n    };\n\n    var updateLine = function updateLine(element, markup, size, scale) {\n        setAttributes(\n            element,\n            Object.assign({}, element.rect, element.styles, {\n                fill: 'none',\n            })\n        );\n\n        var line = element.childNodes[0];\n        var begin = element.childNodes[1];\n        var end = element.childNodes[2];\n\n        var origin = element.rect;\n\n        var target = {\n            x: element.rect.x + element.rect.width,\n            y: element.rect.y + element.rect.height,\n        };\n\n        setAttributes(line, {\n            x1: origin.x,\n            y1: origin.y,\n            x2: target.x,\n            y2: target.y,\n        });\n\n        if (!markup.lineDecoration) return;\n\n        begin.style.display = 'none';\n        end.style.display = 'none';\n\n        var v = vectorNormalize({\n            x: target.x - origin.x,\n            y: target.y - origin.y,\n        });\n\n        var l = getMarkupValue(0.05, size, scale);\n\n        if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n            var arrowBeginRotationPoint = vectorMultiply(v, l);\n            var arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n            var arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n            var arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n            setAttributes(begin, {\n                style: 'display:block;',\n                d: 'M'\n                    .concat(arrowBeginA.x, ',')\n                    .concat(arrowBeginA.y, ' L')\n                    .concat(origin.x, ',')\n                    .concat(origin.y, ' L')\n                    .concat(arrowBeginB.x, ',')\n                    .concat(arrowBeginB.y),\n            });\n        }\n\n        if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n            var arrowEndRotationPoint = vectorMultiply(v, -l);\n            var arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n            var arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n            var arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n            setAttributes(end, {\n                style: 'display:block;',\n                d: 'M'\n                    .concat(arrowEndA.x, ',')\n                    .concat(arrowEndA.y, ' L')\n                    .concat(target.x, ',')\n                    .concat(target.y, ' L')\n                    .concat(arrowEndB.x, ',')\n                    .concat(arrowEndB.y),\n            });\n        }\n    };\n\n    var updatePath = function updatePath(element, markup, size, scale) {\n        setAttributes(\n            element,\n            Object.assign({}, element.styles, {\n                fill: 'none',\n                d: pointsToPathShape(\n                    markup.points.map(function(point) {\n                        return {\n                            x: getMarkupValue(point.x, size, scale, 'width'),\n                            y: getMarkupValue(point.y, size, scale, 'height'),\n                        };\n                    })\n                ),\n            })\n        );\n    };\n\n    var createShape = function createShape(node) {\n        return function(markup) {\n            return svg(node, { id: markup.id });\n        };\n    };\n\n    var createImage = function createImage(markup) {\n        var shape = svg('image', {\n            id: markup.id,\n            'stroke-linecap': 'round',\n            'stroke-linejoin': 'round',\n            opacity: '0',\n        });\n\n        shape.onload = function() {\n            shape.setAttribute('opacity', markup.opacity || 1);\n        };\n        shape.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', markup.src);\n        return shape;\n    };\n\n    var createLine = function createLine(markup) {\n        var shape = svg('g', {\n            id: markup.id,\n            'stroke-linecap': 'round',\n            'stroke-linejoin': 'round',\n        });\n\n        var line = svg('line');\n        shape.appendChild(line);\n\n        var begin = svg('path');\n        shape.appendChild(begin);\n\n        var end = svg('path');\n        shape.appendChild(end);\n\n        return shape;\n    };\n\n    var CREATE_TYPE_ROUTES = {\n        image: createImage,\n        rect: createShape('rect'),\n        ellipse: createShape('ellipse'),\n        text: createShape('text'),\n        path: createShape('path'),\n        line: createLine,\n    };\n\n    var UPDATE_TYPE_ROUTES = {\n        rect: updateRect,\n        ellipse: updateEllipse,\n        image: updateImage,\n        text: updateText,\n        path: updatePath,\n        line: updateLine,\n    };\n\n    var createMarkupByType = function createMarkupByType(type, markup) {\n        return CREATE_TYPE_ROUTES[type](markup);\n    };\n\n    var updateMarkupByType = function updateMarkupByType(element, type, markup, size, scale) {\n        if (type !== 'path') {\n            element.rect = getMarkupRect(markup, size, scale);\n        }\n        element.styles = getMarkupStyles(markup, size, scale);\n        UPDATE_TYPE_ROUTES[type](element, markup, size, scale);\n    };\n\n    var sortMarkupByZIndex = function sortMarkupByZIndex(a, b) {\n        if (a[1].zIndex > b[1].zIndex) {\n            return 1;\n        }\n        if (a[1].zIndex < b[1].zIndex) {\n            return -1;\n        }\n        return 0;\n    };\n\n    var cropSVG = function cropSVG(blob) {\n        var crop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var markup = arguments.length > 2 ? arguments[2] : undefined;\n        var options = arguments.length > 3 ? arguments[3] : undefined;\n        return new Promise(function(resolve) {\n            var _options$background = options.background,\n                background = _options$background === void 0 ? null : _options$background;\n\n            // load blob contents and wrap in crop svg\n            var fr = new FileReader();\n            fr.onloadend = function() {\n                // get svg text\n                var text = fr.result;\n\n                // create element with svg and get size\n                var original = document.createElement('div');\n                original.style.cssText =\n                    'position:absolute;pointer-events:none;width:0;height:0;visibility:hidden;';\n                original.innerHTML = text;\n                var originalNode = original.querySelector('svg');\n                document.body.appendChild(original);\n\n                // request bounding box dimensions\n                var bBox = originalNode.getBBox();\n                original.parentNode.removeChild(original);\n\n                // get title\n                var titleNode = original.querySelector('title');\n\n                // calculate new heights and widths\n                var viewBoxAttribute = originalNode.getAttribute('viewBox') || '';\n                var widthAttribute = originalNode.getAttribute('width') || '';\n                var heightAttribute = originalNode.getAttribute('height') || '';\n                var width = parseFloat(widthAttribute) || null;\n                var height = parseFloat(heightAttribute) || null;\n                var widthUnits = (widthAttribute.match(/[a-z]+/) || [])[0] || '';\n                var heightUnits = (heightAttribute.match(/[a-z]+/) || [])[0] || '';\n\n                // create new size\n                var viewBoxList = viewBoxAttribute.split(' ').map(parseFloat);\n                var viewBox = viewBoxList.length\n                    ? {\n                          x: viewBoxList[0],\n                          y: viewBoxList[1],\n                          width: viewBoxList[2],\n                          height: viewBoxList[3],\n                      }\n                    : bBox;\n\n                var imageWidth = width != null ? width : viewBox.width;\n                var imageHeight = height != null ? height : viewBox.height;\n\n                originalNode.style.overflow = 'visible';\n                originalNode.setAttribute('width', imageWidth);\n                originalNode.setAttribute('height', imageHeight);\n\n                // markup\n                var markupSVG = '';\n                if (markup && markup.length) {\n                    var size = {\n                        width: imageWidth,\n                        height: imageHeight,\n                    };\n\n                    markupSVG = markup.sort(sortMarkupByZIndex).reduce(function(prev, shape) {\n                        var el = createMarkupByType(shape[0], shape[1]);\n                        updateMarkupByType(el, shape[0], shape[1], size);\n                        el.removeAttribute('id');\n                        if (el.getAttribute('opacity') === 1) {\n                            el.removeAttribute('opacity');\n                        }\n                        return prev + '\\n' + el.outerHTML + '\\n';\n                    }, '');\n                    markupSVG = '\\n\\n<g>'.concat(markupSVG.replace(/&nbsp;/g, ' '), '</g>\\n\\n');\n                }\n\n                var aspectRatio = crop.aspectRatio || imageHeight / imageWidth;\n\n                var canvasWidth = imageWidth;\n                var canvasHeight = canvasWidth * aspectRatio;\n\n                var shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n                var cropCenterX = crop.center ? crop.center.x : 0.5;\n                var cropCenterY = crop.center ? crop.center.y : 0.5;\n\n                var canvasZoomFactor = getImageRectZoomFactor(\n                    {\n                        width: imageWidth,\n                        height: imageHeight,\n                    },\n\n                    getCenteredCropRect(\n                        {\n                            width: canvasWidth,\n                            height: canvasHeight,\n                        },\n\n                        aspectRatio\n                    ),\n\n                    crop.rotation,\n                    shouldLimit\n                        ? { x: cropCenterX, y: cropCenterY }\n                        : {\n                              x: 0.5,\n                              y: 0.5,\n                          }\n                );\n\n                var scale = crop.zoom * canvasZoomFactor;\n\n                var rotation = crop.rotation * (180 / Math.PI);\n\n                var canvasCenter = {\n                    x: canvasWidth * 0.5,\n                    y: canvasHeight * 0.5,\n                };\n\n                var imageOffset = {\n                    x: canvasCenter.x - imageWidth * cropCenterX,\n                    y: canvasCenter.y - imageHeight * cropCenterY,\n                };\n\n                var cropTransforms = [\n                    // rotate\n                    'rotate('\n                        .concat(rotation, ' ')\n                        .concat(canvasCenter.x, ' ')\n                        .concat(canvasCenter.y, ')'),\n\n                    // scale\n                    'translate('.concat(canvasCenter.x, ' ').concat(canvasCenter.y, ')'),\n                    'scale('.concat(scale, ')'),\n                    'translate('.concat(-canvasCenter.x, ' ').concat(-canvasCenter.y, ')'),\n\n                    // offset\n                    'translate('.concat(imageOffset.x, ' ').concat(imageOffset.y, ')'),\n                ];\n\n                var cropFlipHorizontal = crop.flip && crop.flip.horizontal;\n                var cropFlipVertical = crop.flip && crop.flip.vertical;\n\n                var flipTransforms = [\n                    'scale('\n                        .concat(cropFlipHorizontal ? -1 : 1, ' ')\n                        .concat(cropFlipVertical ? -1 : 1, ')'),\n                    'translate('\n                        .concat(cropFlipHorizontal ? -imageWidth : 0, ' ')\n                        .concat(cropFlipVertical ? -imageHeight : 0, ')'),\n                ];\n\n                // crop\n                var transformed = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<svg width=\"'\n                    .concat(canvasWidth)\n                    .concat(widthUnits, '\" height=\"')\n                    .concat(canvasHeight)\n                    .concat(heightUnits, '\" \\nviewBox=\"0 0 ')\n                    .concat(canvasWidth, ' ')\n                    .concat(canvasHeight, '\" ')\n                    .concat(\n                        background ? 'style=\"background:' + background + '\" ' : '',\n                        '\\npreserveAspectRatio=\"xMinYMin\"\\nxmlns:xlink=\"http://www.w3.org/1999/xlink\"\\nxmlns=\"http://www.w3.org/2000/svg\">\\n<!-- Generated by PQINA - https://pqina.nl/ -->\\n<title>'\n                    )\n                    .concat(titleNode ? titleNode.textContent : '', '</title>\\n<g transform=\"')\n                    .concat(cropTransforms.join(' '), '\">\\n<g transform=\"')\n                    .concat(flipTransforms.join(' '), '\">\\n')\n                    .concat(originalNode.outerHTML)\n                    .concat(markupSVG, '\\n</g>\\n</g>\\n</svg>');\n\n                // create new svg file\n                resolve(transformed);\n            };\n\n            fr.readAsText(blob);\n        });\n    };\n\n    var objectToImageData = function objectToImageData(obj) {\n        var imageData;\n        try {\n            imageData = new ImageData(obj.width, obj.height);\n        } catch (e) {\n            // IE + Old EDGE (tested on 12)\n            var canvas = document.createElement('canvas');\n            imageData = canvas.getContext('2d').createImageData(obj.width, obj.height);\n        }\n        imageData.data.set(obj.data);\n        return imageData;\n    };\n\n    /* javascript-obfuscator:disable */\n    var TransformWorker = function TransformWorker() {\n        // maps transform types to transform functions\n        var TRANSFORMS = { resize: resize, filter: filter };\n\n        // applies all image transforms to the image data array\n        var applyTransforms = function applyTransforms(transforms, imageData) {\n            transforms.forEach(function(transform) {\n                imageData = TRANSFORMS[transform.type](imageData, transform.data);\n            });\n            return imageData;\n        };\n\n        // transform image hub\n        var transform = function transform(data, cb) {\n            var transforms = data.transforms;\n\n            // if has filter and has resize, move filter to resize operation\n            var filterTransform = null;\n            transforms.forEach(function(transform) {\n                if (transform.type === 'filter') {\n                    filterTransform = transform;\n                }\n            });\n            if (filterTransform) {\n                // find resize\n                var resizeTransform = null;\n                transforms.forEach(function(transform) {\n                    if (transform.type === 'resize') {\n                        resizeTransform = transform;\n                    }\n                });\n\n                if (resizeTransform) {\n                    // update resize operation\n                    resizeTransform.data.matrix = filterTransform.data;\n\n                    // remove filter\n                    transforms = transforms.filter(function(transform) {\n                        return transform.type !== 'filter';\n                    });\n                }\n            }\n\n            cb(applyTransforms(transforms, data.imageData));\n        };\n\n        // eslint-disable-next-line no-restricted-globals\n        self.onmessage = function(e) {\n            transform(e.data.message, function(response) {\n                // eslint-disable-next-line no-restricted-globals\n                self.postMessage({ id: e.data.id, message: response }, [response.data.buffer]);\n            });\n        };\n\n        var br = 1.0;\n        var bg = 1.0;\n        var bb = 1.0;\n        function applyFilterMatrix(index, data, m) {\n            var ir = data[index] / 255;\n            var ig = data[index + 1] / 255;\n            var ib = data[index + 2] / 255;\n            var ia = data[index + 3] / 255;\n\n            var mr = ir * m[0] + ig * m[1] + ib * m[2] + ia * m[3] + m[4];\n            var mg = ir * m[5] + ig * m[6] + ib * m[7] + ia * m[8] + m[9];\n            var mb = ir * m[10] + ig * m[11] + ib * m[12] + ia * m[13] + m[14];\n            var ma = ir * m[15] + ig * m[16] + ib * m[17] + ia * m[18] + m[19];\n\n            var or = Math.max(0, mr * ma) + br * (1.0 - ma);\n            var og = Math.max(0, mg * ma) + bg * (1.0 - ma);\n            var ob = Math.max(0, mb * ma) + bb * (1.0 - ma);\n\n            data[index] = Math.max(0.0, Math.min(1.0, or)) * 255;\n            data[index + 1] = Math.max(0.0, Math.min(1.0, og)) * 255;\n            data[index + 2] = Math.max(0.0, Math.min(1.0, ob)) * 255;\n        }\n\n        var identityMatrix = self.JSON.stringify([\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n        ]);\n        function isIdentityMatrix(filter) {\n            return self.JSON.stringify(filter || []) === identityMatrix;\n        }\n\n        function filter(imageData, matrix) {\n            if (!matrix || isIdentityMatrix(matrix)) return imageData;\n\n            var data = imageData.data;\n            var l = data.length;\n\n            var m11 = matrix[0];\n            var m12 = matrix[1];\n            var m13 = matrix[2];\n            var m14 = matrix[3];\n            var m15 = matrix[4];\n\n            var m21 = matrix[5];\n            var m22 = matrix[6];\n            var m23 = matrix[7];\n            var m24 = matrix[8];\n            var m25 = matrix[9];\n\n            var m31 = matrix[10];\n            var m32 = matrix[11];\n            var m33 = matrix[12];\n            var m34 = matrix[13];\n            var m35 = matrix[14];\n\n            var m41 = matrix[15];\n            var m42 = matrix[16];\n            var m43 = matrix[17];\n            var m44 = matrix[18];\n            var m45 = matrix[19];\n\n            var index = 0,\n                r = 0.0,\n                g = 0.0,\n                b = 0.0,\n                a = 0.0,\n                mr = 0.0,\n                mg = 0.0,\n                mb = 0.0,\n                ma = 0.0,\n                or = 0.0,\n                og = 0.0,\n                ob = 0.0;\n\n            for (; index < l; index += 4) {\n                r = data[index] / 255;\n                g = data[index + 1] / 255;\n                b = data[index + 2] / 255;\n                a = data[index + 3] / 255;\n\n                mr = r * m11 + g * m12 + b * m13 + a * m14 + m15;\n                mg = r * m21 + g * m22 + b * m23 + a * m24 + m25;\n                mb = r * m31 + g * m32 + b * m33 + a * m34 + m35;\n                ma = r * m41 + g * m42 + b * m43 + a * m44 + m45;\n\n                or = Math.max(0, mr * ma) + br * (1.0 - ma);\n                og = Math.max(0, mg * ma) + bg * (1.0 - ma);\n                ob = Math.max(0, mb * ma) + bb * (1.0 - ma);\n\n                data[index] = Math.max(0.0, Math.min(1.0, or)) * 255;\n                data[index + 1] = Math.max(0.0, Math.min(1.0, og)) * 255;\n                data[index + 2] = Math.max(0.0, Math.min(1.0, ob)) * 255;\n                // don't update alpha value\n            }\n\n            return imageData;\n        }\n\n        function resize(imageData, data) {\n            var _data$mode = data.mode,\n                mode = _data$mode === void 0 ? 'contain' : _data$mode,\n                _data$upscale = data.upscale,\n                upscale = _data$upscale === void 0 ? false : _data$upscale,\n                width = data.width,\n                height = data.height,\n                matrix = data.matrix;\n\n            // test if is identity matrix\n            matrix = !matrix || isIdentityMatrix(matrix) ? null : matrix;\n\n            // need at least a width or a height\n            // also 0 is not a valid width or height\n            if (!width && !height) {\n                return filter(imageData, matrix);\n            }\n\n            // make sure all bounds are set\n            if (width === null) {\n                width = height;\n            } else if (height === null) {\n                height = width;\n            }\n\n            if (mode !== 'force') {\n                var scalarWidth = width / imageData.width;\n                var scalarHeight = height / imageData.height;\n                var scalar = 1;\n\n                if (mode === 'cover') {\n                    scalar = Math.max(scalarWidth, scalarHeight);\n                } else if (mode === 'contain') {\n                    scalar = Math.min(scalarWidth, scalarHeight);\n                }\n\n                // if image is too small, exit here with original image\n                if (scalar > 1 && upscale === false) {\n                    return filter(imageData, matrix);\n                }\n\n                width = imageData.width * scalar;\n                height = imageData.height * scalar;\n            }\n\n            var originWidth = imageData.width;\n            var originHeight = imageData.height;\n            var targetWidth = Math.round(width);\n            var targetHeight = Math.round(height);\n            var inputData = imageData.data;\n            var outputData = new Uint8ClampedArray(targetWidth * targetHeight * 4);\n            var ratioWidth = originWidth / targetWidth;\n            var ratioHeight = originHeight / targetHeight;\n            var ratioWidthHalf = Math.ceil(ratioWidth * 0.5);\n            var ratioHeightHalf = Math.ceil(ratioHeight * 0.5);\n\n            for (var j = 0; j < targetHeight; j++) {\n                for (var i = 0; i < targetWidth; i++) {\n                    var x2 = (i + j * targetWidth) * 4;\n                    var weight = 0;\n                    var weights = 0;\n                    var weightsAlpha = 0;\n                    var r = 0;\n                    var g = 0;\n                    var b = 0;\n                    var a = 0;\n                    var centerY = (j + 0.5) * ratioHeight;\n\n                    for (var yy = Math.floor(j * ratioHeight); yy < (j + 1) * ratioHeight; yy++) {\n                        var dy = Math.abs(centerY - (yy + 0.5)) / ratioHeightHalf;\n                        var centerX = (i + 0.5) * ratioWidth;\n                        var w0 = dy * dy;\n\n                        for (var xx = Math.floor(i * ratioWidth); xx < (i + 1) * ratioWidth; xx++) {\n                            var dx = Math.abs(centerX - (xx + 0.5)) / ratioWidthHalf;\n                            var w = Math.sqrt(w0 + dx * dx);\n\n                            if (w >= -1 && w <= 1) {\n                                weight = 2 * w * w * w - 3 * w * w + 1;\n\n                                if (weight > 0) {\n                                    dx = 4 * (xx + yy * originWidth);\n\n                                    var ref = inputData[dx + 3];\n                                    a += weight * ref;\n                                    weightsAlpha += weight;\n\n                                    if (ref < 255) {\n                                        weight = (weight * ref) / 250;\n                                    }\n\n                                    r += weight * inputData[dx];\n                                    g += weight * inputData[dx + 1];\n                                    b += weight * inputData[dx + 2];\n                                    weights += weight;\n                                }\n                            }\n                        }\n                    }\n\n                    outputData[x2] = r / weights;\n                    outputData[x2 + 1] = g / weights;\n                    outputData[x2 + 2] = b / weights;\n                    outputData[x2 + 3] = a / weightsAlpha;\n\n                    matrix && applyFilterMatrix(x2, outputData, matrix);\n                }\n            }\n\n            return {\n                data: outputData,\n                width: targetWidth,\n                height: targetHeight,\n            };\n        }\n    };\n    /* javascript-obfuscator:enable */\n\n    var correctOrientation = function correctOrientation(view, offset) {\n        // Missing 0x45786966 Marker? No Exif Header, stop here\n        if (view.getUint32(offset + 4, false) !== 0x45786966) return;\n\n        // next byte!\n        offset += 4;\n\n        // First 2bytes defines byte align of TIFF data.\n        // If it is 0x4949=\"I I\", it means \"Intel\" type byte align\n        var intelByteAligned = view.getUint16((offset += 6), false) === 0x4949;\n        offset += view.getUint32(offset + 4, intelByteAligned);\n\n        var tags = view.getUint16(offset, intelByteAligned);\n        offset += 2;\n\n        // find Orientation tag\n        for (var i = 0; i < tags; i++) {\n            if (view.getUint16(offset + i * 12, intelByteAligned) === 0x0112) {\n                view.setUint16(offset + i * 12 + 8, 1, intelByteAligned);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    var readData = function readData(data) {\n        var view = new DataView(data);\n\n        // Every JPEG file starts from binary value '0xFFD8'\n        // If it's not present, exit here\n        if (view.getUint16(0) !== 0xffd8) return null;\n\n        var offset = 2; // Start at 2 as we skipped two bytes (FFD8)\n        var marker;\n        var markerLength;\n        var orientationCorrected = false;\n\n        while (offset < view.byteLength) {\n            marker = view.getUint16(offset, false);\n            markerLength = view.getUint16(offset + 2, false) + 2;\n\n            // Test if is APP and COM markers\n            var isData = (marker >= 0xffe0 && marker <= 0xffef) || marker === 0xfffe;\n            if (!isData) {\n                break;\n            }\n\n            if (!orientationCorrected) {\n                orientationCorrected = correctOrientation(view, offset, markerLength);\n            }\n\n            if (offset + markerLength > view.byteLength) {\n                break;\n            }\n\n            offset += markerLength;\n        }\n        return data.slice(0, offset);\n    };\n\n    var getImageHead = function getImageHead(file) {\n        return new Promise(function(resolve) {\n            var reader = new FileReader();\n            reader.onload = function() {\n                return resolve(readData(reader.result) || null);\n            };\n            reader.readAsArrayBuffer(file.slice(0, 256 * 1024));\n        });\n    };\n\n    var getBlobBuilder = function getBlobBuilder() {\n        return (window.BlobBuilder =\n            window.BlobBuilder ||\n            window.WebKitBlobBuilder ||\n            window.MozBlobBuilder ||\n            window.MSBlobBuilder);\n    };\n\n    var createBlob = function createBlob(arrayBuffer, mimeType) {\n        var BB = getBlobBuilder();\n\n        if (BB) {\n            var bb = new BB();\n            bb.append(arrayBuffer);\n            return bb.getBlob(mimeType);\n        }\n\n        return new Blob([arrayBuffer], {\n            type: mimeType,\n        });\n    };\n\n    var getUniqueId = function getUniqueId() {\n        return Math.random()\n            .toString(36)\n            .substr(2, 9);\n    };\n\n    var createWorker = function createWorker(fn) {\n        var workerBlob = new Blob(['(', fn.toString(), ')()'], { type: 'application/javascript' });\n        var workerURL = URL.createObjectURL(workerBlob);\n        var worker = new Worker(workerURL);\n\n        var trips = [];\n\n        return {\n            transfer: function transfer() {}, // (message, cb) => {}\n            post: function post(message, cb, transferList) {\n                var id = getUniqueId();\n                trips[id] = cb;\n\n                worker.onmessage = function(e) {\n                    var cb = trips[e.data.id];\n                    if (!cb) return;\n                    cb(e.data.message);\n                    delete trips[e.data.id];\n                };\n\n                worker.postMessage(\n                    {\n                        id: id,\n                        message: message,\n                    },\n\n                    transferList\n                );\n            },\n            terminate: function terminate() {\n                worker.terminate();\n                URL.revokeObjectURL(workerURL);\n            },\n        };\n    };\n\n    var loadImage = function loadImage(url) {\n        return new Promise(function(resolve, reject) {\n            var img = new Image();\n            img.onload = function() {\n                resolve(img);\n            };\n            img.onerror = function(e) {\n                reject(e);\n            };\n            img.src = url;\n        });\n    };\n\n    var chain = function chain(funcs) {\n        return funcs.reduce(function(promise, func) {\n            return promise.then(function(result) {\n                return func().then(Array.prototype.concat.bind(result));\n            });\n        }, Promise.resolve([]));\n    };\n\n    var canvasApplyMarkup = function canvasApplyMarkup(canvas, markup) {\n        return new Promise(function(resolve) {\n            var size = {\n                width: canvas.width,\n                height: canvas.height,\n            };\n\n            var ctx = canvas.getContext('2d');\n\n            var drawers = markup.sort(sortMarkupByZIndex).map(function(item) {\n                return function() {\n                    return new Promise(function(resolve) {\n                        var result = TYPE_DRAW_ROUTES[item[0]](ctx, size, item[1], resolve);\n                        if (result) resolve();\n                    });\n                };\n            });\n\n            chain(drawers).then(function() {\n                return resolve(canvas);\n            });\n        });\n    };\n\n    var applyMarkupStyles = function applyMarkupStyles(ctx, styles) {\n        ctx.beginPath();\n        ctx.lineCap = styles['stroke-linecap'];\n        ctx.lineJoin = styles['stroke-linejoin'];\n        ctx.lineWidth = styles['stroke-width'];\n        if (styles['stroke-dasharray'].length) {\n            ctx.setLineDash(styles['stroke-dasharray'].split(','));\n        }\n        ctx.fillStyle = styles['fill'];\n        ctx.strokeStyle = styles['stroke'];\n        ctx.globalAlpha = styles.opacity || 1;\n    };\n\n    var drawMarkupStyles = function drawMarkupStyles(ctx) {\n        ctx.fill();\n        ctx.stroke();\n        ctx.globalAlpha = 1;\n    };\n\n    var drawRect = function drawRect(ctx, size, markup) {\n        var rect = getMarkupRect(markup, size);\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\n        drawMarkupStyles(ctx, styles);\n        return true;\n    };\n\n    var drawEllipse = function drawEllipse(ctx, size, markup) {\n        var rect = getMarkupRect(markup, size);\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n\n        var x = rect.x,\n            y = rect.y,\n            w = rect.width,\n            h = rect.height,\n            kappa = 0.5522848,\n            ox = (w / 2) * kappa,\n            oy = (h / 2) * kappa,\n            xe = x + w,\n            ye = y + h,\n            xm = x + w / 2,\n            ym = y + h / 2;\n\n        ctx.moveTo(x, ym);\n        ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n        drawMarkupStyles(ctx, styles);\n        return true;\n    };\n\n    var drawImage = function drawImage(ctx, size, markup, done) {\n        var rect = getMarkupRect(markup, size);\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n\n        var image = new Image();\n\n        // if is cross origin image add cross origin attribute\n        var isCrossOriginImage =\n            new URL(markup.src, window.location.href).origin !== window.location.origin;\n        if (isCrossOriginImage) image.crossOrigin = '';\n\n        image.onload = function() {\n            if (markup.fit === 'cover') {\n                var ar = rect.width / rect.height;\n                var width = ar > 1 ? image.width : image.height * ar;\n                var height = ar > 1 ? image.width / ar : image.height;\n                var x = image.width * 0.5 - width * 0.5;\n                var y = image.height * 0.5 - height * 0.5;\n                ctx.drawImage(image, x, y, width, height, rect.x, rect.y, rect.width, rect.height);\n            } else if (markup.fit === 'contain') {\n                var scalar = Math.min(rect.width / image.width, rect.height / image.height);\n                var _width = scalar * image.width;\n                var _height = scalar * image.height;\n                var _x = rect.x + rect.width * 0.5 - _width * 0.5;\n                var _y = rect.y + rect.height * 0.5 - _height * 0.5;\n                ctx.drawImage(image, 0, 0, image.width, image.height, _x, _y, _width, _height);\n            } else {\n                ctx.drawImage(\n                    image,\n                    0,\n                    0,\n                    image.width,\n                    image.height,\n                    rect.x,\n                    rect.y,\n                    rect.width,\n                    rect.height\n                );\n            }\n\n            drawMarkupStyles(ctx, styles);\n            done();\n        };\n        image.src = markup.src;\n    };\n\n    var drawText = function drawText(ctx, size, markup) {\n        var rect = getMarkupRect(markup, size);\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n\n        var fontSize = getMarkupValue(markup.fontSize, size);\n        var fontFamily = markup.fontFamily || 'sans-serif';\n        var fontWeight = markup.fontWeight || 'normal';\n        var textAlign = markup.textAlign || 'left';\n\n        ctx.font = ''\n            .concat(fontWeight, ' ')\n            .concat(fontSize, 'px ')\n            .concat(fontFamily);\n        ctx.textAlign = textAlign;\n        ctx.fillText(markup.text, rect.x, rect.y);\n\n        drawMarkupStyles(ctx, styles);\n        return true;\n    };\n\n    var drawPath = function drawPath(ctx, size, markup) {\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n        ctx.beginPath();\n\n        var points = markup.points.map(function(point) {\n            return {\n                x: getMarkupValue(point.x, size, 1, 'width'),\n                y: getMarkupValue(point.y, size, 1, 'height'),\n            };\n        });\n\n        ctx.moveTo(points[0].x, points[0].y);\n        var l = points.length;\n        for (var i = 1; i < l; i++) {\n            ctx.lineTo(points[i].x, points[i].y);\n        }\n\n        drawMarkupStyles(ctx, styles);\n        return true;\n    };\n\n    var drawLine = function drawLine(ctx, size, markup) {\n        var rect = getMarkupRect(markup, size);\n        var styles = getMarkupStyles(markup, size);\n        applyMarkupStyles(ctx, styles);\n\n        ctx.beginPath();\n\n        var origin = {\n            x: rect.x,\n            y: rect.y,\n        };\n\n        var target = {\n            x: rect.x + rect.width,\n            y: rect.y + rect.height,\n        };\n\n        ctx.moveTo(origin.x, origin.y);\n        ctx.lineTo(target.x, target.y);\n\n        var v = vectorNormalize({\n            x: target.x - origin.x,\n            y: target.y - origin.y,\n        });\n\n        var l = 0.04 * Math.min(size.width, size.height);\n\n        if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n            var arrowBeginRotationPoint = vectorMultiply(v, l);\n            var arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n            var arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n            var arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n            ctx.moveTo(arrowBeginA.x, arrowBeginA.y);\n            ctx.lineTo(origin.x, origin.y);\n            ctx.lineTo(arrowBeginB.x, arrowBeginB.y);\n        }\n        if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n            var arrowEndRotationPoint = vectorMultiply(v, -l);\n            var arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n            var arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n            var arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n            ctx.moveTo(arrowEndA.x, arrowEndA.y);\n            ctx.lineTo(target.x, target.y);\n            ctx.lineTo(arrowEndB.x, arrowEndB.y);\n        }\n\n        drawMarkupStyles(ctx, styles);\n        return true;\n    };\n\n    var TYPE_DRAW_ROUTES = {\n        rect: drawRect,\n        ellipse: drawEllipse,\n        image: drawImage,\n        text: drawText,\n        line: drawLine,\n        path: drawPath,\n    };\n\n    var imageDataToCanvas = function imageDataToCanvas(imageData) {\n        var image = document.createElement('canvas');\n        image.width = imageData.width;\n        image.height = imageData.height;\n        var ctx = image.getContext('2d');\n        ctx.putImageData(imageData, 0, 0);\n        return image;\n    };\n\n    var transformImage = function transformImage(file, instructions) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return new Promise(function(resolve, reject) {\n            // if the file is not an image we do not have any business transforming it\n            if (!file || !isImage$1(file))\n                return reject({ status: 'not an image file', file: file });\n\n            // get separate options for easier use\n            var stripImageHead = options.stripImageHead,\n                beforeCreateBlob = options.beforeCreateBlob,\n                afterCreateBlob = options.afterCreateBlob,\n                canvasMemoryLimit = options.canvasMemoryLimit;\n\n            // get crop\n            var crop = instructions.crop,\n                size = instructions.size,\n                filter = instructions.filter,\n                markup = instructions.markup,\n                output = instructions.output;\n\n            // get exif orientation\n            var orientation =\n                instructions.image && instructions.image.orientation\n                    ? Math.max(1, Math.min(8, instructions.image.orientation))\n                    : null;\n\n            // compression quality 0 => 100\n            var qualityAsPercentage = output && output.quality;\n            var quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;\n\n            // output format\n            var type = (output && output.type) || null;\n\n            // background color\n            var background = (output && output.background) || null;\n\n            // get transforms\n            var transforms = [];\n\n            // add resize transforms if set\n            if (size && (typeof size.width === 'number' || typeof size.height === 'number')) {\n                transforms.push({ type: 'resize', data: size });\n            }\n\n            // add filters\n            if (filter && filter.length === 20) {\n                transforms.push({ type: 'filter', data: filter });\n            }\n\n            // resolves with supplied blob\n            var resolveWithBlob = function resolveWithBlob(blob) {\n                var promisedBlob = afterCreateBlob ? afterCreateBlob(blob) : blob;\n                Promise.resolve(promisedBlob).then(resolve);\n            };\n\n            // done\n            var toBlob = function toBlob(imageData, options) {\n                var canvas = imageDataToCanvas(imageData);\n                var promisedCanvas = markup.length ? canvasApplyMarkup(canvas, markup) : canvas;\n                Promise.resolve(promisedCanvas).then(function(canvas) {\n                    canvasToBlob(canvas, options, beforeCreateBlob)\n                        .then(function(blob) {\n                            // force release of canvas memory\n                            canvasRelease(canvas);\n\n                            // remove image head (default)\n                            if (stripImageHead) return resolveWithBlob(blob);\n\n                            // try to copy image head from original file to generated blob\n                            getImageHead(file).then(function(imageHead) {\n                                // re-inject image head in case of JPEG, as the image head is removed by canvas export\n                                if (imageHead !== null) {\n                                    blob = new Blob([imageHead, blob.slice(20)], {\n                                        type: blob.type,\n                                    });\n                                }\n\n                                // done!\n                                resolveWithBlob(blob);\n                            });\n                        })\n                        .catch(reject);\n                });\n            };\n\n            // if this is an svg and we want it to stay an svg\n            if (/svg/.test(file.type) && type === null) {\n                return cropSVG(file, crop, markup, { background: background }).then(function(text) {\n                    resolve(createBlob(text, 'image/svg+xml'));\n                });\n            }\n\n            // get file url\n            var url = URL.createObjectURL(file);\n\n            // turn the file into an image\n            loadImage(url)\n                .then(function(image) {\n                    // url is no longer needed\n                    URL.revokeObjectURL(url);\n\n                    // draw to canvas and start transform chain\n                    var imageData = imageToImageData(image, orientation, crop, {\n                        canvasMemoryLimit: canvasMemoryLimit,\n                        background: background,\n                    });\n\n                    // determine the format of the blob that we will output\n                    var outputFormat = {\n                        quality: quality,\n                        type: type || file.type,\n                    };\n\n                    // no transforms necessary, we done!\n                    if (!transforms.length) {\n                        return toBlob(imageData, outputFormat);\n                    }\n\n                    // send to the transform worker to transform the blob on a separate thread\n                    var worker = createWorker(TransformWorker);\n                    worker.post(\n                        {\n                            transforms: transforms,\n                            imageData: imageData,\n                        },\n\n                        function(response) {\n                            // finish up\n                            toBlob(objectToImageData(response), outputFormat);\n\n                            // stop worker\n                            worker.terminate();\n                        },\n                        [imageData.data.buffer]\n                    );\n                })\n                .catch(reject);\n        });\n    };\n\n    function _typeof(obj) {\n        if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n            _typeof = function(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function(obj) {\n                return obj &&\n                    typeof Symbol === 'function' &&\n                    obj.constructor === Symbol &&\n                    obj !== Symbol.prototype\n                    ? 'symbol'\n                    : typeof obj;\n            };\n        }\n\n        return _typeof(obj);\n    }\n\n    var REACT_ELEMENT_TYPE;\n\n    function _jsx(type, props, key, children) {\n        if (!REACT_ELEMENT_TYPE) {\n            REACT_ELEMENT_TYPE =\n                (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||\n                0xeac7;\n        }\n\n        var defaultProps = type && type.defaultProps;\n        var childrenLength = arguments.length - 3;\n\n        if (!props && childrenLength !== 0) {\n            props = {\n                children: void 0,\n            };\n        }\n\n        if (props && defaultProps) {\n            for (var propName in defaultProps) {\n                if (props[propName] === void 0) {\n                    props[propName] = defaultProps[propName];\n                }\n            }\n        } else if (!props) {\n            props = defaultProps || {};\n        }\n\n        if (childrenLength === 1) {\n            props.children = children;\n        } else if (childrenLength > 1) {\n            var childArray = new Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n                childArray[i] = arguments[i + 3];\n            }\n\n            props.children = childArray;\n        }\n\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: type,\n            key: key === undefined ? null : '' + key,\n            ref: null,\n            props: props,\n            _owner: null,\n        };\n    }\n\n    function _asyncIterator(iterable) {\n        var method;\n\n        if (typeof Symbol === 'function') {\n            if (Symbol.asyncIterator) {\n                method = iterable[Symbol.asyncIterator];\n                if (method != null) return method.call(iterable);\n            }\n\n            if (Symbol.iterator) {\n                method = iterable[Symbol.iterator];\n                if (method != null) return method.call(iterable);\n            }\n        }\n\n        throw new TypeError('Object is not async iterable');\n    }\n\n    function _AwaitValue(value) {\n        this.wrapped = value;\n    }\n\n    function _AsyncGenerator(gen) {\n        var front, back;\n\n        function send(key, arg) {\n            return new Promise(function(resolve, reject) {\n                var request = {\n                    key: key,\n                    arg: arg,\n                    resolve: resolve,\n                    reject: reject,\n                    next: null,\n                };\n\n                if (back) {\n                    back = back.next = request;\n                } else {\n                    front = back = request;\n                    resume(key, arg);\n                }\n            });\n        }\n\n        function resume(key, arg) {\n            try {\n                var result = gen[key](arg);\n                var value = result.value;\n                var wrappedAwait = value instanceof _AwaitValue;\n                Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n                    function(arg) {\n                        if (wrappedAwait) {\n                            resume('next', arg);\n                            return;\n                        }\n\n                        settle(result.done ? 'return' : 'normal', arg);\n                    },\n                    function(err) {\n                        resume('throw', err);\n                    }\n                );\n            } catch (err) {\n                settle('throw', err);\n            }\n        }\n\n        function settle(type, value) {\n            switch (type) {\n                case 'return':\n                    front.resolve({\n                        value: value,\n                        done: true,\n                    });\n                    break;\n\n                case 'throw':\n                    front.reject(value);\n                    break;\n\n                default:\n                    front.resolve({\n                        value: value,\n                        done: false,\n                    });\n                    break;\n            }\n\n            front = front.next;\n\n            if (front) {\n                resume(front.key, front.arg);\n            } else {\n                back = null;\n            }\n        }\n\n        this._invoke = send;\n\n        if (typeof gen.return !== 'function') {\n            this.return = undefined;\n        }\n    }\n\n    if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n\n    _AsyncGenerator.prototype.next = function(arg) {\n        return this._invoke('next', arg);\n    };\n\n    _AsyncGenerator.prototype.throw = function(arg) {\n        return this._invoke('throw', arg);\n    };\n\n    _AsyncGenerator.prototype.return = function(arg) {\n        return this._invoke('return', arg);\n    };\n\n    function _wrapAsyncGenerator(fn) {\n        return function() {\n            return new _AsyncGenerator(fn.apply(this, arguments));\n        };\n    }\n\n    function _awaitAsyncGenerator(value) {\n        return new _AwaitValue(value);\n    }\n\n    function _asyncGeneratorDelegate(inner, awaitWrap) {\n        var iter = {},\n            waiting = false;\n\n        function pump(key, value) {\n            waiting = true;\n            value = new Promise(function(resolve) {\n                resolve(inner[key](value));\n            });\n            return {\n                done: false,\n                value: awaitWrap(value),\n            };\n        }\n\n        if (typeof Symbol === 'function' && Symbol.iterator) {\n            iter[Symbol.iterator] = function() {\n                return this;\n            };\n        }\n\n        iter.next = function(value) {\n            if (waiting) {\n                waiting = false;\n                return value;\n            }\n\n            return pump('next', value);\n        };\n\n        if (typeof inner.throw === 'function') {\n            iter.throw = function(value) {\n                if (waiting) {\n                    waiting = false;\n                    throw value;\n                }\n\n                return pump('throw', value);\n            };\n        }\n\n        if (typeof inner.return === 'function') {\n            iter.return = function(value) {\n                return pump('return', value);\n            };\n        }\n\n        return iter;\n    }\n\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self = this,\n                args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self, args);\n\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n                }\n\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n                }\n\n                _next(undefined);\n            });\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError('Cannot call a class as a function');\n        }\n    }\n\n    function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if ('value' in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n    }\n\n    function _defineEnumerableProperties(obj, descs) {\n        for (var key in descs) {\n            var desc = descs[key];\n            desc.configurable = desc.enumerable = true;\n            if ('value' in desc) desc.writable = true;\n            Object.defineProperty(obj, key, desc);\n        }\n\n        if (Object.getOwnPropertySymbols) {\n            var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n            for (var i = 0; i < objectSymbols.length; i++) {\n                var sym = objectSymbols[i];\n                var desc = descs[sym];\n                desc.configurable = desc.enumerable = true;\n                if ('value' in desc) desc.writable = true;\n                Object.defineProperty(obj, sym, desc);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defaults(obj, defaults) {\n        var keys = Object.getOwnPropertyNames(defaults);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n            if (value && value.configurable && obj[key] === undefined) {\n                Object.defineProperty(obj, key, value);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true,\n            });\n        } else {\n            obj[key] = value;\n        }\n\n        return obj;\n    }\n\n    function _extends() {\n        _extends =\n            Object.assign ||\n            function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n\n                return target;\n            };\n\n        return _extends.apply(this, arguments);\n    }\n\n    function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n            var ownKeys = Object.keys(source);\n\n            if (typeof Object.getOwnPropertySymbols === 'function') {\n                ownKeys = ownKeys.concat(\n                    Object.getOwnPropertySymbols(source).filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                    })\n                );\n            }\n\n            ownKeys.forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        }\n\n        return target;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== 'function' && superClass !== null) {\n            throw new TypeError('Super expression must either be null or a function');\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true,\n            },\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n    }\n\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf\n            ? Object.getPrototypeOf\n            : function _getPrototypeOf(o) {\n                  return o.__proto__ || Object.getPrototypeOf(o);\n              };\n        return _getPrototypeOf(o);\n    }\n\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf =\n            Object.setPrototypeOf ||\n            function _setPrototypeOf(o, p) {\n                o.__proto__ = p;\n                return o;\n            };\n\n        return _setPrototypeOf(o, p);\n    }\n\n    function isNativeReflectConstruct() {\n        if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === 'function') return true;\n\n        try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n            _construct = Reflect.construct;\n        } else {\n            _construct = function _construct(Parent, args, Class) {\n                var a = [null];\n                a.push.apply(a, args);\n                var Constructor = Function.bind.apply(Parent, a);\n                var instance = new Constructor();\n                if (Class) _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            };\n        }\n\n        return _construct.apply(null, arguments);\n    }\n\n    function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf('[native code]') !== -1;\n    }\n\n    function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n            if (Class === null || !_isNativeFunction(Class)) return Class;\n\n            if (typeof Class !== 'function') {\n                throw new TypeError('Super expression must either be null or a function');\n            }\n\n            if (typeof _cache !== 'undefined') {\n                if (_cache.has(Class)) return _cache.get(Class);\n\n                _cache.set(Class, Wrapper);\n            }\n\n            function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n            }\n\n            Wrapper.prototype = Object.create(Class.prototype, {\n                constructor: {\n                    value: Wrapper,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                },\n            });\n            return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n    }\n\n    function _instanceof(left, right) {\n        if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {\n            return right[Symbol.hasInstance](left);\n        } else {\n            return left instanceof right;\n        }\n    }\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule\n            ? obj\n            : {\n                  default: obj,\n              };\n    }\n\n    function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n            return obj;\n        } else {\n            var newObj = {};\n\n            if (obj != null) {\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc =\n                            Object.defineProperty && Object.getOwnPropertyDescriptor\n                                ? Object.getOwnPropertyDescriptor(obj, key)\n                                : {};\n\n                        if (desc.get || desc.set) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n            }\n\n            newObj.default = obj;\n            return newObj;\n        }\n    }\n\n    function _newArrowCheck(innerThis, boundThis) {\n        if (innerThis !== boundThis) {\n            throw new TypeError('Cannot instantiate an arrow function');\n        }\n    }\n\n    function _objectDestructuringEmpty(obj) {\n        if (obj == null) throw new TypeError('Cannot destructure undefined');\n    }\n\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n\n        return target;\n    }\n\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n            for (i = 0; i < sourceSymbolKeys.length; i++) {\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n\n        return target;\n    }\n\n    function _assertThisInitialized(self) {\n        if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n        if (call && (typeof call === 'object' || typeof call === 'function')) {\n            return call;\n        }\n\n        return _assertThisInitialized(self);\n    }\n\n    function _superPropBase(object, property) {\n        while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n\n        return object;\n    }\n\n    function _get(target, property, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.get) {\n            _get = Reflect.get;\n        } else {\n            _get = function _get(target, property, receiver) {\n                var base = _superPropBase(target, property);\n\n                if (!base) return;\n                var desc = Object.getOwnPropertyDescriptor(base, property);\n\n                if (desc.get) {\n                    return desc.get.call(receiver);\n                }\n\n                return desc.value;\n            };\n        }\n\n        return _get(target, property, receiver || target);\n    }\n\n    function set(target, property, value, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.set) {\n            set = Reflect.set;\n        } else {\n            set = function set(target, property, value, receiver) {\n                var base = _superPropBase(target, property);\n\n                var desc;\n\n                if (base) {\n                    desc = Object.getOwnPropertyDescriptor(base, property);\n\n                    if (desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    } else if (!desc.writable) {\n                        return false;\n                    }\n                }\n\n                desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n                if (desc) {\n                    if (!desc.writable) {\n                        return false;\n                    }\n\n                    desc.value = value;\n                    Object.defineProperty(receiver, property, desc);\n                } else {\n                    _defineProperty(receiver, property, value);\n                }\n\n                return true;\n            };\n        }\n\n        return set(target, property, value, receiver);\n    }\n\n    function _set(target, property, value, receiver, isStrict) {\n        var s = set(target, property, value, receiver || target);\n\n        if (!s && isStrict) {\n            throw new Error('failed to set property');\n        }\n\n        return value;\n    }\n\n    function _taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        return Object.freeze(\n            Object.defineProperties(strings, {\n                raw: {\n                    value: Object.freeze(raw),\n                },\n            })\n        );\n    }\n\n    function _taggedTemplateLiteralLoose(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        strings.raw = raw;\n        return strings;\n    }\n\n    function _temporalRef(val, name) {\n        if (val === _temporalUndefined) {\n            throw new ReferenceError(name + ' is not defined - temporal dead zone');\n        } else {\n            return val;\n        }\n    }\n\n    function _readOnlyError(name) {\n        throw new Error('\"' + name + '\" is read-only');\n    }\n\n    function _classNameTDZError(name) {\n        throw new Error('Class \"' + name + '\" cannot be referenced in computed property keys.');\n    }\n\n    var _temporalUndefined = {};\n\n    function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n    }\n\n    function _slicedToArrayLoose(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _nonIterableRest();\n    }\n\n    function _toArray(arr) {\n        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n    }\n\n    function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n            return arr2;\n        }\n    }\n\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n\n    function _iterableToArray(iter) {\n        if (\n            Symbol.iterator in Object(iter) ||\n            Object.prototype.toString.call(iter) === '[object Arguments]'\n        )\n            return Array.from(iter);\n    }\n\n    function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally {\n            try {\n                if (!_n && _i['return'] != null) _i['return']();\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n\n        return _arr;\n    }\n\n    function _iterableToArrayLimitLoose(arr, i) {\n        var _arr = [];\n\n        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {\n            _arr.push(_step.value);\n\n            if (i && _arr.length === i) break;\n        }\n\n        return _arr;\n    }\n\n    function _nonIterableSpread() {\n        throw new TypeError('Invalid attempt to spread non-iterable instance');\n    }\n\n    function _nonIterableRest() {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n\n    function _skipFirstGeneratorNext(fn) {\n        return function() {\n            var it = fn.apply(this, arguments);\n            it.next();\n            return it;\n        };\n    }\n\n    function _toPrimitive(input, hint) {\n        if (typeof input !== 'object' || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || 'default');\n            if (typeof res !== 'object') return res;\n            throw new TypeError('@@toPrimitive must return a primitive value.');\n        }\n\n        return (hint === 'string' ? String : Number)(input);\n    }\n\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, 'string');\n\n        return typeof key === 'symbol' ? key : String(key);\n    }\n\n    function _initializerWarningHelper(descriptor, context) {\n        throw new Error(\n            'Decorating class property failed. Please ensure that ' +\n                'proposal-class-properties is enabled and set to use loose mode. ' +\n                'To use proposal-class-properties in spec mode with decorators, wait for ' +\n                'the next major version of decorators in stage 2.'\n        );\n    }\n\n    function _initializerDefineProperty(target, property, descriptor, context) {\n        if (!descriptor) return;\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n\n    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key) {\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n\n        if ('value' in desc || desc.initializer) {\n            desc.writable = true;\n        }\n\n        desc = decorators\n            .slice()\n            .reverse()\n            .reduce(function(desc, decorator) {\n                return decorator(target, property, desc) || desc;\n            }, desc);\n\n        if (context && desc.initializer !== void 0) {\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0) {\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n\n    var id = 0;\n\n    function _classPrivateFieldLooseKey(name) {\n        return '__private_' + id++ + '_' + name;\n    }\n\n    function _classPrivateFieldLooseBase(receiver, privateKey) {\n        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n            throw new TypeError('attempted to use private field on non-instance');\n        }\n\n        return receiver;\n    }\n\n    function _classPrivateFieldGet(receiver, privateMap) {\n        if (!privateMap.has(receiver)) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        var descriptor = privateMap.get(receiver);\n\n        if (descriptor.get) {\n            return descriptor.get.call(receiver);\n        }\n\n        return descriptor.value;\n    }\n\n    function _classPrivateFieldSet(receiver, privateMap, value) {\n        if (!privateMap.has(receiver)) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        var descriptor = privateMap.get(receiver);\n\n        if (descriptor.set) {\n            descriptor.set.call(receiver, value);\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            descriptor.value = value;\n        }\n\n        return value;\n    }\n\n    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return descriptor.value;\n    }\n\n    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        if (!descriptor.writable) {\n            throw new TypeError('attempted to set read only private field');\n        }\n\n        descriptor.value = value;\n        return value;\n    }\n\n    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return method;\n    }\n\n    function _classStaticPrivateMethodSet() {\n        throw new TypeError('attempted to set read only static private field');\n    }\n\n    function _decorate(decorators, factory, superClass, mixins) {\n        var api = _getDecoratorsApi();\n\n        if (mixins) {\n            for (var i = 0; i < mixins.length; i++) {\n                api = mixins[i](api);\n            }\n        }\n\n        var r = factory(function initialize(O) {\n            api.initializeInstanceElements(O, decorated.elements);\n        }, superClass);\n        var decorated = api.decorateClass(\n            _coalesceClassElements(r.d.map(_createElementDescriptor)),\n            decorators\n        );\n        api.initializeClassElements(r.F, decorated.elements);\n        return api.runClassFinishers(r.F, decorated.finishers);\n    }\n\n    function _getDecoratorsApi() {\n        _getDecoratorsApi = function() {\n            return api;\n        };\n\n        var api = {\n            elementsDefinitionOrder: [['method'], ['field']],\n            initializeInstanceElements: function(O, elements) {\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        if (element.kind === kind && element.placement === 'own') {\n                            this.defineClassElement(O, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            initializeClassElements: function(F, elements) {\n                var proto = F.prototype;\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        var placement = element.placement;\n\n                        if (\n                            element.kind === kind &&\n                            (placement === 'static' || placement === 'prototype')\n                        ) {\n                            var receiver = placement === 'static' ? F : proto;\n                            this.defineClassElement(receiver, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            defineClassElement: function(receiver, element) {\n                var descriptor = element.descriptor;\n\n                if (element.kind === 'field') {\n                    var initializer = element.initializer;\n                    descriptor = {\n                        enumerable: descriptor.enumerable,\n                        writable: descriptor.writable,\n                        configurable: descriptor.configurable,\n                        value: initializer === void 0 ? void 0 : initializer.call(receiver),\n                    };\n                }\n\n                Object.defineProperty(receiver, element.key, descriptor);\n            },\n            decorateClass: function(elements, decorators) {\n                var newElements = [];\n                var finishers = [];\n                var placements = {\n                    static: [],\n                    prototype: [],\n                    own: [],\n                };\n                elements.forEach(function(element) {\n                    this.addElementPlacement(element, placements);\n                }, this);\n                elements.forEach(function(element) {\n                    if (!_hasDecorators(element)) return newElements.push(element);\n                    var elementFinishersExtras = this.decorateElement(element, placements);\n                    newElements.push(elementFinishersExtras.element);\n                    newElements.push.apply(newElements, elementFinishersExtras.extras);\n                    finishers.push.apply(finishers, elementFinishersExtras.finishers);\n                }, this);\n\n                if (!decorators) {\n                    return {\n                        elements: newElements,\n                        finishers: finishers,\n                    };\n                }\n\n                var result = this.decorateConstructor(newElements, decorators);\n                finishers.push.apply(finishers, result.finishers);\n                result.finishers = finishers;\n                return result;\n            },\n            addElementPlacement: function(element, placements, silent) {\n                var keys = placements[element.placement];\n\n                if (!silent && keys.indexOf(element.key) !== -1) {\n                    throw new TypeError('Duplicated element (' + element.key + ')');\n                }\n\n                keys.push(element.key);\n            },\n            decorateElement: function(element, placements) {\n                var extras = [];\n                var finishers = [];\n\n                for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n                    var keys = placements[element.placement];\n                    keys.splice(keys.indexOf(element.key), 1);\n                    var elementObject = this.fromElementDescriptor(element);\n                    var elementFinisherExtras = this.toElementFinisherExtras(\n                        (0, decorators[i])(elementObject) || elementObject\n                    );\n                    element = elementFinisherExtras.element;\n                    this.addElementPlacement(element, placements);\n\n                    if (elementFinisherExtras.finisher) {\n                        finishers.push(elementFinisherExtras.finisher);\n                    }\n\n                    var newExtras = elementFinisherExtras.extras;\n\n                    if (newExtras) {\n                        for (var j = 0; j < newExtras.length; j++) {\n                            this.addElementPlacement(newExtras[j], placements);\n                        }\n\n                        extras.push.apply(extras, newExtras);\n                    }\n                }\n\n                return {\n                    element: element,\n                    finishers: finishers,\n                    extras: extras,\n                };\n            },\n            decorateConstructor: function(elements, decorators) {\n                var finishers = [];\n\n                for (var i = decorators.length - 1; i >= 0; i--) {\n                    var obj = this.fromClassDescriptor(elements);\n                    var elementsAndFinisher = this.toClassDescriptor(\n                        (0, decorators[i])(obj) || obj\n                    );\n\n                    if (elementsAndFinisher.finisher !== undefined) {\n                        finishers.push(elementsAndFinisher.finisher);\n                    }\n\n                    if (elementsAndFinisher.elements !== undefined) {\n                        elements = elementsAndFinisher.elements;\n\n                        for (var j = 0; j < elements.length - 1; j++) {\n                            for (var k = j + 1; k < elements.length; k++) {\n                                if (\n                                    elements[j].key === elements[k].key &&\n                                    elements[j].placement === elements[k].placement\n                                ) {\n                                    throw new TypeError(\n                                        'Duplicated element (' + elements[j].key + ')'\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return {\n                    elements: elements,\n                    finishers: finishers,\n                };\n            },\n            fromElementDescriptor: function(element) {\n                var obj = {\n                    kind: element.kind,\n                    key: element.key,\n                    placement: element.placement,\n                    descriptor: element.descriptor,\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                if (element.kind === 'field') obj.initializer = element.initializer;\n                return obj;\n            },\n            toElementDescriptors: function(elementObjects) {\n                if (elementObjects === undefined) return;\n                return _toArray(elementObjects).map(function(elementObject) {\n                    var element = this.toElementDescriptor(elementObject);\n                    this.disallowProperty(elementObject, 'finisher', 'An element descriptor');\n                    this.disallowProperty(elementObject, 'extras', 'An element descriptor');\n                    return element;\n                }, this);\n            },\n            toElementDescriptor: function(elementObject) {\n                var kind = String(elementObject.kind);\n\n                if (kind !== 'method' && kind !== 'field') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .kind property must be either \"method\" or' +\n                            ' \"field\", but a decorator created an element descriptor with' +\n                            ' .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                var key = _toPropertyKey(elementObject.key);\n\n                var placement = String(elementObject.placement);\n\n                if (placement !== 'static' && placement !== 'prototype' && placement !== 'own') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .placement property must be one of \"static\",' +\n                            ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n                            ' with .placement \"' +\n                            placement +\n                            '\"'\n                    );\n                }\n\n                var descriptor = elementObject.descriptor;\n                this.disallowProperty(elementObject, 'elements', 'An element descriptor');\n                var element = {\n                    kind: kind,\n                    key: key,\n                    placement: placement,\n                    descriptor: Object.assign({}, descriptor),\n                };\n\n                if (kind !== 'field') {\n                    this.disallowProperty(elementObject, 'initializer', 'A method descriptor');\n                } else {\n                    this.disallowProperty(\n                        descriptor,\n                        'get',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'set',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'value',\n                        'The property descriptor of a field descriptor'\n                    );\n                    element.initializer = elementObject.initializer;\n                }\n\n                return element;\n            },\n            toElementFinisherExtras: function(elementObject) {\n                var element = this.toElementDescriptor(elementObject);\n\n                var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n                var extras = this.toElementDescriptors(elementObject.extras);\n                return {\n                    element: element,\n                    finisher: finisher,\n                    extras: extras,\n                };\n            },\n            fromClassDescriptor: function(elements) {\n                var obj = {\n                    kind: 'class',\n                    elements: elements.map(this.fromElementDescriptor, this),\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                return obj;\n            },\n            toClassDescriptor: function(obj) {\n                var kind = String(obj.kind);\n\n                if (kind !== 'class') {\n                    throw new TypeError(\n                        'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n                            ' created a class descriptor with .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                this.disallowProperty(obj, 'key', 'A class descriptor');\n                this.disallowProperty(obj, 'placement', 'A class descriptor');\n                this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n                this.disallowProperty(obj, 'initializer', 'A class descriptor');\n                this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n                var finisher = _optionalCallableProperty(obj, 'finisher');\n\n                var elements = this.toElementDescriptors(obj.elements);\n                return {\n                    elements: elements,\n                    finisher: finisher,\n                };\n            },\n            runClassFinishers: function(constructor, finishers) {\n                for (var i = 0; i < finishers.length; i++) {\n                    var newConstructor = (0, finishers[i])(constructor);\n\n                    if (newConstructor !== undefined) {\n                        if (typeof newConstructor !== 'function') {\n                            throw new TypeError('Finishers must return a constructor.');\n                        }\n\n                        constructor = newConstructor;\n                    }\n                }\n\n                return constructor;\n            },\n            disallowProperty: function(obj, name, objectType) {\n                if (obj[name] !== undefined) {\n                    throw new TypeError(objectType + \" can't have a .\" + name + ' property.');\n                }\n            },\n        };\n        return api;\n    }\n\n    function _createElementDescriptor(def) {\n        var key = _toPropertyKey(def.key);\n\n        var descriptor;\n\n        if (def.kind === 'method') {\n            descriptor = {\n                value: def.value,\n                writable: true,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'get') {\n            descriptor = {\n                get: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'set') {\n            descriptor = {\n                set: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'field') {\n            descriptor = {\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            };\n        }\n\n        var element = {\n            kind: def.kind === 'field' ? 'field' : 'method',\n            key: key,\n            placement: def.static ? 'static' : def.kind === 'field' ? 'own' : 'prototype',\n            descriptor: descriptor,\n        };\n        if (def.decorators) element.decorators = def.decorators;\n        if (def.kind === 'field') element.initializer = def.value;\n        return element;\n    }\n\n    function _coalesceGetterSetter(element, other) {\n        if (element.descriptor.get !== undefined) {\n            other.descriptor.get = element.descriptor.get;\n        } else {\n            other.descriptor.set = element.descriptor.set;\n        }\n    }\n\n    function _coalesceClassElements(elements) {\n        var newElements = [];\n\n        var isSameElement = function(other) {\n            return (\n                other.kind === 'method' &&\n                other.key === element.key &&\n                other.placement === element.placement\n            );\n        };\n\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var other;\n\n            if (element.kind === 'method' && (other = newElements.find(isSameElement))) {\n                if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n                    if (_hasDecorators(element) || _hasDecorators(other)) {\n                        throw new ReferenceError(\n                            'Duplicated methods (' + element.key + \") can't be decorated.\"\n                        );\n                    }\n\n                    other.descriptor = element.descriptor;\n                } else {\n                    if (_hasDecorators(element)) {\n                        if (_hasDecorators(other)) {\n                            throw new ReferenceError(\n                                \"Decorators can't be placed on different accessors with for \" +\n                                    'the same property (' +\n                                    element.key +\n                                    ').'\n                            );\n                        }\n\n                        other.decorators = element.decorators;\n                    }\n\n                    _coalesceGetterSetter(element, other);\n                }\n            } else {\n                newElements.push(element);\n            }\n        }\n\n        return newElements;\n    }\n\n    function _hasDecorators(element) {\n        return element.decorators && element.decorators.length;\n    }\n\n    function _isDataDescriptor(desc) {\n        return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n    }\n\n    function _optionalCallableProperty(obj, name) {\n        var value = obj[name];\n\n        if (value !== undefined && typeof value !== 'function') {\n            throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n        }\n\n        return value;\n    }\n\n    function _classPrivateMethodGet(receiver, privateSet, fn) {\n        if (!privateSet.has(receiver)) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        return fn;\n    }\n\n    function _classPrivateMethodSet() {\n        throw new TypeError('attempted to reassign private method');\n    }\n\n    function _wrapRegExp(re, groups) {\n        _wrapRegExp = function(re, groups) {\n            return new BabelRegExp(re, groups);\n        };\n\n        var _RegExp = _wrapNativeSuper(RegExp);\n\n        var _super = RegExp.prototype;\n\n        var _groups = new WeakMap();\n\n        function BabelRegExp(re, groups) {\n            var _this = _RegExp.call(this, re);\n\n            _groups.set(_this, groups);\n\n            return _this;\n        }\n\n        _inherits(BabelRegExp, _RegExp);\n\n        BabelRegExp.prototype.exec = function(str) {\n            var result = _super.exec.call(this, str);\n\n            if (result) result.groups = buildGroups(result, this);\n            return result;\n        };\n\n        BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n            if (typeof substitution === 'string') {\n                var groups = _groups.get(this);\n\n                return _super[Symbol.replace].call(\n                    this,\n                    str,\n                    substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n                        return '$' + groups[name];\n                    })\n                );\n            } else if (typeof substitution === 'function') {\n                var _this = this;\n\n                return _super[Symbol.replace].call(this, str, function() {\n                    var args = [];\n                    args.push.apply(args, arguments);\n\n                    if (typeof args[args.length - 1] !== 'object') {\n                        args.push(buildGroups(args, _this));\n                    }\n\n                    return substitution.apply(this, args);\n                });\n            } else {\n                return _super[Symbol.replace].call(this, str, substitution);\n            }\n        };\n\n        function buildGroups(result, re) {\n            var g = _groups.get(re);\n\n            return Object.keys(g).reduce(function(groups, name) {\n                groups[name] = result[g[name]];\n                return groups;\n            }, Object.create(null));\n        }\n\n        return _wrapRegExp.apply(this, arguments);\n    }\n\n    var MARKUP_RECT = ['x', 'y', 'left', 'top', 'right', 'bottom', 'width', 'height'];\n\n    var toOptionalFraction = function toOptionalFraction(value) {\n        return typeof value === 'string' && /%/.test(value) ? parseFloat(value) / 100 : value;\n    };\n\n    // adds default markup properties, clones markup\n    var prepareMarkup = function prepareMarkup(markup) {\n        var _markup = _slicedToArray(markup, 2),\n            type = _markup[0],\n            props = _markup[1];\n\n        var rect = props.points\n            ? {}\n            : MARKUP_RECT.reduce(function(prev, curr) {\n                  prev[curr] = toOptionalFraction(props[curr]);\n                  return prev;\n              }, {});\n\n        return [\n            type,\n            Object.assign(\n                {\n                    zIndex: 0,\n                },\n                props,\n                rect\n            ),\n        ];\n    };\n\n    var getImageSize = function getImageSize(file) {\n        return new Promise(function(resolve, reject) {\n            var imageElement = new Image();\n            imageElement.src = URL.createObjectURL(file);\n\n            // start testing size\n            var measure = function measure() {\n                var width = imageElement.naturalWidth;\n                var height = imageElement.naturalHeight;\n                var hasSize = width && height;\n                if (!hasSize) return;\n\n                URL.revokeObjectURL(imageElement.src);\n                clearInterval(intervalId);\n                resolve({ width: width, height: height });\n            };\n\n            imageElement.onerror = function(err) {\n                URL.revokeObjectURL(imageElement.src);\n                clearInterval(intervalId);\n                reject(err);\n            };\n\n            var intervalId = setInterval(measure, 1);\n\n            measure();\n        });\n    };\n\n    /**\n     * Polyfill Edge and IE when in Browser\n     */\n    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n        if (!HTMLCanvasElement.prototype.toBlob) {\n            Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n                value: function value(cb, type, quality) {\n                    var canvas = this;\n                    setTimeout(function() {\n                        var dataURL = canvas.toDataURL(type, quality).split(',')[1];\n                        var binStr = atob(dataURL);\n                        var index = binStr.length;\n                        var data = new Uint8Array(index);\n                        while (index--) {\n                            data[index] = binStr.charCodeAt(index);\n                        }\n                        cb(new Blob([data], { type: type || 'image/png' }));\n                    });\n                },\n            });\n        }\n    }\n\n    var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    var isIOS = isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n    /**\n     * Image Transform Plugin\n     */\n    var plugin = function plugin(_ref) {\n        var addFilter = _ref.addFilter,\n            utils = _ref.utils;\n        var Type = utils.Type,\n            forin = utils.forin,\n            getFileFromBlob = utils.getFileFromBlob,\n            isFile = utils.isFile;\n\n        /**\n         * Helper functions\n         */\n\n        // valid transforms (in correct order)\n        var TRANSFORM_LIST = ['crop', 'resize', 'filter', 'markup', 'output'];\n\n        var createVariantCreator = function createVariantCreator(updateMetadata) {\n            return function(transform, file, metadata) {\n                return transform(file, updateMetadata ? updateMetadata(metadata) : metadata);\n            };\n        };\n\n        var isDefaultCrop = function isDefaultCrop(crop) {\n            return (\n                crop.aspectRatio === null &&\n                crop.rotation === 0 &&\n                crop.zoom === 1 &&\n                crop.center &&\n                crop.center.x === 0.5 &&\n                crop.center.y === 0.5 &&\n                crop.flip &&\n                crop.flip.horizontal === false &&\n                crop.flip.vertical === false\n            );\n        };\n\n        /**\n         * Filters\n         */\n        addFilter('SHOULD_PREPARE_OUTPUT', function(shouldPrepareOutput, _ref2) {\n            var query = _ref2.query;\n            return new Promise(function(resolve) {\n                // If is not async should prepare now\n                resolve(!query('IS_ASYNC'));\n            });\n        });\n\n        var shouldTransformFile = function shouldTransformFile(query, file, item) {\n            return new Promise(function(resolve) {\n                if (\n                    !query('GET_ALLOW_IMAGE_TRANSFORM') ||\n                    item.archived ||\n                    !isFile(file) ||\n                    !isImage(file)\n                ) {\n                    return resolve(false);\n                }\n\n                // if size can't be read this browser doesn't support image\n                getImageSize(file)\n                    .then(function() {\n                        var fn = query('GET_IMAGE_TRANSFORM_IMAGE_FILTER');\n                        if (fn) {\n                            var filterResult = fn(file);\n                            if (filterResult == null) {\n                                // undefined or null\n                                return handleRevert(true);\n                            }\n                            if (typeof filterResult === 'boolean') {\n                                return resolve(filterResult);\n                            }\n                            if (typeof filterResult.then === 'function') {\n                                return filterResult.then(resolve);\n                            }\n                        }\n\n                        resolve(true);\n                    })\n                    .catch(function(err) {\n                        resolve(false);\n                    });\n            });\n        };\n\n        addFilter('DID_CREATE_ITEM', function(item, _ref3) {\n            var query = _ref3.query,\n                dispatch = _ref3.dispatch;\n            if (!query('GET_ALLOW_IMAGE_TRANSFORM')) return;\n\n            item.extend('requestPrepare', function() {\n                return new Promise(function(resolve, reject) {\n                    dispatch(\n                        'REQUEST_PREPARE_OUTPUT',\n                        {\n                            query: item.id,\n                            item: item,\n                            success: resolve,\n                            failure: reject,\n                        },\n\n                        true\n                    );\n                });\n            });\n        });\n\n        // subscribe to file transformations\n        addFilter('PREPARE_OUTPUT', function(file, _ref4) {\n            var query = _ref4.query,\n                item = _ref4.item;\n            return new Promise(function(resolve) {\n                shouldTransformFile(query, file, item).then(function(shouldTransform) {\n                    // no need to transform, exit\n                    if (!shouldTransform) return resolve(file);\n\n                    // get variants\n                    var variants = [];\n\n                    // add original file\n                    if (query('GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_ORIGINAL')) {\n                        variants.push(function() {\n                            return new Promise(function(resolve) {\n                                resolve({\n                                    name: query('GET_IMAGE_TRANSFORM_VARIANTS_ORIGINAL_NAME'),\n                                    file: file,\n                                });\n                            });\n                        });\n                    }\n\n                    // add default output version if output default set to true or if no variants defined\n                    if (query('GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_DEFAULT')) {\n                        variants.push(function(transform, file, metadata) {\n                            return new Promise(function(resolve) {\n                                transform(file, metadata).then(function(file) {\n                                    return resolve({\n                                        name: query('GET_IMAGE_TRANSFORM_VARIANTS_DEFAULT_NAME'),\n\n                                        file: file,\n                                    });\n                                });\n                            });\n                        });\n                    }\n\n                    // get other variants\n                    var variantsDefinition = query('GET_IMAGE_TRANSFORM_VARIANTS') || {};\n                    forin(variantsDefinition, function(key, fn) {\n                        var createVariant = createVariantCreator(fn);\n                        variants.push(function(transform, file, metadata) {\n                            return new Promise(function(resolve) {\n                                createVariant(transform, file, metadata).then(function(file) {\n                                    return resolve({ name: key, file: file });\n                                });\n                            });\n                        });\n                    });\n\n                    // output format (quality 0 => 100)\n                    var qualityAsPercentage = query('GET_IMAGE_TRANSFORM_OUTPUT_QUALITY');\n                    var qualityMode = query('GET_IMAGE_TRANSFORM_OUTPUT_QUALITY_MODE');\n                    var quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;\n                    var type = query('GET_IMAGE_TRANSFORM_OUTPUT_MIME_TYPE');\n                    var clientTransforms =\n                        query('GET_IMAGE_TRANSFORM_CLIENT_TRANSFORMS') || TRANSFORM_LIST;\n\n                    // update transform metadata object\n                    item.setMetadata(\n                        'output',\n                        {\n                            type: type,\n                            quality: quality,\n                            client: clientTransforms,\n                        },\n\n                        true\n                    );\n\n                    // the function that is used to apply the file transformations\n                    var transform = function transform(file, metadata) {\n                        return new Promise(function(resolve, reject) {\n                            var filteredMetadata = Object.assign({}, metadata);\n\n                            Object.keys(filteredMetadata)\n                                .filter(function(instruction) {\n                                    return instruction !== 'exif';\n                                })\n                                .forEach(function(instruction) {\n                                    // if not in list, remove from object, the instruction will be handled by the server\n                                    if (clientTransforms.indexOf(instruction) === -1) {\n                                        delete filteredMetadata[instruction];\n                                    }\n                                });\n                            var resize = filteredMetadata.resize,\n                                exif = filteredMetadata.exif,\n                                output = filteredMetadata.output,\n                                crop = filteredMetadata.crop,\n                                filter = filteredMetadata.filter,\n                                markup = filteredMetadata.markup;\n\n                            var instructions = {\n                                image: {\n                                    orientation: exif ? exif.orientation : null,\n                                },\n\n                                output:\n                                    output &&\n                                    (output.type ||\n                                        typeof output.quality === 'number' ||\n                                        output.background)\n                                        ? {\n                                              type: output.type,\n                                              quality:\n                                                  typeof output.quality === 'number'\n                                                      ? output.quality * 100\n                                                      : null,\n                                              background:\n                                                  output.background ||\n                                                  query(\n                                                      'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n                                                  ) ||\n                                                  null,\n                                          }\n                                        : undefined,\n                                size:\n                                    resize && (resize.size.width || resize.size.height)\n                                        ? Object.assign(\n                                              {\n                                                  mode: resize.mode,\n                                                  upscale: resize.upscale,\n                                              },\n                                              resize.size\n                                          )\n                                        : undefined,\n                                crop:\n                                    crop && !isDefaultCrop(crop)\n                                        ? Object.assign(\n                                              {},\n\n                                              crop\n                                          )\n                                        : undefined,\n                                markup: markup && markup.length ? markup.map(prepareMarkup) : [],\n                                filter: filter,\n                            };\n\n                            if (instructions.output) {\n                                // determine if file type will change\n                                var willChangeType = output.type\n                                    ? // type set\n                                      output.type !== file.type\n                                    : // type not set\n                                      false;\n\n                                var canChangeQuality = /\\/jpe?g$/.test(file.type);\n                                var willChangeQuality =\n                                    output.quality !== null\n                                        ? // quality set\n                                          canChangeQuality && qualityMode === 'always'\n                                        : // quality not set\n                                          false;\n\n                                // determine if file data will be modified\n                                var willModifyImageData = !!(\n                                    instructions.size ||\n                                    instructions.crop ||\n                                    instructions.filter ||\n                                    willChangeType ||\n                                    willChangeQuality\n                                );\n\n                                // if we're not modifying the image data then we don't have to modify the output\n                                if (!willModifyImageData) return resolve(file);\n                            }\n\n                            var options = {\n                                beforeCreateBlob: query('GET_IMAGE_TRANSFORM_BEFORE_CREATE_BLOB'),\n                                afterCreateBlob: query('GET_IMAGE_TRANSFORM_AFTER_CREATE_BLOB'),\n                                canvasMemoryLimit: query('GET_IMAGE_TRANSFORM_CANVAS_MEMORY_LIMIT'),\n                                stripImageHead: query(\n                                    'GET_IMAGE_TRANSFORM_OUTPUT_STRIP_IMAGE_HEAD'\n                                ),\n                            };\n\n                            transformImage(file, instructions, options)\n                                .then(function(blob) {\n                                    // set file object\n                                    var out = getFileFromBlob(\n                                        blob,\n                                        // rename the original filename to match the mime type of the output image\n                                        renameFileToMatchMimeType(\n                                            file.name,\n                                            getValidOutputMimeType(blob.type)\n                                        )\n                                    );\n\n                                    resolve(out);\n                                })\n                                .catch(reject);\n                        });\n                    };\n\n                    // start creating variants\n                    var variantPromises = variants.map(function(create) {\n                        return create(transform, file, item.getMetadata());\n                    });\n\n                    // wait for results\n                    Promise.all(variantPromises).then(function(files) {\n                        // if single file object in array, return the single file object else, return array of\n                        resolve(\n                            files.length === 1 && files[0].name === null\n                                ? // return the File object\n                                  files[0].file\n                                : // return an array of files { name:'name', file:File }\n                                  files\n                        );\n                    });\n                });\n            });\n        });\n\n        // Expose plugin options\n        return {\n            options: {\n                allowImageTransform: [true, Type.BOOLEAN],\n\n                // filter images to transform\n                imageTransformImageFilter: [null, Type.FUNCTION],\n\n                // null, 'image/jpeg', 'image/png'\n                imageTransformOutputMimeType: [null, Type.STRING],\n\n                // null, 0 - 100\n                imageTransformOutputQuality: [null, Type.INT],\n\n                // set to false to copy image exif data to output\n                imageTransformOutputStripImageHead: [true, Type.BOOLEAN],\n\n                // only apply transforms in this list\n                imageTransformClientTransforms: [null, Type.ARRAY],\n\n                // only apply output quality when a transform is required\n                imageTransformOutputQualityMode: ['always', Type.STRING],\n                // 'always'\n                // 'optional'\n                // 'mismatch' (future feature, only applied if quality differs from input)\n\n                // get image transform variants\n                imageTransformVariants: [null, Type.OBJECT],\n\n                // should we post the default transformed file\n                imageTransformVariantsIncludeDefault: [true, Type.BOOLEAN],\n\n                // which name to prefix the default transformed file with\n                imageTransformVariantsDefaultName: [null, Type.STRING],\n\n                // should we post the original file\n                imageTransformVariantsIncludeOriginal: [false, Type.BOOLEAN],\n\n                // which name to prefix the original file with\n                imageTransformVariantsOriginalName: ['original_', Type.STRING],\n\n                // called before creating the blob, receives canvas, expects promise resolve with canvas\n                imageTransformBeforeCreateBlob: [null, Type.FUNCTION],\n\n                // expects promise resolved with blob\n                imageTransformAfterCreateBlob: [null, Type.FUNCTION],\n\n                // canvas memory limit\n                imageTransformCanvasMemoryLimit: [\n                    isBrowser && isIOS ? 4096 * 4096 : null,\n                    Type.INT,\n                ],\n\n                // background image of the output canvas\n                imageTransformCanvasBackgroundColor: [null, Type.STRING],\n            },\n        };\n    };\n\n    // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n    if (isBrowser) {\n        document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n    }\n\n    return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXRyYW5zZm9ybS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS10cmFuc2Zvcm0uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEU7QUFDQSxVQUFVLENBRThFO0FBQ3hGLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CLFFBQVEsU0FBUyxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwRUFBMEU7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0JBQWtCO0FBQzlDLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBOztBQUVBLGtFQUFrRSwyQkFBMkI7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxnQ0FBZ0M7QUFDakc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQXlDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EscURBQXFELHdCQUF3QjtBQUM3RTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjs7QUFFMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELCtCQUErQjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RCxrQ0FBa0M7QUFDOUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MseUJBQXlCO0FBQ2pFLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsdUJBQXVCO0FBQzVFLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtdHJhbnNmb3JtL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXRyYW5zZm9ybS5qcz85YmE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVRyYW5zZm9ybSAzLjguN1xuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgICAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCAoZ2xvYmFsLkZpbGVQb25kUGx1Z2luSW1hZ2VUcmFuc2Zvcm0gPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIHRlc3QgaWYgZmlsZSBpcyBvZiB0eXBlIGltYWdlXG4gICAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiBpc0ltYWdlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIC9eaW1hZ2UvLnRlc3QoZmlsZS50eXBlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG4gICAgfTtcblxuICAgIC8vIG9ubHkgaGFuZGxlcyBpbWFnZS9qcGcsIGltYWdlL2pwZWcsIGltYWdlL3BuZywgYW5kIGltYWdlL3N2Zyt4bWwgZm9yIG5vd1xuICAgIHZhciBFeHRlbnNpb25NYXAgPSB7XG4gICAgICAgIGpwZWc6ICdqcGcnLFxuICAgICAgICAnc3ZnK3htbCc6ICdzdmcnLFxuICAgIH07XG5cbiAgICB2YXIgcmVuYW1lRmlsZVRvTWF0Y2hNaW1lVHlwZSA9IGZ1bmN0aW9uIHJlbmFtZUZpbGVUb01hdGNoTWltZVR5cGUoZmlsZW5hbWUsIG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtaW1lVHlwZS5zcGxpdCgnLycpWzFdO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gRXh0ZW5zaW9uTWFwW3R5cGVdIHx8IHR5cGU7XG4gICAgICAgIHJldHVybiAnJy5jb25jYXQobmFtZSwgJy4nKS5jb25jYXQoZXh0ZW5zaW9uKTtcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJucyBhbGwgdGhlIHZhbGlkIG91dHB1dCBmb3JtYXRzIHdlIGNhbiBlbmNvZGUgdG93YXJkc1xuICAgIHZhciBnZXRWYWxpZE91dHB1dE1pbWVUeXBlID0gZnVuY3Rpb24gZ2V0VmFsaWRPdXRwdXRNaW1lVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAvanBlZ3xwbmd8c3ZnXFwreG1sLy50ZXN0KHR5cGUpID8gdHlwZSA6ICdpbWFnZS9qcGVnJztcbiAgICB9O1xuXG4gICAgLy8gdGVzdCBpZiBmaWxlIGlzIG9mIHR5cGUgaW1hZ2VcbiAgICB2YXIgaXNJbWFnZSQxID0gZnVuY3Rpb24gaXNJbWFnZShmaWxlKSB7XG4gICAgICAgIHJldHVybiAvXmltYWdlLy50ZXN0KGZpbGUudHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBNQVRSSUNFUyA9IHtcbiAgICAgICAgMTogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgIH0sXG4gICAgICAgIDI6IGZ1bmN0aW9uIF8od2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbLTEsIDAsIDAsIDEsIHdpZHRoLCAwXTtcbiAgICAgICAgfSxcbiAgICAgICAgMzogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMSwgd2lkdGgsIGhlaWdodF07XG4gICAgICAgIH0sXG4gICAgICAgIDQ6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAtMSwgMCwgaGVpZ2h0XTtcbiAgICAgICAgfSxcbiAgICAgICAgNTogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMSwgMSwgMCwgMCwgMF07XG4gICAgICAgIH0sXG4gICAgICAgIDY6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxLCAtMSwgMCwgaGVpZ2h0LCAwXTtcbiAgICAgICAgfSxcbiAgICAgICAgNzogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIC0xLCAtMSwgMCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgIH0sXG4gICAgICAgIDg6IGZ1bmN0aW9uIF8od2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgLTEsIDEsIDAsIDAsIHdpZHRoXTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIGdldEltYWdlT3JpZW50YXRpb25NYXRyaXggPSBmdW5jdGlvbiBnZXRJbWFnZU9yaWVudGF0aW9uTWF0cml4KHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTUFUUklDRVNbb3JpZW50YXRpb25dKHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVmVjdG9yID0gZnVuY3Rpb24gY3JlYXRlVmVjdG9yKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG5cbiAgICB2YXIgdmVjdG9yRG90ID0gZnVuY3Rpb24gdmVjdG9yRG90KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueTtcbiAgICB9O1xuXG4gICAgdmFyIHZlY3RvclN1YnRyYWN0ID0gZnVuY3Rpb24gdmVjdG9yU3VidHJhY3QoYSwgYikge1xuICAgICAgICByZXR1cm4gY3JlYXRlVmVjdG9yKGEueCAtIGIueCwgYS55IC0gYi55KTtcbiAgICB9O1xuXG4gICAgdmFyIHZlY3RvckRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uIHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XG4gICAgICAgIHJldHVybiB2ZWN0b3JEb3QodmVjdG9yU3VidHJhY3QoYSwgYiksIHZlY3RvclN1YnRyYWN0KGEsIGIpKTtcbiAgICB9O1xuXG4gICAgdmFyIHZlY3RvckRpc3RhbmNlID0gZnVuY3Rpb24gdmVjdG9yRGlzdGFuY2UoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRPZmZzZXRQb2ludE9uRWRnZSA9IGZ1bmN0aW9uIGdldE9mZnNldFBvaW50T25FZGdlKGxlbmd0aCwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIGEgPSBsZW5ndGg7XG5cbiAgICAgICAgdmFyIEEgPSAxLjU3MDc5NjMyNjc5NDg5NjY7XG4gICAgICAgIHZhciBCID0gcm90YXRpb247XG4gICAgICAgIHZhciBDID0gMS41NzA3OTYzMjY3OTQ4OTY2IC0gcm90YXRpb247XG5cbiAgICAgICAgdmFyIHNpbkEgPSBNYXRoLnNpbihBKTtcbiAgICAgICAgdmFyIHNpbkIgPSBNYXRoLnNpbihCKTtcbiAgICAgICAgdmFyIHNpbkMgPSBNYXRoLnNpbihDKTtcbiAgICAgICAgdmFyIGNvc0MgPSBNYXRoLmNvcyhDKTtcbiAgICAgICAgdmFyIHJhdGlvID0gYSAvIHNpbkE7XG4gICAgICAgIHZhciBiID0gcmF0aW8gKiBzaW5CO1xuICAgICAgICB2YXIgYyA9IHJhdGlvICogc2luQztcblxuICAgICAgICByZXR1cm4gY3JlYXRlVmVjdG9yKGNvc0MgKiBiLCBjb3NDICogYyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRSb3RhdGVkUmVjdFNpemUgPSBmdW5jdGlvbiBnZXRSb3RhdGVkUmVjdFNpemUocmVjdCwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIHcgPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgaCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBob3IgPSBnZXRPZmZzZXRQb2ludE9uRWRnZSh3LCByb3RhdGlvbik7XG4gICAgICAgIHZhciB2ZXIgPSBnZXRPZmZzZXRQb2ludE9uRWRnZShoLCByb3RhdGlvbik7XG5cbiAgICAgICAgdmFyIHRsID0gY3JlYXRlVmVjdG9yKHJlY3QueCArIE1hdGguYWJzKGhvci54KSwgcmVjdC55IC0gTWF0aC5hYnMoaG9yLnkpKTtcblxuICAgICAgICB2YXIgdHIgPSBjcmVhdGVWZWN0b3IocmVjdC54ICsgcmVjdC53aWR0aCArIE1hdGguYWJzKHZlci55KSwgcmVjdC55ICsgTWF0aC5hYnModmVyLngpKTtcblxuICAgICAgICB2YXIgYmwgPSBjcmVhdGVWZWN0b3IocmVjdC54IC0gTWF0aC5hYnModmVyLnkpLCByZWN0LnkgKyByZWN0LmhlaWdodCAtIE1hdGguYWJzKHZlci54KSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB2ZWN0b3JEaXN0YW5jZSh0bCwgdHIpLFxuICAgICAgICAgICAgaGVpZ2h0OiB2ZWN0b3JEaXN0YW5jZSh0bCwgYmwpLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SW1hZ2VSZWN0Wm9vbUZhY3RvciA9IGZ1bmN0aW9uIGdldEltYWdlUmVjdFpvb21GYWN0b3IoaW1hZ2VSZWN0LCBjcm9wUmVjdCkge1xuICAgICAgICB2YXIgcm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciBjZW50ZXIgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7IHg6IDAuNSwgeTogMC41IH07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGF2YWlsYWJsZSBzcGFjZSByb3VuZCBpbWFnZSBjZW50ZXIgcG9zaXRpb25cbiAgICAgICAgdmFyIGN4ID0gY2VudGVyLnggPiAwLjUgPyAxIC0gY2VudGVyLnggOiBjZW50ZXIueDtcbiAgICAgICAgdmFyIGN5ID0gY2VudGVyLnkgPiAwLjUgPyAxIC0gY2VudGVyLnkgOiBjZW50ZXIueTtcbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSBjeCAqIDIgKiBpbWFnZVJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGN5ICogMiAqIGltYWdlUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgY3JvcCByZWN0YW5nbGUgc2l6ZVxuICAgICAgICB2YXIgcm90YXRlZENyb3BTaXplID0gZ2V0Um90YXRlZFJlY3RTaXplKGNyb3BSZWN0LCByb3RhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvdGF0ZWRDcm9wU2l6ZS53aWR0aCAvIGltYWdlV2lkdGgsIHJvdGF0ZWRDcm9wU2l6ZS5oZWlnaHQgLyBpbWFnZUhlaWdodCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRDZW50ZXJlZENyb3BSZWN0ID0gZnVuY3Rpb24gZ2V0Q2VudGVyZWRDcm9wUmVjdChjb250YWluZXIsIGFzcGVjdFJhdGlvKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChoZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IChjb250YWluZXIud2lkdGggLSB3aWR0aCkgKiAwLjU7XG4gICAgICAgIHZhciB5ID0gKGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQpICogMC41O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2UsIGNhbnZhc0FzcGVjdFJhdGlvKSB7XG4gICAgICAgIHZhciB6b29tID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gICAgICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGFjdHVhbCBwaXhlbHMgb24geCBhbmQgeSBheGlzXG4gICAgICAgIHZhciBjYW52YXNXaWR0aCA9IDE7XG4gICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBjYW52YXNBc3BlY3RSYXRpbztcbiAgICAgICAgdmFyIGltZ1dpZHRoID0gMTtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltYWdlQXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChpbWdIZWlnaHQgPiBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIGltZ0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIGltZ1dpZHRoID0gaW1nSGVpZ2h0IC8gaW1hZ2VBc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsYXIgPSBNYXRoLm1heChjYW52YXNXaWR0aCAvIGltZ1dpZHRoLCBjYW52YXNIZWlnaHQgLyBpbWdIZWlnaHQpO1xuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCAvICh6b29tICogc2NhbGFyICogaW1nV2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggKiBjYW52YXNBc3BlY3RSYXRpbztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjYW52YXNSZWxlYXNlID0gZnVuY3Rpb24gY2FudmFzUmVsZWFzZShjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRmxpcHBlZCA9IGZ1bmN0aW9uIGlzRmxpcHBlZChmbGlwKSB7XG4gICAgICAgIHJldHVybiBmbGlwICYmIChmbGlwLmhvcml6b250YWwgfHwgZmxpcC52ZXJ0aWNhbCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCaXRtYXAgPSBmdW5jdGlvbiBnZXRCaXRtYXAoaW1hZ2UsIG9yaWVudGF0aW9uLCBmbGlwKSB7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA8PSAxICYmICFpc0ZsaXBwZWQoZmxpcCkpIHtcbiAgICAgICAgICAgIGltYWdlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcblxuICAgICAgICAvLyBpZiBpcyByb3RhdGVkIGluY29ycmVjdGx5IHN3YXAgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICB2YXIgc3dhcHBlZCA9IG9yaWVudGF0aW9uID49IDUgJiYgb3JpZW50YXRpb24gPD0gODtcbiAgICAgICAgaWYgKHN3YXBwZWQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlIGJ1dCBmaXJzdCBmaXggb3JpZW50YXRpb24gYW5kIHNldCBjb3JyZWN0IGZsaXBcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIC8vIGdldCBiYXNlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgICBpZiAob3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBnZXRJbWFnZU9yaWVudGF0aW9uTWF0cml4KHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGbGlwcGVkKGZsaXApKSB7XG4gICAgICAgICAgICAvLyBmbGlwIGhvcml6b250YWxcbiAgICAgICAgICAgIC8vIFstMSwgMCwgMCwgMSwgd2lkdGgsIDBdXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgaWYgKCghc3dhcHBlZCAmJiBmbGlwLmhvcml6b250YWwpIHx8IHN3YXBwZWQgJiBmbGlwLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4WzBdID0gLTE7XG4gICAgICAgICAgICAgICAgbWF0cml4WzRdID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZsaXAgdmVydGljYWxcbiAgICAgICAgICAgIC8vIFsxLCAwLCAwLCAtMSwgMCwgaGVpZ2h0XVxuICAgICAgICAgICAgaWYgKCghc3dhcHBlZCAmJiBmbGlwLnZlcnRpY2FsKSB8fCAoc3dhcHBlZCAmJiBmbGlwLmhvcml6b250YWwpKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4WzNdID0gLTE7XG4gICAgICAgICAgICAgICAgbWF0cml4WzVdID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgbWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIHZhciBpbWFnZVRvSW1hZ2VEYXRhID0gZnVuY3Rpb24gaW1hZ2VUb0ltYWdlRGF0YShpbWFnZUVsZW1lbnQsIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciBjcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgICB2YXIgY2FudmFzTWVtb3J5TGltaXQgPSBvcHRpb25zLmNhbnZhc01lbW9yeUxpbWl0LFxuICAgICAgICAgICAgX29wdGlvbnMkYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZCxcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBfb3B0aW9ucyRiYWNrZ3JvdW5kID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnMkYmFja2dyb3VuZDtcblxuICAgICAgICB2YXIgem9vbSA9IGNyb3Auem9vbSB8fCAxO1xuXG4gICAgICAgIC8vIGZpeGVzIHBvc3NpYmxlIGltYWdlIG9yaWVudGF0aW9uIHByb2JsZW1zIGJ5IGRyYXdpbmcgdGhlIGltYWdlIG9uIHRoZSBjb3JyZWN0IGNhbnZhc1xuICAgICAgICB2YXIgYml0bWFwID0gZ2V0Qml0bWFwKGltYWdlRWxlbWVudCwgb3JpZW50YXRpb24sIGNyb3AuZmxpcCk7XG4gICAgICAgIHZhciBpbWFnZVNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogYml0bWFwLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiaXRtYXAuaGVpZ2h0LFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW8gfHwgaW1hZ2VTaXplLmhlaWdodCAvIGltYWdlU2l6ZS53aWR0aDtcblxuICAgICAgICB2YXIgY2FudmFzU2l6ZSA9IGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2VTaXplLCBhc3BlY3RSYXRpbywgem9vbSk7XG5cbiAgICAgICAgaWYgKGNhbnZhc01lbW9yeUxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWRNZW1vcnkgPSBjYW52YXNTaXplLndpZHRoICogY2FudmFzU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWRNZW1vcnkgPiBjYW52YXNNZW1vcnlMaW1pdCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2FsYXIgPSBNYXRoLnNxcnQoY2FudmFzTWVtb3J5TGltaXQpIC8gTWF0aC5zcXJ0KHJlcXVpcmVkTWVtb3J5KTtcbiAgICAgICAgICAgICAgICBpbWFnZVNpemUud2lkdGggPSBNYXRoLmZsb29yKGltYWdlU2l6ZS53aWR0aCAqIHNjYWxhcik7XG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplLmhlaWdodCA9IE1hdGguZmxvb3IoaW1hZ2VTaXplLmhlaWdodCAqIHNjYWxhcik7XG4gICAgICAgICAgICAgICAgY2FudmFzU2l6ZSA9IGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2VTaXplLCBhc3BlY3RSYXRpbywgem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgdmFyIGNhbnZhc0NlbnRlciA9IHtcbiAgICAgICAgICAgIHg6IGNhbnZhc1NpemUud2lkdGggKiAwLjUsXG4gICAgICAgICAgICB5OiBjYW52YXNTaXplLmhlaWdodCAqIDAuNSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RhZ2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiBjYW52YXNTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgICAgIGNlbnRlcjogY2FudmFzQ2VudGVyLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaG91bGRMaW1pdCA9IHR5cGVvZiBjcm9wLnNjYWxlVG9GaXQgPT09ICd1bmRlZmluZWQnIHx8IGNyb3Auc2NhbGVUb0ZpdDtcblxuICAgICAgICB2YXIgc2NhbGUgPVxuICAgICAgICAgICAgem9vbSAqXG4gICAgICAgICAgICBnZXRJbWFnZVJlY3Rab29tRmFjdG9yKFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICBnZXRDZW50ZXJlZENyb3BSZWN0KHN0YWdlLCBhc3BlY3RSYXRpbyksXG4gICAgICAgICAgICAgICAgY3JvcC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzaG91bGRMaW1pdCA/IGNyb3AuY2VudGVyIDogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIC8vIHN0YXJ0IGRyYXdpbmdcbiAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZChjYW52YXNTaXplLndpZHRoIC8gc2NhbGUpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlKTtcblxuICAgICAgICBjYW52YXNDZW50ZXIueCAvPSBzY2FsZTtcbiAgICAgICAgY2FudmFzQ2VudGVyLnkgLz0gc2NhbGU7XG5cbiAgICAgICAgdmFyIGltYWdlT2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogY2FudmFzQ2VudGVyLnggLSBpbWFnZVNpemUud2lkdGggKiAoY3JvcC5jZW50ZXIgPyBjcm9wLmNlbnRlci54IDogMC41KSxcbiAgICAgICAgICAgIHk6IGNhbnZhc0NlbnRlci55IC0gaW1hZ2VTaXplLmhlaWdodCAqIChjcm9wLmNlbnRlciA/IGNyb3AuY2VudGVyLnkgOiAwLjUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHRvIGRyYXcgb2Zmc2V0XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2FudmFzQ2VudGVyLngsIGNhbnZhc0NlbnRlci55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShjcm9wLnJvdGF0aW9uIHx8IDApO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBiaXRtYXAsXG4gICAgICAgICAgICBpbWFnZU9mZnNldC54IC0gY2FudmFzQ2VudGVyLngsXG4gICAgICAgICAgICBpbWFnZU9mZnNldC55IC0gY2FudmFzQ2VudGVyLnksXG4gICAgICAgICAgICBpbWFnZVNpemUud2lkdGgsXG4gICAgICAgICAgICBpbWFnZVNpemUuaGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZ2V0IGRhdGEgZnJvbSBjYW52YXNcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyByZWxlYXNlIGNhbnZhc1xuICAgICAgICBjYW52YXNSZWxlYXNlKGNhbnZhcyk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGRhdGFcbiAgICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgdG9CbG9iIGZvciBFZGdlXG4gICAgICovXG4gICAgdmFyIElTX0JST1dTRVIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgICB9KSgpO1xuICAgIGlmIChJU19CUk9XU0VSKSB7XG4gICAgICAgIGlmICghSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLnRvQmxvYikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSwgJ3RvQmxvYicsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFVUkwgPSB0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpblN0ciA9IGF0b2IoZGF0YVVSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYmluU3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEJsb2IoW2Fycl0sIHsgdHlwZTogdHlwZSB8fCAnaW1hZ2UvcG5nJyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYW52YXNUb0Jsb2IgPSBmdW5jdGlvbiBjYW52YXNUb0Jsb2IoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBiZWZvcmVDcmVhdGVCbG9iID1cbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlZEltYWdlID0gYmVmb3JlQ3JlYXRlQmxvYiA/IGJlZm9yZUNyZWF0ZUJsb2IoY2FudmFzKSA6IGNhbnZhcztcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlZEltYWdlKS50aGVuKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgb3B0aW9ucy50eXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgdmVjdG9yTXVsdGlwbHkgPSBmdW5jdGlvbiB2ZWN0b3JNdWx0aXBseSh2LCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZlY3RvciQxKHYueCAqIGFtb3VudCwgdi55ICogYW1vdW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHZlY3RvckFkZCA9IGZ1bmN0aW9uIHZlY3RvckFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMShhLnggKyBiLngsIGEueSArIGIueSk7XG4gICAgfTtcblxuICAgIHZhciB2ZWN0b3JOb3JtYWxpemUgPSBmdW5jdGlvbiB2ZWN0b3JOb3JtYWxpemUodikge1xuICAgICAgICB2YXIgbCA9IE1hdGguc3FydCh2LnggKiB2LnggKyB2LnkgKiB2LnkpO1xuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMSh2LnggLyBsLCB2LnkgLyBsKTtcbiAgICB9O1xuXG4gICAgdmFyIHZlY3RvclJvdGF0ZSA9IGZ1bmN0aW9uIHZlY3RvclJvdGF0ZSh2LCByYWRpYW5zLCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgICAgIHZhciB0ID0gY3JlYXRlVmVjdG9yJDEodi54IC0gb3JpZ2luLngsIHYueSAtIG9yaWdpbi55KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZlY3RvciQxKG9yaWdpbi54ICsgY29zICogdC54IC0gc2luICogdC55LCBvcmlnaW4ueSArIHNpbiAqIHQueCArIGNvcyAqIHQueSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVWZWN0b3IkMSA9IGZ1bmN0aW9uIGNyZWF0ZVZlY3RvcigpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcblxuICAgIHZhciBnZXRNYXJrdXBWYWx1ZSA9IGZ1bmN0aW9uIGdldE1hcmt1cFZhbHVlKHZhbHVlLCBzaXplKSB7XG4gICAgICAgIHZhciBzY2FsYXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBheGlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgKiBzY2FsYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAqIChheGlzID8gc2l6ZVtheGlzXSA6IE1hdGgubWluKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TWFya3VwU3R5bGVzID0gZnVuY3Rpb24gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICAgICAgdmFyIGxpbmVTdHlsZSA9IG1hcmt1cC5ib3JkZXJTdHlsZSB8fCBtYXJrdXAubGluZVN0eWxlIHx8ICdzb2xpZCc7XG4gICAgICAgIHZhciBmaWxsID0gbWFya3VwLmJhY2tncm91bmRDb2xvciB8fCBtYXJrdXAuZm9udENvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHZhciBzdHJva2UgPSBtYXJrdXAuYm9yZGVyQ29sb3IgfHwgbWFya3VwLmxpbmVDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSBnZXRNYXJrdXBWYWx1ZShtYXJrdXAuYm9yZGVyV2lkdGggfHwgbWFya3VwLmxpbmVXaWR0aCwgc2l6ZSwgc2NhbGUpO1xuICAgICAgICB2YXIgbGluZUNhcCA9IG1hcmt1cC5saW5lQ2FwIHx8ICdyb3VuZCc7XG4gICAgICAgIHZhciBsaW5lSm9pbiA9IG1hcmt1cC5saW5lSm9pbiB8fCAncm91bmQnO1xuICAgICAgICB2YXIgZGFzaGVzID1cbiAgICAgICAgICAgIHR5cGVvZiBsaW5lU3R5bGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogbGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYXJrdXBWYWx1ZSh2LCBzaXplLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IG1hcmt1cC5vcGFjaXR5IHx8IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiBsaW5lQ2FwLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lam9pbic6IGxpbmVKb2luLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDAsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGRhc2hlcyxcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRNYXJrdXBSZWN0ID0gZnVuY3Rpb24gZ2V0TWFya3VwUmVjdChyZWN0LCBzaXplKSB7XG4gICAgICAgIHZhciBzY2FsYXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgICAgICAgdmFyIGxlZnQgPVxuICAgICAgICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC54LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpIHx8XG4gICAgICAgICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LmxlZnQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgICAgIHZhciB0b3AgPVxuICAgICAgICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC55LCBzaXplLCBzY2FsYXIsICdoZWlnaHQnKSB8fFxuICAgICAgICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC50b3AsIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuICAgICAgICB2YXIgd2lkdGggPSBnZXRNYXJrdXBWYWx1ZShyZWN0LndpZHRoLCBzaXplLCBzY2FsYXIsICd3aWR0aCcpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZ2V0TWFya3VwVmFsdWUocmVjdC5oZWlnaHQsIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuICAgICAgICB2YXIgcmlnaHQgPSBnZXRNYXJrdXBWYWx1ZShyZWN0LnJpZ2h0LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpO1xuICAgICAgICB2YXIgYm90dG9tID0gZ2V0TWFya3VwVmFsdWUocmVjdC5ib3R0b20sIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuXG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRvcCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHNpemUuaGVpZ2h0IC0gaGVpZ2h0IC0gYm90dG9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRGVmaW5lZChsZWZ0KSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh3aWR0aCkgJiYgaXNEZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzaXplLndpZHRoIC0gd2lkdGggLSByaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0RlZmluZWQod2lkdGgpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnQpICYmIGlzRGVmaW5lZChyaWdodCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGggLSBsZWZ0IC0gcmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodG9wKSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0IC0gdG9wIC0gYm90dG9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGxlZnQgfHwgMCxcbiAgICAgICAgICAgIHk6IHRvcCB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcG9pbnRzVG9QYXRoU2hhcGUgPSBmdW5jdGlvbiBwb2ludHNUb1BhdGhTaGFwZShwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChpbmRleCA9PT0gMCA/ICdNJyA6ICdMJywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHBvaW50LngsICcgJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwb2ludC55KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIHZhciBzdmcgPSBmdW5jdGlvbiBzdmcodGFnLCBhdHRyKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpO1xuICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVJlY3QgPSBmdW5jdGlvbiB1cGRhdGVSZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcykpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRWxsaXBzZSA9IGZ1bmN0aW9uIHVwZGF0ZUVsbGlwc2UoZWxlbWVudCkge1xuICAgICAgICB2YXIgY3ggPSBlbGVtZW50LnJlY3QueCArIGVsZW1lbnQucmVjdC53aWR0aCAqIDAuNTtcbiAgICAgICAgdmFyIGN5ID0gZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgcnggPSBlbGVtZW50LnJlY3Qud2lkdGggKiAwLjU7XG4gICAgICAgIHZhciByeSA9IGVsZW1lbnQucmVjdC5oZWlnaHQgKiAwLjU7XG4gICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcng6IHJ4LFxuICAgICAgICAgICAgICAgICAgICByeTogcnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgSU1BR0VfRklUX1NUWUxFID0ge1xuICAgICAgICBjb250YWluOiAneE1pZFlNaWQgbWVldCcsXG4gICAgICAgIGNvdmVyOiAneE1pZFlNaWQgc2xpY2UnLFxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlSW1hZ2UgPSBmdW5jdGlvbiB1cGRhdGVJbWFnZShlbGVtZW50LCBtYXJrdXApIHtcbiAgICAgICAgc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50LnJlY3QsIGVsZW1lbnQuc3R5bGVzLCB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogSU1BR0VfRklUX1NUWUxFW21hcmt1cC5maXRdIHx8ICdub25lJyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBURVhUX0FOQ0hPUiA9IHtcbiAgICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgICAgY2VudGVyOiAnbWlkZGxlJyxcbiAgICAgICAgcmlnaHQ6ICdlbmQnLFxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlVGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZVRleHQoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgICAgICB2YXIgZm9udFNpemUgPSBnZXRNYXJrdXBWYWx1ZShtYXJrdXAuZm9udFNpemUsIHNpemUsIHNjYWxlKTtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBtYXJrdXAuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7XG4gICAgICAgIHZhciBmb250V2VpZ2h0ID0gbWFya3VwLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSBURVhUX0FOQ0hPUlttYXJrdXAudGV4dEFsaWduXSB8fCAnc3RhcnQnO1xuXG4gICAgICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxuICAgICAgICAgICAgICAgICdmb250LXdlaWdodCc6IGZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IGZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogdGV4dEFsaWduLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGV4dFxuICAgICAgICBpZiAoZWxlbWVudC50ZXh0ICE9PSBtYXJrdXAudGV4dCkge1xuICAgICAgICAgICAgZWxlbWVudC50ZXh0ID0gbWFya3VwLnRleHQ7XG4gICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gbWFya3VwLnRleHQubGVuZ3RoID8gbWFya3VwLnRleHQgOiAnICc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUxpbmUgPSBmdW5jdGlvbiB1cGRhdGVMaW5lKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50LnJlY3QsIGVsZW1lbnQuc3R5bGVzLCB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbGluZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdmFyIGJlZ2luID0gZWxlbWVudC5jaGlsZE5vZGVzWzFdO1xuICAgICAgICB2YXIgZW5kID0gZWxlbWVudC5jaGlsZE5vZGVzWzJdO1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSBlbGVtZW50LnJlY3Q7XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgICAgIHg6IGVsZW1lbnQucmVjdC54ICsgZWxlbWVudC5yZWN0LndpZHRoLFxuICAgICAgICAgICAgeTogZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0LFxuICAgICAgICB9O1xuXG4gICAgICAgIHNldEF0dHJpYnV0ZXMobGluZSwge1xuICAgICAgICAgICAgeDE6IG9yaWdpbi54LFxuICAgICAgICAgICAgeTE6IG9yaWdpbi55LFxuICAgICAgICAgICAgeDI6IHRhcmdldC54LFxuICAgICAgICAgICAgeTI6IHRhcmdldC55LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1hcmt1cC5saW5lRGVjb3JhdGlvbikgcmV0dXJuO1xuXG4gICAgICAgIGJlZ2luLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGVuZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgIHZhciB2ID0gdmVjdG9yTm9ybWFsaXplKHtcbiAgICAgICAgICAgIHg6IHRhcmdldC54IC0gb3JpZ2luLngsXG4gICAgICAgICAgICB5OiB0YXJnZXQueSAtIG9yaWdpbi55LFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbCA9IGdldE1hcmt1cFZhbHVlKDAuMDUsIHNpemUsIHNjYWxlKTtcblxuICAgICAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWJlZ2luJykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCBsKTtcbiAgICAgICAgICAgIHZhciBhcnJvd0JlZ2luQ2VudGVyID0gdmVjdG9yQWRkKG9yaWdpbiwgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGFycm93QmVnaW5BID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgMiwgYXJyb3dCZWdpbkNlbnRlcik7XG4gICAgICAgICAgICB2YXIgYXJyb3dCZWdpbkIgPSB2ZWN0b3JSb3RhdGUob3JpZ2luLCAtMiwgYXJyb3dCZWdpbkNlbnRlcik7XG5cbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZXMoYmVnaW4sIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2Rpc3BsYXk6YmxvY2s7JyxcbiAgICAgICAgICAgICAgICBkOiAnTSdcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhcnJvd0JlZ2luQS54LCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYXJyb3dCZWdpbkEueSwgJyBMJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChvcmlnaW4ueCwgJywnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG9yaWdpbi55LCAnIEwnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5CLngsICcsJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhcnJvd0JlZ2luQi55KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmt1cC5saW5lRGVjb3JhdGlvbi5pbmRleE9mKCdhcnJvdy1lbmQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBhcnJvd0VuZFJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCAtbCk7XG4gICAgICAgICAgICB2YXIgYXJyb3dFbmRDZW50ZXIgPSB2ZWN0b3JBZGQodGFyZ2V0LCBhcnJvd0VuZFJvdGF0aW9uUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGFycm93RW5kQSA9IHZlY3RvclJvdGF0ZSh0YXJnZXQsIDIsIGFycm93RW5kQ2VudGVyKTtcbiAgICAgICAgICAgIHZhciBhcnJvd0VuZEIgPSB2ZWN0b3JSb3RhdGUodGFyZ2V0LCAtMiwgYXJyb3dFbmRDZW50ZXIpO1xuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGVzKGVuZCwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZGlzcGxheTpibG9jazsnLFxuICAgICAgICAgICAgICAgIGQ6ICdNJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFycm93RW5kQS54LCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYXJyb3dFbmRBLnksICcgTCcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGFyZ2V0LngsICcsJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0YXJnZXQueSwgJyBMJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEIueCwgJywnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFycm93RW5kQi55KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVQYXRoID0gZnVuY3Rpb24gdXBkYXRlUGF0aChlbGVtZW50LCBtYXJrdXAsIHNpemUsIHNjYWxlKSB7XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5zdHlsZXMsIHtcbiAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgZDogcG9pbnRzVG9QYXRoU2hhcGUoXG4gICAgICAgICAgICAgICAgICAgIG1hcmt1cC5wb2ludHMubWFwKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGdldE1hcmt1cFZhbHVlKHBvaW50LngsIHNpemUsIHNjYWxlLCAnd2lkdGgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBnZXRNYXJrdXBWYWx1ZShwb2ludC55LCBzaXplLCBzY2FsZSwgJ2hlaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gY3JlYXRlU2hhcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ZnKG5vZGUsIHsgaWQ6IG1hcmt1cC5pZCB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUltYWdlID0gZnVuY3Rpb24gY3JlYXRlSW1hZ2UobWFya3VwKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IHN2ZygnaW1hZ2UnLCB7XG4gICAgICAgICAgICBpZDogbWFya3VwLmlkLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLFxuICAgICAgICAgICAgb3BhY2l0eTogJzAnLFxuICAgICAgICB9KTtcblxuICAgICAgICBzaGFwZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIG1hcmt1cC5vcGFjaXR5IHx8IDEpO1xuICAgICAgICB9O1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICd4bGluazpocmVmJywgbWFya3VwLnNyYyk7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUxpbmUgPSBmdW5jdGlvbiBjcmVhdGVMaW5lKG1hcmt1cCkge1xuICAgICAgICB2YXIgc2hhcGUgPSBzdmcoJ2cnLCB7XG4gICAgICAgICAgICBpZDogbWFya3VwLmlkLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbGluZSA9IHN2ZygnbGluZScpO1xuICAgICAgICBzaGFwZS5hcHBlbmRDaGlsZChsaW5lKTtcblxuICAgICAgICB2YXIgYmVnaW4gPSBzdmcoJ3BhdGgnKTtcbiAgICAgICAgc2hhcGUuYXBwZW5kQ2hpbGQoYmVnaW4pO1xuXG4gICAgICAgIHZhciBlbmQgPSBzdmcoJ3BhdGgnKTtcbiAgICAgICAgc2hhcGUuYXBwZW5kQ2hpbGQoZW5kKTtcblxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfTtcblxuICAgIHZhciBDUkVBVEVfVFlQRV9ST1VURVMgPSB7XG4gICAgICAgIGltYWdlOiBjcmVhdGVJbWFnZSxcbiAgICAgICAgcmVjdDogY3JlYXRlU2hhcGUoJ3JlY3QnKSxcbiAgICAgICAgZWxsaXBzZTogY3JlYXRlU2hhcGUoJ2VsbGlwc2UnKSxcbiAgICAgICAgdGV4dDogY3JlYXRlU2hhcGUoJ3RleHQnKSxcbiAgICAgICAgcGF0aDogY3JlYXRlU2hhcGUoJ3BhdGgnKSxcbiAgICAgICAgbGluZTogY3JlYXRlTGluZSxcbiAgICB9O1xuXG4gICAgdmFyIFVQREFURV9UWVBFX1JPVVRFUyA9IHtcbiAgICAgICAgcmVjdDogdXBkYXRlUmVjdCxcbiAgICAgICAgZWxsaXBzZTogdXBkYXRlRWxsaXBzZSxcbiAgICAgICAgaW1hZ2U6IHVwZGF0ZUltYWdlLFxuICAgICAgICB0ZXh0OiB1cGRhdGVUZXh0LFxuICAgICAgICBwYXRoOiB1cGRhdGVQYXRoLFxuICAgICAgICBsaW5lOiB1cGRhdGVMaW5lLFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTWFya3VwQnlUeXBlID0gZnVuY3Rpb24gY3JlYXRlTWFya3VwQnlUeXBlKHR5cGUsIG1hcmt1cCkge1xuICAgICAgICByZXR1cm4gQ1JFQVRFX1RZUEVfUk9VVEVTW3R5cGVdKG1hcmt1cCk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVNYXJrdXBCeVR5cGUgPSBmdW5jdGlvbiB1cGRhdGVNYXJrdXBCeVR5cGUoZWxlbWVudCwgdHlwZSwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlY3QgPSBnZXRNYXJrdXBSZWN0KG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc3R5bGVzID0gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xuICAgICAgICBVUERBVEVfVFlQRV9ST1VURVNbdHlwZV0oZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSk7XG4gICAgfTtcblxuICAgIHZhciBzb3J0TWFya3VwQnlaSW5kZXggPSBmdW5jdGlvbiBzb3J0TWFya3VwQnlaSW5kZXgoYSwgYikge1xuICAgICAgICBpZiAoYVsxXS56SW5kZXggPiBiWzFdLnpJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbMV0uekluZGV4IDwgYlsxXS56SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgdmFyIGNyb3BTVkcgPSBmdW5jdGlvbiBjcm9wU1ZHKGJsb2IpIHtcbiAgICAgICAgdmFyIGNyb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgbWFya3VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnMkYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gX29wdGlvbnMkYmFja2dyb3VuZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGJhY2tncm91bmQ7XG5cbiAgICAgICAgICAgIC8vIGxvYWQgYmxvYiBjb250ZW50cyBhbmQgd3JhcCBpbiBjcm9wIHN2Z1xuICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGZyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBzdmcgdGV4dFxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZnIucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGVsZW1lbnQgd2l0aCBzdmcgYW5kIGdldCBzaXplXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWwuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lO3dpZHRoOjA7aGVpZ2h0OjA7dmlzaWJpbGl0eTpoaWRkZW47JztcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBvcmlnaW5hbC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICB2YXIgYkJveCA9IG9yaWdpbmFsTm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGl0bGVcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVOb2RlID0gb3JpZ2luYWwucXVlcnlTZWxlY3RvcigndGl0bGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBuZXcgaGVpZ2h0cyBhbmQgd2lkdGhzXG4gICAgICAgICAgICAgICAgdmFyIHZpZXdCb3hBdHRyaWJ1dGUgPSBvcmlnaW5hbE5vZGUuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoQXR0cmlidXRlID0gb3JpZ2luYWxOb2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAnJztcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0QXR0cmlidXRlID0gb3JpZ2luYWxOb2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh3aWR0aEF0dHJpYnV0ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHRBdHRyaWJ1dGUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoVW5pdHMgPSAod2lkdGhBdHRyaWJ1dGUubWF0Y2goL1thLXpdKy8pIHx8IFtdKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0VW5pdHMgPSAoaGVpZ2h0QXR0cmlidXRlLm1hdGNoKC9bYS16XSsvKSB8fCBbXSlbMF0gfHwgJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IHNpemVcbiAgICAgICAgICAgICAgICB2YXIgdmlld0JveExpc3QgPSB2aWV3Qm94QXR0cmlidXRlLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3Qm94ID0gdmlld0JveExpc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB2aWV3Qm94TGlzdFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdmlld0JveExpc3RbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2aWV3Qm94TGlzdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWV3Qm94TGlzdFszXSxcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogYkJveDtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZVdpZHRoID0gd2lkdGggIT0gbnVsbCA/IHdpZHRoIDogdmlld0JveC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VIZWlnaHQgPSBoZWlnaHQgIT0gbnVsbCA/IGhlaWdodCA6IHZpZXdCb3guaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxOb2RlLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTm9kZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaW1hZ2VXaWR0aCk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxOb2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaW1hZ2VIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbWFya3VwXG4gICAgICAgICAgICAgICAgdmFyIG1hcmt1cFNWRyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrdXBTVkcgPSBtYXJrdXAuc29ydChzb3J0TWFya3VwQnlaSW5kZXgpLnJlZHVjZShmdW5jdGlvbihwcmV2LCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gY3JlYXRlTWFya3VwQnlUeXBlKHNoYXBlWzBdLCBzaGFwZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVNYXJrdXBCeVR5cGUoZWwsIHNoYXBlWzBdLCBzaGFwZVsxXSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdvcGFjaXR5JykgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ29wYWNpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ICsgJ1xcbicgKyBlbC5vdXRlckhUTUwgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrdXBTVkcgPSAnXFxuXFxuPGc+Jy5jb25jYXQobWFya3VwU1ZHLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpLCAnPC9nPlxcblxcbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW8gfHwgaW1hZ2VIZWlnaHQgLyBpbWFnZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gaW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY2FudmFzV2lkdGggKiBhc3BlY3RSYXRpbztcblxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRMaW1pdCA9IHR5cGVvZiBjcm9wLnNjYWxlVG9GaXQgPT09ICd1bmRlZmluZWQnIHx8IGNyb3Auc2NhbGVUb0ZpdDtcblxuICAgICAgICAgICAgICAgIHZhciBjcm9wQ2VudGVyWCA9IGNyb3AuY2VudGVyID8gY3JvcC5jZW50ZXIueCA6IDAuNTtcbiAgICAgICAgICAgICAgICB2YXIgY3JvcENlbnRlclkgPSBjcm9wLmNlbnRlciA/IGNyb3AuY2VudGVyLnkgOiAwLjU7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBnZXRDZW50ZXJlZENyb3BSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgY3JvcC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkTGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB4OiBjcm9wQ2VudGVyWCwgeTogY3JvcENlbnRlclkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gY3JvcC56b29tICogY2FudmFzWm9vbUZhY3RvcjtcblxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IGNyb3Aucm90YXRpb24gKiAoMTgwIC8gTWF0aC5QSSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzQ2VudGVyID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBjYW52YXNXaWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgeTogY2FudmFzSGVpZ2h0ICogMC41LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNhbnZhc0NlbnRlci54IC0gaW1hZ2VXaWR0aCAqIGNyb3BDZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjYW52YXNDZW50ZXIueSAtIGltYWdlSGVpZ2h0ICogY3JvcENlbnRlclksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBjcm9wVHJhbnNmb3JtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRlXG4gICAgICAgICAgICAgICAgICAgICdyb3RhdGUoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyb3RhdGlvbiwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjYW52YXNDZW50ZXIueCwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjYW52YXNDZW50ZXIueSwgJyknKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBzY2FsZVxuICAgICAgICAgICAgICAgICAgICAndHJhbnNsYXRlKCcuY29uY2F0KGNhbnZhc0NlbnRlci54LCAnICcpLmNvbmNhdChjYW52YXNDZW50ZXIueSwgJyknKSxcbiAgICAgICAgICAgICAgICAgICAgJ3NjYWxlKCcuY29uY2F0KHNjYWxlLCAnKScpLFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNsYXRlKCcuY29uY2F0KC1jYW52YXNDZW50ZXIueCwgJyAnKS5jb25jYXQoLWNhbnZhc0NlbnRlci55LCAnKScpLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNsYXRlKCcuY29uY2F0KGltYWdlT2Zmc2V0LngsICcgJykuY29uY2F0KGltYWdlT2Zmc2V0LnksICcpJyksXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIHZhciBjcm9wRmxpcEhvcml6b250YWwgPSBjcm9wLmZsaXAgJiYgY3JvcC5mbGlwLmhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgdmFyIGNyb3BGbGlwVmVydGljYWwgPSBjcm9wLmZsaXAgJiYgY3JvcC5mbGlwLnZlcnRpY2FsO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZsaXBUcmFuc2Zvcm1zID0gW1xuICAgICAgICAgICAgICAgICAgICAnc2NhbGUoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjcm9wRmxpcEhvcml6b250YWwgPyAtMSA6IDEsICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoY3JvcEZsaXBWZXJ0aWNhbCA/IC0xIDogMSwgJyknKSxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNyb3BGbGlwSG9yaXpvbnRhbCA/IC1pbWFnZVdpZHRoIDogMCwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjcm9wRmxpcFZlcnRpY2FsID8gLWltYWdlSGVpZ2h0IDogMCwgJyknKSxcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JvcFxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG48c3ZnIHdpZHRoPVwiJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNhbnZhc1dpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHdpZHRoVW5pdHMsICdcIiBoZWlnaHQ9XCInKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNhbnZhc0hlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChoZWlnaHRVbml0cywgJ1wiIFxcbnZpZXdCb3g9XCIwIDAgJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjYW52YXNXaWR0aCwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNhbnZhc0hlaWdodCwgJ1wiICcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kID8gJ3N0eWxlPVwiYmFja2dyb3VuZDonICsgYmFja2dyb3VuZCArICdcIiAnIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxucHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluXCJcXG54bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxcbnhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cXG48IS0tIEdlbmVyYXRlZCBieSBQUUlOQSAtIGh0dHBzOi8vcHFpbmEubmwvIC0tPlxcbjx0aXRsZT4nXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aXRsZU5vZGUgPyB0aXRsZU5vZGUudGV4dENvbnRlbnQgOiAnJywgJzwvdGl0bGU+XFxuPGcgdHJhbnNmb3JtPVwiJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjcm9wVHJhbnNmb3Jtcy5qb2luKCcgJyksICdcIj5cXG48ZyB0cmFuc2Zvcm09XCInKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGZsaXBUcmFuc2Zvcm1zLmpvaW4oJyAnKSwgJ1wiPlxcbicpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQob3JpZ2luYWxOb2RlLm91dGVySFRNTClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrdXBTVkcsICdcXG48L2c+XFxuPC9nPlxcbjwvc3ZnPicpO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBzdmcgZmlsZVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnIucmVhZEFzVGV4dChibG9iKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBvYmplY3RUb0ltYWdlRGF0YSA9IGZ1bmN0aW9uIG9iamVjdFRvSW1hZ2VEYXRhKG9iaikge1xuICAgICAgICB2YXIgaW1hZ2VEYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShvYmoud2lkdGgsIG9iai5oZWlnaHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJRSArIE9sZCBFREdFICh0ZXN0ZWQgb24gMTIpXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBpbWFnZURhdGEgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5jcmVhdGVJbWFnZURhdGEob2JqLndpZHRoLCBvYmouaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZURhdGEuZGF0YS5zZXQob2JqLmRhdGEpO1xuICAgICAgICByZXR1cm4gaW1hZ2VEYXRhO1xuICAgIH07XG5cbiAgICAvKiBqYXZhc2NyaXB0LW9iZnVzY2F0b3I6ZGlzYWJsZSAqL1xuICAgIHZhciBUcmFuc2Zvcm1Xb3JrZXIgPSBmdW5jdGlvbiBUcmFuc2Zvcm1Xb3JrZXIoKSB7XG4gICAgICAgIC8vIG1hcHMgdHJhbnNmb3JtIHR5cGVzIHRvIHRyYW5zZm9ybSBmdW5jdGlvbnNcbiAgICAgICAgdmFyIFRSQU5TRk9STVMgPSB7IHJlc2l6ZTogcmVzaXplLCBmaWx0ZXI6IGZpbHRlciB9O1xuXG4gICAgICAgIC8vIGFwcGxpZXMgYWxsIGltYWdlIHRyYW5zZm9ybXMgdG8gdGhlIGltYWdlIGRhdGEgYXJyYXlcbiAgICAgICAgdmFyIGFwcGx5VHJhbnNmb3JtcyA9IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zLCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEgPSBUUkFOU0ZPUk1TW3RyYW5zZm9ybS50eXBlXShpbWFnZURhdGEsIHRyYW5zZm9ybS5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gaW1hZ2UgaHViXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YSwgY2IpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gZGF0YS50cmFuc2Zvcm1zO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgZmlsdGVyIGFuZCBoYXMgcmVzaXplLCBtb3ZlIGZpbHRlciB0byByZXNpemUgb3BlcmF0aW9uXG4gICAgICAgICAgICB2YXIgZmlsdGVyVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtLnR5cGUgPT09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHJlc2l6ZVxuICAgICAgICAgICAgICAgIHZhciByZXNpemVUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybS50eXBlID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzaXplVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSByZXNpemUgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVRyYW5zZm9ybS5kYXRhLm1hdHJpeCA9IGZpbHRlclRyYW5zZm9ybS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtcyA9IHRyYW5zZm9ybXMuZmlsdGVyKGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS50eXBlICE9PSAnZmlsdGVyJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihhcHBseVRyYW5zZm9ybXModHJhbnNmb3JtcywgZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtKGUuZGF0YS5tZXNzYWdlLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgbWVzc2FnZTogcmVzcG9uc2UgfSwgW3Jlc3BvbnNlLmRhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYnIgPSAxLjA7XG4gICAgICAgIHZhciBiZyA9IDEuMDtcbiAgICAgICAgdmFyIGJiID0gMS4wO1xuICAgICAgICBmdW5jdGlvbiBhcHBseUZpbHRlck1hdHJpeChpbmRleCwgZGF0YSwgbSkge1xuICAgICAgICAgICAgdmFyIGlyID0gZGF0YVtpbmRleF0gLyAyNTU7XG4gICAgICAgICAgICB2YXIgaWcgPSBkYXRhW2luZGV4ICsgMV0gLyAyNTU7XG4gICAgICAgICAgICB2YXIgaWIgPSBkYXRhW2luZGV4ICsgMl0gLyAyNTU7XG4gICAgICAgICAgICB2YXIgaWEgPSBkYXRhW2luZGV4ICsgM10gLyAyNTU7XG5cbiAgICAgICAgICAgIHZhciBtciA9IGlyICogbVswXSArIGlnICogbVsxXSArIGliICogbVsyXSArIGlhICogbVszXSArIG1bNF07XG4gICAgICAgICAgICB2YXIgbWcgPSBpciAqIG1bNV0gKyBpZyAqIG1bNl0gKyBpYiAqIG1bN10gKyBpYSAqIG1bOF0gKyBtWzldO1xuICAgICAgICAgICAgdmFyIG1iID0gaXIgKiBtWzEwXSArIGlnICogbVsxMV0gKyBpYiAqIG1bMTJdICsgaWEgKiBtWzEzXSArIG1bMTRdO1xuICAgICAgICAgICAgdmFyIG1hID0gaXIgKiBtWzE1XSArIGlnICogbVsxNl0gKyBpYiAqIG1bMTddICsgaWEgKiBtWzE4XSArIG1bMTldO1xuXG4gICAgICAgICAgICB2YXIgb3IgPSBNYXRoLm1heCgwLCBtciAqIG1hKSArIGJyICogKDEuMCAtIG1hKTtcbiAgICAgICAgICAgIHZhciBvZyA9IE1hdGgubWF4KDAsIG1nICogbWEpICsgYmcgKiAoMS4wIC0gbWEpO1xuICAgICAgICAgICAgdmFyIG9iID0gTWF0aC5tYXgoMCwgbWIgKiBtYSkgKyBiYiAqICgxLjAgLSBtYSk7XG5cbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIG9yKSkgKiAyNTU7XG4gICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgb2cpKSAqIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBvYikpICogMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkZW50aXR5TWF0cml4ID0gc2VsZi5KU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgXSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpdHlNYXRyaXgoZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5KU09OLnN0cmluZ2lmeShmaWx0ZXIgfHwgW10pID09PSBpZGVudGl0eU1hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlcihpbWFnZURhdGEsIG1hdHJpeCkge1xuICAgICAgICAgICAgaWYgKCFtYXRyaXggfHwgaXNJZGVudGl0eU1hdHJpeChtYXRyaXgpKSByZXR1cm4gaW1hZ2VEYXRhO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIG0xMSA9IG1hdHJpeFswXTtcbiAgICAgICAgICAgIHZhciBtMTIgPSBtYXRyaXhbMV07XG4gICAgICAgICAgICB2YXIgbTEzID0gbWF0cml4WzJdO1xuICAgICAgICAgICAgdmFyIG0xNCA9IG1hdHJpeFszXTtcbiAgICAgICAgICAgIHZhciBtMTUgPSBtYXRyaXhbNF07XG5cbiAgICAgICAgICAgIHZhciBtMjEgPSBtYXRyaXhbNV07XG4gICAgICAgICAgICB2YXIgbTIyID0gbWF0cml4WzZdO1xuICAgICAgICAgICAgdmFyIG0yMyA9IG1hdHJpeFs3XTtcbiAgICAgICAgICAgIHZhciBtMjQgPSBtYXRyaXhbOF07XG4gICAgICAgICAgICB2YXIgbTI1ID0gbWF0cml4WzldO1xuXG4gICAgICAgICAgICB2YXIgbTMxID0gbWF0cml4WzEwXTtcbiAgICAgICAgICAgIHZhciBtMzIgPSBtYXRyaXhbMTFdO1xuICAgICAgICAgICAgdmFyIG0zMyA9IG1hdHJpeFsxMl07XG4gICAgICAgICAgICB2YXIgbTM0ID0gbWF0cml4WzEzXTtcbiAgICAgICAgICAgIHZhciBtMzUgPSBtYXRyaXhbMTRdO1xuXG4gICAgICAgICAgICB2YXIgbTQxID0gbWF0cml4WzE1XTtcbiAgICAgICAgICAgIHZhciBtNDIgPSBtYXRyaXhbMTZdO1xuICAgICAgICAgICAgdmFyIG00MyA9IG1hdHJpeFsxN107XG4gICAgICAgICAgICB2YXIgbTQ0ID0gbWF0cml4WzE4XTtcbiAgICAgICAgICAgIHZhciBtNDUgPSBtYXRyaXhbMTldO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIHIgPSAwLjAsXG4gICAgICAgICAgICAgICAgZyA9IDAuMCxcbiAgICAgICAgICAgICAgICBiID0gMC4wLFxuICAgICAgICAgICAgICAgIGEgPSAwLjAsXG4gICAgICAgICAgICAgICAgbXIgPSAwLjAsXG4gICAgICAgICAgICAgICAgbWcgPSAwLjAsXG4gICAgICAgICAgICAgICAgbWIgPSAwLjAsXG4gICAgICAgICAgICAgICAgbWEgPSAwLjAsXG4gICAgICAgICAgICAgICAgb3IgPSAwLjAsXG4gICAgICAgICAgICAgICAgb2cgPSAwLjAsXG4gICAgICAgICAgICAgICAgb2IgPSAwLjA7XG5cbiAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGw7IGluZGV4ICs9IDQpIHtcbiAgICAgICAgICAgICAgICByID0gZGF0YVtpbmRleF0gLyAyNTU7XG4gICAgICAgICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXSAvIDI1NTtcbiAgICAgICAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdIC8gMjU1O1xuICAgICAgICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM10gLyAyNTU7XG5cbiAgICAgICAgICAgICAgICBtciA9IHIgKiBtMTEgKyBnICogbTEyICsgYiAqIG0xMyArIGEgKiBtMTQgKyBtMTU7XG4gICAgICAgICAgICAgICAgbWcgPSByICogbTIxICsgZyAqIG0yMiArIGIgKiBtMjMgKyBhICogbTI0ICsgbTI1O1xuICAgICAgICAgICAgICAgIG1iID0gciAqIG0zMSArIGcgKiBtMzIgKyBiICogbTMzICsgYSAqIG0zNCArIG0zNTtcbiAgICAgICAgICAgICAgICBtYSA9IHIgKiBtNDEgKyBnICogbTQyICsgYiAqIG00MyArIGEgKiBtNDQgKyBtNDU7XG5cbiAgICAgICAgICAgICAgICBvciA9IE1hdGgubWF4KDAsIG1yICogbWEpICsgYnIgKiAoMS4wIC0gbWEpO1xuICAgICAgICAgICAgICAgIG9nID0gTWF0aC5tYXgoMCwgbWcgKiBtYSkgKyBiZyAqICgxLjAgLSBtYSk7XG4gICAgICAgICAgICAgICAgb2IgPSBNYXRoLm1heCgwLCBtYiAqIG1hKSArIGJiICogKDEuMCAtIG1hKTtcblxuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIG9yKSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIG9nKSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDJdID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIG9iKSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIGFscGhhIHZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZURhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemUoaW1hZ2VEYXRhLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgX2RhdGEkbW9kZSA9IGRhdGEubW9kZSxcbiAgICAgICAgICAgICAgICBtb2RlID0gX2RhdGEkbW9kZSA9PT0gdm9pZCAwID8gJ2NvbnRhaW4nIDogX2RhdGEkbW9kZSxcbiAgICAgICAgICAgICAgICBfZGF0YSR1cHNjYWxlID0gZGF0YS51cHNjYWxlLFxuICAgICAgICAgICAgICAgIHVwc2NhbGUgPSBfZGF0YSR1cHNjYWxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kYXRhJHVwc2NhbGUsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBkYXRhLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1hdHJpeCA9IGRhdGEubWF0cml4O1xuXG4gICAgICAgICAgICAvLyB0ZXN0IGlmIGlzIGlkZW50aXR5IG1hdHJpeFxuICAgICAgICAgICAgbWF0cml4ID0gIW1hdHJpeCB8fCBpc0lkZW50aXR5TWF0cml4KG1hdHJpeCkgPyBudWxsIDogbWF0cml4O1xuXG4gICAgICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgd2lkdGggb3IgYSBoZWlnaHRcbiAgICAgICAgICAgIC8vIGFsc28gMCBpcyBub3QgYSB2YWxpZCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoaW1hZ2VEYXRhLCBtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIGJvdW5kcyBhcmUgc2V0XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RlICE9PSAnZm9yY2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxhcldpZHRoID0gd2lkdGggLyBpbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxhckhlaWdodCA9IGhlaWdodCAvIGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxhciA9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2NvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzY2FsYXIgPSBNYXRoLm1heChzY2FsYXJXaWR0aCwgc2NhbGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdjb250YWluJykge1xuICAgICAgICAgICAgICAgICAgICBzY2FsYXIgPSBNYXRoLm1pbihzY2FsYXJXaWR0aCwgc2NhbGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpbWFnZSBpcyB0b28gc21hbGwsIGV4aXQgaGVyZSB3aXRoIG9yaWdpbmFsIGltYWdlXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxhciA+IDEgJiYgdXBzY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihpbWFnZURhdGEsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZURhdGEud2lkdGggKiBzY2FsYXI7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCAqIHNjYWxhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0V2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgaW5wdXREYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICB2YXIgb3V0cHV0RGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0YXJnZXRXaWR0aCAqIHRhcmdldEhlaWdodCAqIDQpO1xuICAgICAgICAgICAgdmFyIHJhdGlvV2lkdGggPSBvcmlnaW5XaWR0aCAvIHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgdmFyIHJhdGlvSGVpZ2h0ID0gb3JpZ2luSGVpZ2h0IC8gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHJhdGlvV2lkdGhIYWxmID0gTWF0aC5jZWlsKHJhdGlvV2lkdGggKiAwLjUpO1xuICAgICAgICAgICAgdmFyIHJhdGlvSGVpZ2h0SGFsZiA9IE1hdGguY2VpbChyYXRpb0hlaWdodCAqIDAuNSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGFyZ2V0SGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gKGkgKyBqICogdGFyZ2V0V2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodHNBbHBoYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlclkgPSAoaiArIDAuNSkgKiByYXRpb0hlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5eSA9IE1hdGguZmxvb3IoaiAqIHJhdGlvSGVpZ2h0KTsgeXkgPCAoaiArIDEpICogcmF0aW9IZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IE1hdGguYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSGVpZ2h0SGFsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJYID0gKGkgKyAwLjUpICogcmF0aW9XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3MCA9IGR5ICogZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHh4ID0gTWF0aC5mbG9vcihpICogcmF0aW9XaWR0aCk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dpZHRoSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IE1hdGguc3FydCh3MCArIGR4ICogZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgPj0gLTEgJiYgdyA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9yaWdpbldpZHRoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IGlucHV0RGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQgKiByZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gKHdlaWdodCAqIHJlZikgLyAyNTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gd2VpZ2h0ICogaW5wdXREYXRhW2R4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gd2VpZ2h0ICogaW5wdXREYXRhW2R4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiICs9IHdlaWdodCAqIGlucHV0RGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXREYXRhW3gyXSA9IHIgLyB3ZWlnaHRzO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXREYXRhW3gyICsgMV0gPSBnIC8gd2VpZ2h0cztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0RGF0YVt4MiArIDJdID0gYiAvIHdlaWdodHM7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dERhdGFbeDIgKyAzXSA9IGEgLyB3ZWlnaHRzQWxwaGE7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ICYmIGFwcGx5RmlsdGVyTWF0cml4KHgyLCBvdXRwdXREYXRhLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBvdXRwdXREYXRhLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRhcmdldEhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIGphdmFzY3JpcHQtb2JmdXNjYXRvcjplbmFibGUgKi9cblxuICAgIHZhciBjb3JyZWN0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBjb3JyZWN0T3JpZW50YXRpb24odmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIE1pc3NpbmcgMHg0NTc4Njk2NiBNYXJrZXI/IE5vIEV4aWYgSGVhZGVyLCBzdG9wIGhlcmVcbiAgICAgICAgaWYgKHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQsIGZhbHNlKSAhPT0gMHg0NTc4Njk2NikgcmV0dXJuO1xuXG4gICAgICAgIC8vIG5leHQgYnl0ZSFcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgLy8gRmlyc3QgMmJ5dGVzIGRlZmluZXMgYnl0ZSBhbGlnbiBvZiBUSUZGIGRhdGEuXG4gICAgICAgIC8vIElmIGl0IGlzIDB4NDk0OT1cIkkgSVwiLCBpdCBtZWFucyBcIkludGVsXCIgdHlwZSBieXRlIGFsaWduXG4gICAgICAgIHZhciBpbnRlbEJ5dGVBbGlnbmVkID0gdmlldy5nZXRVaW50MTYoKG9mZnNldCArPSA2KSwgZmFsc2UpID09PSAweDQ5NDk7XG4gICAgICAgIG9mZnNldCArPSB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0LCBpbnRlbEJ5dGVBbGlnbmVkKTtcblxuICAgICAgICB2YXIgdGFncyA9IHZpZXcuZ2V0VWludDE2KG9mZnNldCwgaW50ZWxCeXRlQWxpZ25lZCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuXG4gICAgICAgIC8vIGZpbmQgT3JpZW50YXRpb24gdGFnXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmlldy5nZXRVaW50MTYob2Zmc2V0ICsgaSAqIDEyLCBpbnRlbEJ5dGVBbGlnbmVkKSA9PT0gMHgwMTEyKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgaSAqIDEyICsgOCwgMSwgaW50ZWxCeXRlQWxpZ25lZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgcmVhZERhdGEgPSBmdW5jdGlvbiByZWFkRGF0YShkYXRhKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuXG4gICAgICAgIC8vIEV2ZXJ5IEpQRUcgZmlsZSBzdGFydHMgZnJvbSBiaW5hcnkgdmFsdWUgJzB4RkZEOCdcbiAgICAgICAgLy8gSWYgaXQncyBub3QgcHJlc2VudCwgZXhpdCBoZXJlXG4gICAgICAgIGlmICh2aWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gMjsgLy8gU3RhcnQgYXQgMiBhcyB3ZSBza2lwcGVkIHR3byBieXRlcyAoRkZEOClcbiAgICAgICAgdmFyIG1hcmtlcjtcbiAgICAgICAgdmFyIG1hcmtlckxlbmd0aDtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uQ29ycmVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IHZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgbWFya2VyID0gdmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICBtYXJrZXJMZW5ndGggPSB2aWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSkgKyAyO1xuXG4gICAgICAgICAgICAvLyBUZXN0IGlmIGlzIEFQUCBhbmQgQ09NIG1hcmtlcnNcbiAgICAgICAgICAgIHZhciBpc0RhdGEgPSAobWFya2VyID49IDB4ZmZlMCAmJiBtYXJrZXIgPD0gMHhmZmVmKSB8fCBtYXJrZXIgPT09IDB4ZmZmZTtcbiAgICAgICAgICAgIGlmICghaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3JpZW50YXRpb25Db3JyZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbkNvcnJlY3RlZCA9IGNvcnJlY3RPcmllbnRhdGlvbih2aWV3LCBvZmZzZXQsIG1hcmtlckxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgKyBtYXJrZXJMZW5ndGggPiB2aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hcmtlckxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBvZmZzZXQpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SW1hZ2VIZWFkID0gZnVuY3Rpb24gZ2V0SW1hZ2VIZWFkKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlYWREYXRhKHJlYWRlci5yZXN1bHQpIHx8IG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlLnNsaWNlKDAsIDI1NiAqIDEwMjQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5CbG9iQnVpbGRlciA9XG4gICAgICAgICAgICB3aW5kb3cuQmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgICAgIHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuTVNCbG9iQnVpbGRlcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICAgICAgdmFyIEJCID0gZ2V0QmxvYkJ1aWxkZXIoKTtcblxuICAgICAgICBpZiAoQkIpIHtcbiAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCQigpO1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRVbmlxdWVJZCA9IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgICAgICAgLnN1YnN0cigyLCA5KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgICAgICB2YXIgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gICAgICAgIHZhciB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwpO1xuXG4gICAgICAgIHZhciB0cmlwcyA9IFtdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2ZlcjogZnVuY3Rpb24gdHJhbnNmZXIoKSB7fSwgLy8gKG1lc3NhZ2UsIGNiKSA9PiB7fVxuICAgICAgICAgICAgcG9zdDogZnVuY3Rpb24gcG9zdChtZXNzYWdlLCBjYiwgdHJhbnNmZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgICAgICAgICB0cmlwc1tpZF0gPSBjYjtcblxuICAgICAgICAgICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IHRyaXBzW2UuZGF0YS5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2IpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHJpcHNbZS5kYXRhLmlkXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyTGlzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVybWluYXRlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiBsb2FkSW1hZ2UodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbiBjaGFpbihmdW5jcykge1xuICAgICAgICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uKHByb21pc2UsIGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKEFycmF5LnByb3RvdHlwZS5jb25jYXQuYmluZChyZXN1bHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoW10pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbnZhc0FwcGx5TWFya3VwID0gZnVuY3Rpb24gY2FudmFzQXBwbHlNYXJrdXAoY2FudmFzLCBtYXJrdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICB2YXIgZHJhd2VycyA9IG1hcmt1cC5zb3J0KHNvcnRNYXJrdXBCeVpJbmRleCkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gVFlQRV9EUkFXX1JPVVRFU1tpdGVtWzBdXShjdHgsIHNpemUsIGl0ZW1bMV0sIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoYWluKGRyYXdlcnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY2FudmFzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGx5TWFya3VwU3R5bGVzID0gZnVuY3Rpb24gYXBwbHlNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubGluZUNhcCA9IHN0eWxlc1snc3Ryb2tlLWxpbmVjYXAnXTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gc3R5bGVzWydzdHJva2UtbGluZWpvaW4nXTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlc1snc3Ryb2tlLXdpZHRoJ107XG4gICAgICAgIGlmIChzdHlsZXNbJ3N0cm9rZS1kYXNoYXJyYXknXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZXNbJ3N0cm9rZS1kYXNoYXJyYXknXS5zcGxpdCgnLCcpKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVzWydmaWxsJ107XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlc1snc3Ryb2tlJ107XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlcy5vcGFjaXR5IHx8IDE7XG4gICAgfTtcblxuICAgIHZhciBkcmF3TWFya3VwU3R5bGVzID0gZnVuY3Rpb24gZHJhd01hcmt1cFN0eWxlcyhjdHgpIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1JlY3QgPSBmdW5jdGlvbiBkcmF3UmVjdChjdHgsIHNpemUsIG1hcmt1cCkge1xuICAgICAgICB2YXIgcmVjdCA9IGdldE1hcmt1cFJlY3QobWFya3VwLCBzaXplKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldE1hcmt1cFN0eWxlcyhtYXJrdXAsIHNpemUpO1xuICAgICAgICBhcHBseU1hcmt1cFN0eWxlcyhjdHgsIHN0eWxlcyk7XG4gICAgICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGRyYXdNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdFbGxpcHNlID0gZnVuY3Rpb24gZHJhd0VsbGlwc2UoY3R4LCBzaXplLCBtYXJrdXApIHtcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRNYXJrdXBSZWN0KG1hcmt1cCwgc2l6ZSk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRNYXJrdXBTdHlsZXMobWFya3VwLCBzaXplKTtcbiAgICAgICAgYXBwbHlNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpO1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54LFxuICAgICAgICAgICAgeSA9IHJlY3QueSxcbiAgICAgICAgICAgIHcgPSByZWN0LndpZHRoLFxuICAgICAgICAgICAgaCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICBveCA9ICh3IC8gMikgKiBrYXBwYSxcbiAgICAgICAgICAgIG95ID0gKGggLyAyKSAqIGthcHBhLFxuICAgICAgICAgICAgeGUgPSB4ICsgdyxcbiAgICAgICAgICAgIHllID0geSArIGgsXG4gICAgICAgICAgICB4bSA9IHggKyB3IC8gMixcbiAgICAgICAgICAgIHltID0geSArIGggLyAyO1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG5cbiAgICAgICAgZHJhd01hcmt1cFN0eWxlcyhjdHgsIHN0eWxlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd0ltYWdlID0gZnVuY3Rpb24gZHJhd0ltYWdlKGN0eCwgc2l6ZSwgbWFya3VwLCBkb25lKSB7XG4gICAgICAgIHZhciByZWN0ID0gZ2V0TWFya3VwUmVjdChtYXJrdXAsIHNpemUpO1xuICAgICAgICB2YXIgc3R5bGVzID0gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSk7XG4gICAgICAgIGFwcGx5TWFya3VwU3R5bGVzKGN0eCwgc3R5bGVzKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAvLyBpZiBpcyBjcm9zcyBvcmlnaW4gaW1hZ2UgYWRkIGNyb3NzIG9yaWdpbiBhdHRyaWJ1dGVcbiAgICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5JbWFnZSA9XG4gICAgICAgICAgICBuZXcgVVJMKG1hcmt1cC5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGlmIChpc0Nyb3NzT3JpZ2luSW1hZ2UpIGltYWdlLmNyb3NzT3JpZ2luID0gJyc7XG5cbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobWFya3VwLmZpdCA9PT0gJ2NvdmVyJykge1xuICAgICAgICAgICAgICAgIHZhciBhciA9IHJlY3Qud2lkdGggLyByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBhciA+IDEgPyBpbWFnZS53aWR0aCA6IGltYWdlLmhlaWdodCAqIGFyO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhciA+IDEgPyBpbWFnZS53aWR0aCAvIGFyIDogaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB4ID0gaW1hZ2Uud2lkdGggKiAwLjUgLSB3aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGltYWdlLmhlaWdodCAqIDAuNSAtIGhlaWdodCAqIDAuNTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXJrdXAuZml0ID09PSAnY29udGFpbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGFyID0gTWF0aC5taW4ocmVjdC53aWR0aCAvIGltYWdlLndpZHRoLCByZWN0LmhlaWdodCAvIGltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdmFyIF93aWR0aCA9IHNjYWxhciAqIGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBfaGVpZ2h0ID0gc2NhbGFyICogaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBfeCA9IHJlY3QueCArIHJlY3Qud2lkdGggKiAwLjUgLSBfd2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgdmFyIF95ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgKiAwLjUgLSBfaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdC55LFxuICAgICAgICAgICAgICAgICAgICByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICByZWN0LmhlaWdodFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYXdNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSBtYXJrdXAuc3JjO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dChjdHgsIHNpemUsIG1hcmt1cCkge1xuICAgICAgICB2YXIgcmVjdCA9IGdldE1hcmt1cFJlY3QobWFya3VwLCBzaXplKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldE1hcmt1cFN0eWxlcyhtYXJrdXAsIHNpemUpO1xuICAgICAgICBhcHBseU1hcmt1cFN0eWxlcyhjdHgsIHN0eWxlcyk7XG5cbiAgICAgICAgdmFyIGZvbnRTaXplID0gZ2V0TWFya3VwVmFsdWUobWFya3VwLmZvbnRTaXplLCBzaXplKTtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBtYXJrdXAuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7XG4gICAgICAgIHZhciBmb250V2VpZ2h0ID0gbWFya3VwLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSBtYXJrdXAudGV4dEFsaWduIHx8ICdsZWZ0JztcblxuICAgICAgICBjdHguZm9udCA9ICcnXG4gICAgICAgICAgICAuY29uY2F0KGZvbnRXZWlnaHQsICcgJylcbiAgICAgICAgICAgIC5jb25jYXQoZm9udFNpemUsICdweCAnKVxuICAgICAgICAgICAgLmNvbmNhdChmb250RmFtaWx5KTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KG1hcmt1cC50ZXh0LCByZWN0LngsIHJlY3QueSk7XG5cbiAgICAgICAgZHJhd01hcmt1cFN0eWxlcyhjdHgsIHN0eWxlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1BhdGggPSBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHNpemUsIG1hcmt1cCkge1xuICAgICAgICB2YXIgc3R5bGVzID0gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSk7XG4gICAgICAgIGFwcGx5TWFya3VwU3R5bGVzKGN0eCwgc3R5bGVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBtYXJrdXAucG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBnZXRNYXJrdXBWYWx1ZShwb2ludC54LCBzaXplLCAxLCAnd2lkdGgnKSxcbiAgICAgICAgICAgICAgICB5OiBnZXRNYXJrdXBWYWx1ZShwb2ludC55LCBzaXplLCAxLCAnaGVpZ2h0JyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICAgIHZhciBsID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdMaW5lID0gZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCBzaXplLCBtYXJrdXApIHtcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRNYXJrdXBSZWN0KG1hcmt1cCwgc2l6ZSk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRNYXJrdXBTdHlsZXMobWFya3VwLCBzaXplKTtcbiAgICAgICAgYXBwbHlNYXJrdXBTdHlsZXMoY3R4LCBzdHlsZXMpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICAgICAgeDogcmVjdC54LFxuICAgICAgICAgICAgeTogcmVjdC55LFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgICAgICB4OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgICAgICAgICAgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQsXG4gICAgICAgIH07XG5cbiAgICAgICAgY3R4Lm1vdmVUbyhvcmlnaW4ueCwgb3JpZ2luLnkpO1xuICAgICAgICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cbiAgICAgICAgdmFyIHYgPSB2ZWN0b3JOb3JtYWxpemUoe1xuICAgICAgICAgICAgeDogdGFyZ2V0LnggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgIHk6IHRhcmdldC55IC0gb3JpZ2luLnksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBsID0gMC4wNCAqIE1hdGgubWluKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWJlZ2luJykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCBsKTtcbiAgICAgICAgICAgIHZhciBhcnJvd0JlZ2luQ2VudGVyID0gdmVjdG9yQWRkKG9yaWdpbiwgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGFycm93QmVnaW5BID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgMiwgYXJyb3dCZWdpbkNlbnRlcik7XG4gICAgICAgICAgICB2YXIgYXJyb3dCZWdpbkIgPSB2ZWN0b3JSb3RhdGUob3JpZ2luLCAtMiwgYXJyb3dCZWdpbkNlbnRlcik7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oYXJyb3dCZWdpbkEueCwgYXJyb3dCZWdpbkEueSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKG9yaWdpbi54LCBvcmlnaW4ueSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGFycm93QmVnaW5CLngsIGFycm93QmVnaW5CLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXAubGluZURlY29yYXRpb24uaW5kZXhPZignYXJyb3ctZW5kJykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgYXJyb3dFbmRSb3RhdGlvblBvaW50ID0gdmVjdG9yTXVsdGlwbHkodiwgLWwpO1xuICAgICAgICAgICAgdmFyIGFycm93RW5kQ2VudGVyID0gdmVjdG9yQWRkKHRhcmdldCwgYXJyb3dFbmRSb3RhdGlvblBvaW50KTtcbiAgICAgICAgICAgIHZhciBhcnJvd0VuZEEgPSB2ZWN0b3JSb3RhdGUodGFyZ2V0LCAyLCBhcnJvd0VuZENlbnRlcik7XG4gICAgICAgICAgICB2YXIgYXJyb3dFbmRCID0gdmVjdG9yUm90YXRlKHRhcmdldCwgLTIsIGFycm93RW5kQ2VudGVyKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhhcnJvd0VuZEEueCwgYXJyb3dFbmRBLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd0VuZEIueCwgYXJyb3dFbmRCLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhd01hcmt1cFN0eWxlcyhjdHgsIHN0eWxlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgVFlQRV9EUkFXX1JPVVRFUyA9IHtcbiAgICAgICAgcmVjdDogZHJhd1JlY3QsXG4gICAgICAgIGVsbGlwc2U6IGRyYXdFbGxpcHNlLFxuICAgICAgICBpbWFnZTogZHJhd0ltYWdlLFxuICAgICAgICB0ZXh0OiBkcmF3VGV4dCxcbiAgICAgICAgbGluZTogZHJhd0xpbmUsXG4gICAgICAgIHBhdGg6IGRyYXdQYXRoLFxuICAgIH07XG5cbiAgICB2YXIgaW1hZ2VEYXRhVG9DYW52YXMgPSBmdW5jdGlvbiBpbWFnZURhdGFUb0NhbnZhcyhpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGltYWdlLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICB2YXIgY3R4ID0gaW1hZ2UuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1JbWFnZSA9IGZ1bmN0aW9uIHRyYW5zZm9ybUltYWdlKGZpbGUsIGluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaWxlIGlzIG5vdCBhbiBpbWFnZSB3ZSBkbyBub3QgaGF2ZSBhbnkgYnVzaW5lc3MgdHJhbnNmb3JtaW5nIGl0XG4gICAgICAgICAgICBpZiAoIWZpbGUgfHwgIWlzSW1hZ2UkMShmaWxlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHsgc3RhdHVzOiAnbm90IGFuIGltYWdlIGZpbGUnLCBmaWxlOiBmaWxlIH0pO1xuXG4gICAgICAgICAgICAvLyBnZXQgc2VwYXJhdGUgb3B0aW9ucyBmb3IgZWFzaWVyIHVzZVxuICAgICAgICAgICAgdmFyIHN0cmlwSW1hZ2VIZWFkID0gb3B0aW9ucy5zdHJpcEltYWdlSGVhZCxcbiAgICAgICAgICAgICAgICBiZWZvcmVDcmVhdGVCbG9iID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVCbG9iLFxuICAgICAgICAgICAgICAgIGFmdGVyQ3JlYXRlQmxvYiA9IG9wdGlvbnMuYWZ0ZXJDcmVhdGVCbG9iLFxuICAgICAgICAgICAgICAgIGNhbnZhc01lbW9yeUxpbWl0ID0gb3B0aW9ucy5jYW52YXNNZW1vcnlMaW1pdDtcblxuICAgICAgICAgICAgLy8gZ2V0IGNyb3BcbiAgICAgICAgICAgIHZhciBjcm9wID0gaW5zdHJ1Y3Rpb25zLmNyb3AsXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGluc3RydWN0aW9ucy5zaXplLFxuICAgICAgICAgICAgICAgIGZpbHRlciA9IGluc3RydWN0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgbWFya3VwID0gaW5zdHJ1Y3Rpb25zLm1hcmt1cCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBpbnN0cnVjdGlvbnMub3V0cHV0O1xuXG4gICAgICAgICAgICAvLyBnZXQgZXhpZiBvcmllbnRhdGlvblxuICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uID1cbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMuaW1hZ2UgJiYgaW5zdHJ1Y3Rpb25zLmltYWdlLm9yaWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oOCwgaW5zdHJ1Y3Rpb25zLmltYWdlLm9yaWVudGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBxdWFsaXR5IDAgPT4gMTAwXG4gICAgICAgICAgICB2YXIgcXVhbGl0eUFzUGVyY2VudGFnZSA9IG91dHB1dCAmJiBvdXRwdXQucXVhbGl0eTtcbiAgICAgICAgICAgIHZhciBxdWFsaXR5ID0gcXVhbGl0eUFzUGVyY2VudGFnZSA9PT0gbnVsbCA/IG51bGwgOiBxdWFsaXR5QXNQZXJjZW50YWdlIC8gMTAwO1xuXG4gICAgICAgICAgICAvLyBvdXRwdXQgZm9ybWF0XG4gICAgICAgICAgICB2YXIgdHlwZSA9IChvdXRwdXQgJiYgb3V0cHV0LnR5cGUpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kID0gKG91dHB1dCAmJiBvdXRwdXQuYmFja2dyb3VuZCkgfHwgbnVsbDtcblxuICAgICAgICAgICAgLy8gZ2V0IHRyYW5zZm9ybXNcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG5cbiAgICAgICAgICAgIC8vIGFkZCByZXNpemUgdHJhbnNmb3JtcyBpZiBzZXRcbiAgICAgICAgICAgIGlmIChzaXplICYmICh0eXBlb2Ygc2l6ZS53aWR0aCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNpemUuaGVpZ2h0ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zLnB1c2goeyB0eXBlOiAncmVzaXplJywgZGF0YTogc2l6ZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIGZpbHRlcnNcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmxlbmd0aCA9PT0gMjApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zLnB1c2goeyB0eXBlOiAnZmlsdGVyJywgZGF0YTogZmlsdGVyIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXNvbHZlcyB3aXRoIHN1cHBsaWVkIGJsb2JcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aEJsb2IgPSBmdW5jdGlvbiByZXNvbHZlV2l0aEJsb2IoYmxvYikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlZEJsb2IgPSBhZnRlckNyZWF0ZUJsb2IgPyBhZnRlckNyZWF0ZUJsb2IoYmxvYikgOiBibG9iO1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlZEJsb2IpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBkb25lXG4gICAgICAgICAgICB2YXIgdG9CbG9iID0gZnVuY3Rpb24gdG9CbG9iKGltYWdlRGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBpbWFnZURhdGFUb0NhbnZhcyhpbWFnZURhdGEpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlZENhbnZhcyA9IG1hcmt1cC5sZW5ndGggPyBjYW52YXNBcHBseU1hcmt1cChjYW52YXMsIG1hcmt1cCkgOiBjYW52YXM7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2VkQ2FudmFzKS50aGVuKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNUb0Jsb2IoY2FudmFzLCBvcHRpb25zLCBiZWZvcmVDcmVhdGVCbG9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlbGVhc2Ugb2YgY2FudmFzIG1lbW9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlbGVhc2UoY2FudmFzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpbWFnZSBoZWFkIChkZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcEltYWdlSGVhZCkgcmV0dXJuIHJlc29sdmVXaXRoQmxvYihibG9iKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBjb3B5IGltYWdlIGhlYWQgZnJvbSBvcmlnaW5hbCBmaWxlIHRvIGdlbmVyYXRlZCBibG9iXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW1hZ2VIZWFkKGZpbGUpLnRoZW4oZnVuY3Rpb24oaW1hZ2VIZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWluamVjdCBpbWFnZSBoZWFkIGluIGNhc2Ugb2YgSlBFRywgYXMgdGhlIGltYWdlIGhlYWQgaXMgcmVtb3ZlZCBieSBjYW52YXMgZXhwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbaW1hZ2VIZWFkLCBibG9iLnNsaWNlKDIwKV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBibG9iLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVXaXRoQmxvYihibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gc3ZnIGFuZCB3ZSB3YW50IGl0IHRvIHN0YXkgYW4gc3ZnXG4gICAgICAgICAgICBpZiAoL3N2Zy8udGVzdChmaWxlLnR5cGUpICYmIHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JvcFNWRyhmaWxlLCBjcm9wLCBtYXJrdXAsIHsgYmFja2dyb3VuZDogYmFja2dyb3VuZCB9KS50aGVuKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVCbG9iKHRleHQsICdpbWFnZS9zdmcreG1sJykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgZmlsZSB1cmxcbiAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXG4gICAgICAgICAgICAvLyB0dXJuIHRoZSBmaWxlIGludG8gYW4gaW1hZ2VcbiAgICAgICAgICAgIGxvYWRJbWFnZSh1cmwpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXJsIGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdG8gY2FudmFzIGFuZCBzdGFydCB0cmFuc2Zvcm0gY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IGltYWdlVG9JbWFnZURhdGEoaW1hZ2UsIG9yaWVudGF0aW9uLCBjcm9wLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNNZW1vcnlMaW1pdDogY2FudmFzTWVtb3J5TGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGZvcm1hdCBvZiB0aGUgYmxvYiB0aGF0IHdlIHdpbGwgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRGb3JtYXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSB8fCBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gdHJhbnNmb3JtcyBuZWNlc3NhcnksIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b0Jsb2IoaW1hZ2VEYXRhLCBvdXRwdXRGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCB0byB0aGUgdHJhbnNmb3JtIHdvcmtlciB0byB0cmFuc2Zvcm0gdGhlIGJsb2Igb24gYSBzZXBhcmF0ZSB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmtlciA9IGNyZWF0ZVdvcmtlcihUcmFuc2Zvcm1Xb3JrZXIpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB0cmFuc2Zvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0Jsb2Iob2JqZWN0VG9JbWFnZURhdGEocmVzcG9uc2UpLCBvdXRwdXRGb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCB3b3JrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW2ltYWdlRGF0YS5kYXRhLmJ1ZmZlcl1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cblxuICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbiAgICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuICAgICAgICAgICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgICAgICAgICAgICAgIDB4ZWFjNztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMztcblxuICAgICAgICBpZiAoIXByb3BzICYmIGNoaWxkcmVuTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogdm9pZCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcyAmJiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHByb3BzID0gZGVmYXVsdFByb3BzIHx8IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBuZXcgQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAga2V5OiBrZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAnJyArIGtleSxcbiAgICAgICAgICAgIHJlZjogbnVsbCxcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIF9vd25lcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXN5bmNJdGVyYXRvcihpdGVyYWJsZSkge1xuICAgICAgICB2YXIgbWV0aG9kO1xuXG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgICAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gJ3JldHVybicgOiAnbm9ybWFsJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgICAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgICB9O1xuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gICAgfTtcblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3JldHVybicsIGFyZyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoaW5uZXIsIGF3YWl0V3JhcCkge1xuICAgICAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAod2FpdGluZykge1xuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXIudGhyb3cgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3JldHVybicsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAnbmV4dCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBvYmplY3RTeW1ib2xzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICBfZXh0ZW5kcyA9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICAgICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlXG4gICAgICAgICAgICA/IG9ialxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBvYmosXG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9uZXdBcnJvd0NoZWNrKGlubmVyVGhpcywgYm91bmRUaGlzKSB7XG4gICAgICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0RGVzdHJ1Y3R1cmluZ0VtcHR5KG9iaikge1xuICAgICAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgdmFyIGtleSwgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgICAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgICAgICAgdmFyIGtleSwgaTtcblxuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgY2FsbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LnNldCkge1xuICAgICAgICAgICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgICAgICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICAgICAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzZXQgcHJvcGVydHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywge1xuICAgICAgICAgICAgICAgIHJhdzoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShzdHJpbmdzLCByYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpIHtcbiAgICAgICAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgICAgICBpZiAodmFsID09PSBfdGVtcG9yYWxVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihuYW1lICsgJyBpcyBub3QgZGVmaW5lZCAtIHRlbXBvcmFsIGRlYWQgem9uZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWFkT25seUVycm9yKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBuYW1lICsgJ1wiIGlzIHJlYWQtb25seScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgXCInICsgbmFtZSArICdcIiBjYW5ub3QgYmUgcmVmZXJlbmNlZCBpbiBjb21wdXRlZCBwcm9wZXJ0eSBrZXlzLicpO1xuICAgIH1cblxuICAgIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5TG9vc2UoYXJyLCBpKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgICAgICAgIHJldHVybiBhcnIyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgICAgICAgdmFyIF9hcnIgPSBbXTtcbiAgICAgICAgdmFyIF9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kID0gZmFsc2U7XG4gICAgICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICAgICAgX2UgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0TG9vc2UoYXJyLCBpKSB7XG4gICAgICAgIHZhciBfYXJyID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lOyApIHtcbiAgICAgICAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NraXBGaXJzdEdlbmVyYXRvck5leHQoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGl0Lm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgICAgICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAnb2JqZWN0JykgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0BAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gICAgICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCAnc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgK1xuICAgICAgICAgICAgICAgICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHNldCB0byB1c2UgbG9vc2UgbW9kZS4gJyArXG4gICAgICAgICAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAgICAgICAgICd0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGRlY29yYXRvcnMgaW4gc3RhZ2UgMi4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGRlc2MgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlO1xuICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7XG5cbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MgPSBkZWNvcmF0b3JzXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihkZXNjLCBkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7XG4gICAgICAgICAgICB9LCBkZXNjKTtcblxuICAgICAgICBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwO1xuICAgICAgICAgICAgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgICAgIGRlc2MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gMDtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdfX3ByaXZhdGVfJyArIGlkKysgKyAnXycgKyBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlQmFzZShyZWNlaXZlciwgcHJpdmF0ZUtleSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlRmllbGRTcGVjR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNTZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7XG4gICAgICAgIHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpO1xuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBpID0gbWl4aW5zW2ldKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7XG4gICAgICAgICAgICBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgfSwgc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgICAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgICAgICAgIGRlY29yYXRvcnNcbiAgICAgICAgKTtcbiAgICAgICAgYXBpLmluaXRpYWxpemVDbGFzc0VsZW1lbnRzKHIuRiwgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXREZWNvcmF0b3JzQXBpKCkge1xuICAgICAgICBfZ2V0RGVjb3JhdG9yc0FwaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbJ21ldGhvZCddLCBbJ2ZpZWxkJ11dLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uKE8sIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSAnb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQua2luZCA9PT0ga2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09ICdzdGF0aWMnID8gRiA6IHByb3RvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmaW5lQ2xhc3NFbGVtZW50OiBmdW5jdGlvbihyZWNlaXZlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3duOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaGVycyA9IGZpbmlzaGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50LmtleSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKGVsZW1lbnRPYmplY3QpIHx8IGVsZW1lbnRPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFeHRyYXMgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZXh0cmFzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhcy5wdXNoLmFwcGx5KGV4dHJhcywgbmV3RXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYXM6IGV4dHJhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c0FuZEZpbmlzaGVyID0gdGhpcy50b0NsYXNzRGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9ialxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnRzW2pdLmtleSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24oZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9BcnJheShlbGVtZW50T2JqZWN0cykubWFwKGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZXh0cmFzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyAmJiBraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIGVpdGhlciBcIm1ldGhvZFwiIG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSAnc3RhdGljJyAmJiBwbGFjZW1lbnQgIT09ICdwcm90b3R5cGUnICYmIHBsYWNlbWVudCAhPT0gJ293bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFwicHJvdG90eXBlXCIgb3IgXCJvd25cIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIC5wbGFjZW1lbnQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2VsZW1lbnRzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2luaXRpYWxpemVyJywgJ0EgbWV0aG9kIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KGVsZW1lbnRPYmplY3QsICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlcixcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFzOiBleHRyYXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcob2JqLmtpbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGNyZWF0ZWQgYSBjbGFzcyBkZXNjcmlwdG9yIHdpdGggLmtpbmQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2tleScsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdkZXNjcmlwdG9yJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdpbml0aWFsaXplcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuQ2xhc3NGaW5pc2hlcnM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmaW5pc2hlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhbGxvd1Byb3BlcnR5OiBmdW5jdGlvbihvYmosIG5hbWUsIG9iamVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmplY3RUeXBlICsgXCIgY2FuJ3QgaGF2ZSBhIC5cIiArIG5hbWUgKyAnIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikge1xuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgaWYgKGRlZi5raW5kID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGdldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIHNldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBraW5kOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdmaWVsZCcgOiAnbWV0aG9kJyxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcGxhY2VtZW50OiBkZWYuc3RhdGljID8gJ3N0YXRpYycgOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdvd24nIDogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgICAgICBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikge1xuICAgICAgICBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29hbGVzY2VDbGFzc0VsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmXG4gICAgICAgICAgICAgICAgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJiAob3RoZXIgPSBuZXdFbGVtZW50cy5maW5kKGlzU2FtZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBtZXRob2RzICgnICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIHNhbWUgcHJvcGVydHkgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5rZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRlY29yYXRvcnMgJiYgZWxlbWVudC5kZWNvcmF0b3JzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNEYXRhRGVzY3JpcHRvcihkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQgJiYgIShkZXNjLnZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVzYy53cml0YWJsZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQocmVjZWl2ZXIsIHByaXZhdGVTZXQsIGZuKSB7XG4gICAgICAgIGlmICghcHJpdmF0ZVNldC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3dyYXBSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgICBfd3JhcFJlZ0V4cCA9IGZ1bmN0aW9uKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIGdyb3Vwcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9SZWdFeHAgPSBfd3JhcE5hdGl2ZVN1cGVyKFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbiAgICAgICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9SZWdFeHAuY2FsbCh0aGlzLCByZSk7XG5cbiAgICAgICAgICAgIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQuZ3JvdXBzID0gYnVpbGRHcm91cHMocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gX2dyb3Vwcy5nZXQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbi5yZXBsYWNlKC9cXCQ8KFtePl0rKT4vZywgZnVuY3Rpb24oXywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckJyArIGdyb3Vwc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbGRHcm91cHMoYXJncywgX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcbiAgICAgICAgICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZykucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgbmFtZSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgTUFSS1VQX1JFQ1QgPSBbJ3gnLCAneScsICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0J107XG5cbiAgICB2YXIgdG9PcHRpb25hbEZyYWN0aW9uID0gZnVuY3Rpb24gdG9PcHRpb25hbEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC8lLy50ZXN0KHZhbHVlKSA/IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwIDogdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgZGVmYXVsdCBtYXJrdXAgcHJvcGVydGllcywgY2xvbmVzIG1hcmt1cFxuICAgIHZhciBwcmVwYXJlTWFya3VwID0gZnVuY3Rpb24gcHJlcGFyZU1hcmt1cChtYXJrdXApIHtcbiAgICAgICAgdmFyIF9tYXJrdXAgPSBfc2xpY2VkVG9BcnJheShtYXJrdXAsIDIpLFxuICAgICAgICAgICAgdHlwZSA9IF9tYXJrdXBbMF0sXG4gICAgICAgICAgICBwcm9wcyA9IF9tYXJrdXBbMV07XG5cbiAgICAgICAgdmFyIHJlY3QgPSBwcm9wcy5wb2ludHNcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDogTUFSS1VQX1JFQ1QucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgIHByZXZbY3Vycl0gPSB0b09wdGlvbmFsRnJhY3Rpb24ocHJvcHNbY3Vycl0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgIH0sIHt9KTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICByZWN0XG4gICAgICAgICAgICApLFxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRlc3Rpbmcgc2l6ZVxuICAgICAgICAgICAgdmFyIG1lYXN1cmUgPSBmdW5jdGlvbiBtZWFzdXJlKCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGltYWdlRWxlbWVudC5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlRWxlbWVudC5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBoYXNTaXplID0gd2lkdGggJiYgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICghaGFzU2l6ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpbWFnZUVsZW1lbnQuc3JjKTtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGltYWdlRWxlbWVudC5zcmMpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKG1lYXN1cmUsIDEpO1xuXG4gICAgICAgICAgICBtZWFzdXJlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBFZGdlIGFuZCBJRSB3aGVuIGluIEJyb3dzZXJcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudG9CbG9iKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCAndG9CbG9iJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShjYiwgdHlwZSwgcXVhbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpblN0ciA9IGF0b2IoZGF0YVVSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiaW5TdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gYmluU3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IEJsb2IoW2RhdGFdLCB7IHR5cGU6IHR5cGUgfHwgJ2ltYWdlL3BuZycgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGlzSU9TID0gaXNCcm93c2VyICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBUcmFuc2Zvcm0gUGx1Z2luXG4gICAgICovXG4gICAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgICAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICAgICAgdmFyIFR5cGUgPSB1dGlscy5UeXBlLFxuICAgICAgICAgICAgZm9yaW4gPSB1dGlscy5mb3JpbixcbiAgICAgICAgICAgIGdldEZpbGVGcm9tQmxvYiA9IHV0aWxzLmdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgIGlzRmlsZSA9IHV0aWxzLmlzRmlsZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uc1xuICAgICAgICAgKi9cblxuICAgICAgICAvLyB2YWxpZCB0cmFuc2Zvcm1zIChpbiBjb3JyZWN0IG9yZGVyKVxuICAgICAgICB2YXIgVFJBTlNGT1JNX0xJU1QgPSBbJ2Nyb3AnLCAncmVzaXplJywgJ2ZpbHRlcicsICdtYXJrdXAnLCAnb3V0cHV0J107XG5cbiAgICAgICAgdmFyIGNyZWF0ZVZhcmlhbnRDcmVhdG9yID0gZnVuY3Rpb24gY3JlYXRlVmFyaWFudENyZWF0b3IodXBkYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0cmFuc2Zvcm0sIGZpbGUsIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShmaWxlLCB1cGRhdGVNZXRhZGF0YSA/IHVwZGF0ZU1ldGFkYXRhKG1ldGFkYXRhKSA6IG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzRGVmYXVsdENyb3AgPSBmdW5jdGlvbiBpc0RlZmF1bHRDcm9wKGNyb3ApIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgY3JvcC5hc3BlY3RSYXRpbyA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGNyb3Aucm90YXRpb24gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjcm9wLnpvb20gPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjcm9wLmNlbnRlciAmJlxuICAgICAgICAgICAgICAgIGNyb3AuY2VudGVyLnggPT09IDAuNSAmJlxuICAgICAgICAgICAgICAgIGNyb3AuY2VudGVyLnkgPT09IDAuNSAmJlxuICAgICAgICAgICAgICAgIGNyb3AuZmxpcCAmJlxuICAgICAgICAgICAgICAgIGNyb3AuZmxpcC5ob3Jpem9udGFsID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGNyb3AuZmxpcC52ZXJ0aWNhbCA9PT0gZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbHRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbHRlcignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCwgX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBub3QgYXN5bmMgc2hvdWxkIHByZXBhcmUgbm93XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSghcXVlcnkoJ0lTX0FTWU5DJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzaG91bGRUcmFuc2Zvcm1GaWxlID0gZnVuY3Rpb24gc2hvdWxkVHJhbnNmb3JtRmlsZShxdWVyeSwgZmlsZSwgaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFxdWVyeSgnR0VUX0FMTE9XX0lNQUdFX1RSQU5TRk9STScpIHx8XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXJjaGl2ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIWlzRmlsZShmaWxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNJbWFnZShmaWxlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgc2l6ZSBjYW4ndCBiZSByZWFkIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaW1hZ2VcbiAgICAgICAgICAgICAgICBnZXRJbWFnZVNpemUoZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWVyeSgnR0VUX0lNQUdFX1RSQU5TRk9STV9JTUFHRV9GSUxURVInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJSZXN1bHQgPSBmbihmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJSZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWx0ZXJSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlclJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJSZXN1bHQudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZEZpbHRlcignRElEX0NSRUFURV9JVEVNJywgZnVuY3Rpb24oaXRlbSwgX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWYzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoID0gX3JlZjMuZGlzcGF0Y2g7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KCdHRVRfQUxMT1dfSU1BR0VfVFJBTlNGT1JNJykpIHJldHVybjtcblxuICAgICAgICAgICAgaXRlbS5leHRlbmQoJ3JlcXVlc3RQcmVwYXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBmaWxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBhZGRGaWx0ZXIoJ1BSRVBBUkVfT1VUUFVUJywgZnVuY3Rpb24oZmlsZSwgX3JlZjQpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWY0LnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBfcmVmNC5pdGVtO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRUcmFuc2Zvcm1GaWxlKHF1ZXJ5LCBmaWxlLCBpdGVtKS50aGVuKGZ1bmN0aW9uKHNob3VsZFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHRyYW5zZm9ybSwgZXhpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFRyYW5zZm9ybSkgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeSgnR0VUX0lNQUdFX1RSQU5TRk9STV9WQVJJQU5UU19JTkNMVURFX09SSUdJTkFMJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxdWVyeSgnR0VUX0lNQUdFX1RSQU5TRk9STV9WQVJJQU5UU19PUklHSU5BTF9OQU1FJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGRlZmF1bHQgb3V0cHV0IHZlcnNpb24gaWYgb3V0cHV0IGRlZmF1bHQgc2V0IHRvIHRydWUgb3IgaWYgbm8gdmFyaWFudHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnkoJ0dFVF9JTUFHRV9UUkFOU0ZPUk1fVkFSSUFOVFNfSU5DTFVERV9ERUZBVUxUJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzLnB1c2goZnVuY3Rpb24odHJhbnNmb3JtLCBmaWxlLCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShmaWxlLCBtZXRhZGF0YSkudGhlbihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcXVlcnkoJ0dFVF9JTUFHRV9UUkFOU0ZPUk1fVkFSSUFOVFNfREVGQVVMVF9OQU1FJyksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgb3RoZXIgdmFyaWFudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhbnRzRGVmaW5pdGlvbiA9IHF1ZXJ5KCdHRVRfSU1BR0VfVFJBTlNGT1JNX1ZBUklBTlRTJykgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGZvcmluKHZhcmlhbnRzRGVmaW5pdGlvbiwgZnVuY3Rpb24oa2V5LCBmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZVZhcmlhbnQgPSBjcmVhdGVWYXJpYW50Q3JlYXRvcihmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50cy5wdXNoKGZ1bmN0aW9uKHRyYW5zZm9ybSwgZmlsZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVWYXJpYW50KHRyYW5zZm9ybSwgZmlsZSwgbWV0YWRhdGEpLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBuYW1lOiBrZXksIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dCBmb3JtYXQgKHF1YWxpdHkgMCA9PiAxMDApXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWFsaXR5QXNQZXJjZW50YWdlID0gcXVlcnkoJ0dFVF9JTUFHRV9UUkFOU0ZPUk1fT1VUUFVUX1FVQUxJVFknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1YWxpdHlNb2RlID0gcXVlcnkoJ0dFVF9JTUFHRV9UUkFOU0ZPUk1fT1VUUFVUX1FVQUxJVFlfTU9ERScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbGl0eSA9IHF1YWxpdHlBc1BlcmNlbnRhZ2UgPT09IG51bGwgPyBudWxsIDogcXVhbGl0eUFzUGVyY2VudGFnZSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBxdWVyeSgnR0VUX0lNQUdFX1RSQU5TRk9STV9PVVRQVVRfTUlNRV9UWVBFJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGllbnRUcmFuc2Zvcm1zID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfSU1BR0VfVFJBTlNGT1JNX0NMSUVOVF9UUkFOU0ZPUk1TJykgfHwgVFJBTlNGT1JNX0xJU1Q7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRyYW5zZm9ybSBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IGNsaWVudFRyYW5zZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBhcHBseSB0aGUgZmlsZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShmaWxlLCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZE1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmlsdGVyZWRNZXRhZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uICE9PSAnZXhpZic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgaW4gbGlzdCwgcmVtb3ZlIGZyb20gb2JqZWN0LCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRUcmFuc2Zvcm1zLmluZGV4T2YoaW5zdHJ1Y3Rpb24pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJlZE1ldGFkYXRhW2luc3RydWN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZSA9IGZpbHRlcmVkTWV0YWRhdGEucmVzaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlmID0gZmlsdGVyZWRNZXRhZGF0YS5leGlmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaWx0ZXJlZE1ldGFkYXRhLm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvcCA9IGZpbHRlcmVkTWV0YWRhdGEuY3JvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyZWRNZXRhZGF0YS5maWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmt1cCA9IGZpbHRlcmVkTWV0YWRhdGEubWFya3VwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RydWN0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBleGlmID8gZXhpZi5vcmllbnRhdGlvbiA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0cHV0LnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0LnF1YWxpdHkgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmJhY2tncm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb3V0cHV0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG91dHB1dC5xdWFsaXR5ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvdXRwdXQucXVhbGl0eSAqIDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5iYWNrZ3JvdW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0dFVF9JTUFHRV9UUkFOU0ZPUk1fQ0FOVkFTX0JBQ0tHUk9VTkRfQ09MT1InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZSAmJiAocmVzaXplLnNpemUud2lkdGggfHwgcmVzaXplLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IHJlc2l6ZS5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHNjYWxlOiByZXNpemUudXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZS5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9wICYmICFpc0RlZmF1bHRDcm9wKGNyb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrdXA6IG1hcmt1cCAmJiBtYXJrdXAubGVuZ3RoID8gbWFya3VwLm1hcChwcmVwYXJlTWFya3VwKSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9ucy5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGZpbGUgdHlwZSB3aWxsIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lsbENoYW5nZVR5cGUgPSBvdXRwdXQudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyB0eXBlIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudHlwZSAhPT0gZmlsZS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIHR5cGUgbm90IHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuQ2hhbmdlUXVhbGl0eSA9IC9cXC9qcGU/ZyQvLnRlc3QoZmlsZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbGxDaGFuZ2VRdWFsaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5xdWFsaXR5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBxdWFsaXR5IHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQ2hhbmdlUXVhbGl0eSAmJiBxdWFsaXR5TW9kZSA9PT0gJ2Fsd2F5cydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIHF1YWxpdHkgbm90IHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGZpbGUgZGF0YSB3aWxsIGJlIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWxsTW9kaWZ5SW1hZ2VEYXRhID0gISEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLmNyb3AgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5maWx0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2VUeXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsQ2hhbmdlUXVhbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBtb2RpZnlpbmcgdGhlIGltYWdlIGRhdGEgdGhlbiB3ZSBkb24ndCBoYXZlIHRvIG1vZGlmeSB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2lsbE1vZGlmeUltYWdlRGF0YSkgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUNyZWF0ZUJsb2I6IHF1ZXJ5KCdHRVRfSU1BR0VfVFJBTlNGT1JNX0JFRk9SRV9DUkVBVEVfQkxPQicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZUJsb2I6IHF1ZXJ5KCdHRVRfSU1BR0VfVFJBTlNGT1JNX0FGVEVSX0NSRUFURV9CTE9CJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc01lbW9yeUxpbWl0OiBxdWVyeSgnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfTUVNT1JZX0xJTUlUJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwSW1hZ2VIZWFkOiBxdWVyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdHRVRfSU1BR0VfVFJBTlNGT1JNX09VVFBVVF9TVFJJUF9JTUFHRV9IRUFEJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JbWFnZShmaWxlLCBpbnN0cnVjdGlvbnMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBmaWxlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IGdldEZpbGVGcm9tQmxvYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9iLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmFtZSB0aGUgb3JpZ2luYWwgZmlsZW5hbWUgdG8gbWF0Y2ggdGhlIG1pbWUgdHlwZSBvZiB0aGUgb3V0cHV0IGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuYW1lRmlsZVRvTWF0Y2hNaW1lVHlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWxpZE91dHB1dE1pbWVUeXBlKGJsb2IudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgY3JlYXRpbmcgdmFyaWFudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhbnRQcm9taXNlcyA9IHZhcmlhbnRzLm1hcChmdW5jdGlvbihjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUodHJhbnNmb3JtLCBmaWxlLCBpdGVtLmdldE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHZhcmlhbnRQcm9taXNlcykudGhlbihmdW5jdGlvbihmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2luZ2xlIGZpbGUgb2JqZWN0IGluIGFycmF5LCByZXR1cm4gdGhlIHNpbmdsZSBmaWxlIG9iamVjdCBlbHNlLCByZXR1cm4gYXJyYXkgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMubGVuZ3RoID09PSAxICYmIGZpbGVzWzBdLm5hbWUgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyByZXR1cm4gdGhlIEZpbGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNbMF0uZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIHJldHVybiBhbiBhcnJheSBvZiBmaWxlcyB7IG5hbWU6J25hbWUnLCBmaWxlOkZpbGUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFeHBvc2UgcGx1Z2luIG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBhbGxvd0ltYWdlVHJhbnNmb3JtOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBpbWFnZXMgdG8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaW1hZ2VUcmFuc2Zvcm1JbWFnZUZpbHRlcjogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuXG4gICAgICAgICAgICAgICAgLy8gbnVsbCwgJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcG5nJ1xuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtT3V0cHV0TWltZVR5cGU6IFtudWxsLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgICAgICAgICAvLyBudWxsLCAwIC0gMTAwXG4gICAgICAgICAgICAgICAgaW1hZ2VUcmFuc2Zvcm1PdXRwdXRRdWFsaXR5OiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIGZhbHNlIHRvIGNvcHkgaW1hZ2UgZXhpZiBkYXRhIHRvIG91dHB1dFxuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtT3V0cHV0U3RyaXBJbWFnZUhlYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBseSB0cmFuc2Zvcm1zIGluIHRoaXMgbGlzdFxuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtQ2xpZW50VHJhbnNmb3JtczogW251bGwsIFR5cGUuQVJSQVldLFxuXG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBseSBvdXRwdXQgcXVhbGl0eSB3aGVuIGEgdHJhbnNmb3JtIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgaW1hZ2VUcmFuc2Zvcm1PdXRwdXRRdWFsaXR5TW9kZTogWydhbHdheXMnLCBUeXBlLlNUUklOR10sXG4gICAgICAgICAgICAgICAgLy8gJ2Fsd2F5cydcbiAgICAgICAgICAgICAgICAvLyAnb3B0aW9uYWwnXG4gICAgICAgICAgICAgICAgLy8gJ21pc21hdGNoJyAoZnV0dXJlIGZlYXR1cmUsIG9ubHkgYXBwbGllZCBpZiBxdWFsaXR5IGRpZmZlcnMgZnJvbSBpbnB1dClcblxuICAgICAgICAgICAgICAgIC8vIGdldCBpbWFnZSB0cmFuc2Zvcm0gdmFyaWFudHNcbiAgICAgICAgICAgICAgICBpbWFnZVRyYW5zZm9ybVZhcmlhbnRzOiBbbnVsbCwgVHlwZS5PQkpFQ1RdLFxuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIHBvc3QgdGhlIGRlZmF1bHQgdHJhbnNmb3JtZWQgZmlsZVxuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtVmFyaWFudHNJbmNsdWRlRGVmYXVsdDogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgICAgICAgICAvLyB3aGljaCBuYW1lIHRvIHByZWZpeCB0aGUgZGVmYXVsdCB0cmFuc2Zvcm1lZCBmaWxlIHdpdGhcbiAgICAgICAgICAgICAgICBpbWFnZVRyYW5zZm9ybVZhcmlhbnRzRGVmYXVsdE5hbWU6IFtudWxsLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgd2UgcG9zdCB0aGUgb3JpZ2luYWwgZmlsZVxuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtVmFyaWFudHNJbmNsdWRlT3JpZ2luYWw6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIG5hbWUgdG8gcHJlZml4IHRoZSBvcmlnaW5hbCBmaWxlIHdpdGhcbiAgICAgICAgICAgICAgICBpbWFnZVRyYW5zZm9ybVZhcmlhbnRzT3JpZ2luYWxOYW1lOiBbJ29yaWdpbmFsXycsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBiZWZvcmUgY3JlYXRpbmcgdGhlIGJsb2IsIHJlY2VpdmVzIGNhbnZhcywgZXhwZWN0cyBwcm9taXNlIHJlc29sdmUgd2l0aCBjYW52YXNcbiAgICAgICAgICAgICAgICBpbWFnZVRyYW5zZm9ybUJlZm9yZUNyZWF0ZUJsb2I6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgICAgICAgICAgIC8vIGV4cGVjdHMgcHJvbWlzZSByZXNvbHZlZCB3aXRoIGJsb2JcbiAgICAgICAgICAgICAgICBpbWFnZVRyYW5zZm9ybUFmdGVyQ3JlYXRlQmxvYjogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuXG4gICAgICAgICAgICAgICAgLy8gY2FudmFzIG1lbW9yeSBsaW1pdFxuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtQ2FudmFzTWVtb3J5TGltaXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgaXNCcm93c2VyICYmIGlzSU9TID8gNDA5NiAqIDQwOTYgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBUeXBlLklOVCxcbiAgICAgICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBpbWFnZSBvZiB0aGUgb3V0cHV0IGNhbnZhc1xuICAgICAgICAgICAgICAgIGltYWdlVHJhbnNmb3JtQ2FudmFzQmFja2dyb3VuZENvbG9yOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-transform/dist/filepond-plugin-image-transform.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*!\n * FilePond 4.29.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? factory(exports)\n        : 0;\n})(this, function(exports) {\n    'use strict';\n\n    var isNode = function isNode(value) {\n        return value instanceof HTMLElement;\n    };\n\n    var createStore = function createStore(initialState) {\n        var queries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        // internal state\n        var state = Object.assign({}, initialState);\n\n        // contains all actions for next frame, is clear when actions are requested\n        var actionQueue = [];\n        var dispatchQueue = [];\n\n        // returns a duplicate of the current state\n        var getState = function getState() {\n            return Object.assign({}, state);\n        };\n\n        // returns a duplicate of the actions array and clears the actions array\n        var processActionQueue = function processActionQueue() {\n            // create copy of actions queue\n            var queue = [].concat(actionQueue);\n\n            // clear actions queue (we don't want no double actions)\n            actionQueue.length = 0;\n\n            return queue;\n        };\n\n        // processes actions that might block the main UI thread\n        var processDispatchQueue = function processDispatchQueue() {\n            // create copy of actions queue\n            var queue = [].concat(dispatchQueue);\n\n            // clear actions queue (we don't want no double actions)\n            dispatchQueue.length = 0;\n\n            // now dispatch these actions\n            queue.forEach(function(_ref) {\n                var type = _ref.type,\n                    data = _ref.data;\n                dispatch(type, data);\n            });\n        };\n\n        // adds a new action, calls its handler and\n        var dispatch = function dispatch(type, data, isBlocking) {\n            // is blocking action (should never block if document is hidden)\n            if (isBlocking && !document.hidden) {\n                dispatchQueue.push({ type: type, data: data });\n                return;\n            }\n\n            // if this action has a handler, handle the action\n            if (actionHandlers[type]) {\n                actionHandlers[type](data);\n            }\n\n            // now add action\n            actionQueue.push({\n                type: type,\n                data: data,\n            });\n        };\n\n        var query = function query(str) {\n            var _queryHandles;\n            for (\n                var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                args[_key - 1] = arguments[_key];\n            }\n            return queryHandles[str]\n                ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n                : null;\n        };\n\n        var api = {\n            getState: getState,\n            processActionQueue: processActionQueue,\n            processDispatchQueue: processDispatchQueue,\n            dispatch: dispatch,\n            query: query,\n        };\n\n        var queryHandles = {};\n        queries.forEach(function(query) {\n            queryHandles = Object.assign({}, query(state), {}, queryHandles);\n        });\n\n        var actionHandlers = {};\n        actions.forEach(function(action) {\n            actionHandlers = Object.assign({}, action(dispatch, query, state), {}, actionHandlers);\n        });\n\n        return api;\n    };\n\n    var defineProperty = function defineProperty(obj, property, definition) {\n        if (typeof definition === 'function') {\n            obj[property] = definition;\n            return;\n        }\n        Object.defineProperty(obj, property, Object.assign({}, definition));\n    };\n\n    var forin = function forin(obj, cb) {\n        for (var key in obj) {\n            if (!obj.hasOwnProperty(key)) {\n                continue;\n            }\n\n            cb(key, obj[key]);\n        }\n    };\n\n    var createObject = function createObject(definition) {\n        var obj = {};\n        forin(definition, function(property) {\n            defineProperty(obj, property, definition[property]);\n        });\n        return obj;\n    };\n\n    var attr = function attr(node, name) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        if (value === null) {\n            return node.getAttribute(name) || node.hasAttribute(name);\n        }\n        node.setAttribute(name, value);\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var svgElements = ['svg', 'path']; // only svg elements used\n\n    var isSVGElement = function isSVGElement(tag) {\n        return svgElements.includes(tag);\n    };\n\n    var createElement = function createElement(tag, className) {\n        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (typeof className === 'object') {\n            attributes = className;\n            className = null;\n        }\n        var element = isSVGElement(tag)\n            ? document.createElementNS(ns, tag)\n            : document.createElement(tag);\n        if (className) {\n            if (isSVGElement(tag)) {\n                attr(element, 'class', className);\n            } else {\n                element.className = className;\n            }\n        }\n        forin(attributes, function(name, value) {\n            attr(element, name, value);\n        });\n        return element;\n    };\n\n    var appendChild = function appendChild(parent) {\n        return function(child, index) {\n            if (typeof index !== 'undefined' && parent.children[index]) {\n                parent.insertBefore(child, parent.children[index]);\n            } else {\n                parent.appendChild(child);\n            }\n        };\n    };\n\n    var appendChildView = function appendChildView(parent, childViews) {\n        return function(view, index) {\n            if (typeof index !== 'undefined') {\n                childViews.splice(index, 0, view);\n            } else {\n                childViews.push(view);\n            }\n\n            return view;\n        };\n    };\n\n    var removeChildView = function removeChildView(parent, childViews) {\n        return function(view) {\n            // remove from child views\n            childViews.splice(childViews.indexOf(view), 1);\n\n            // remove the element\n            if (view.element.parentNode) {\n                parent.removeChild(view.element);\n            }\n\n            return view;\n        };\n    };\n\n    var IS_BROWSER = (function() {\n        return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    })();\n    var isBrowser = function isBrowser() {\n        return IS_BROWSER;\n    };\n\n    var testElement = isBrowser() ? createElement('svg') : {};\n    var getChildCount =\n        'children' in testElement\n            ? function(el) {\n                  return el.children.length;\n              }\n            : function(el) {\n                  return el.childNodes.length;\n              };\n\n    var getViewRect = function getViewRect(elementRect, childViews, offset, scale) {\n        var left = offset[0] || elementRect.left;\n        var top = offset[1] || elementRect.top;\n        var right = left + elementRect.width;\n        var bottom = top + elementRect.height * (scale[1] || 1);\n\n        var rect = {\n            // the rectangle of the element itself\n            element: Object.assign({}, elementRect),\n\n            // the rectangle of the element expanded to contain its children, does not include any margins\n            inner: {\n                left: elementRect.left,\n                top: elementRect.top,\n                right: elementRect.right,\n                bottom: elementRect.bottom,\n            },\n\n            // the rectangle of the element expanded to contain its children including own margin and child margins\n            // margins will be added after we've recalculated the size\n            outer: {\n                left: left,\n                top: top,\n                right: right,\n                bottom: bottom,\n            },\n        };\n\n        // expand rect to fit all child rectangles\n        childViews\n            .filter(function(childView) {\n                return !childView.isRectIgnored();\n            })\n            .map(function(childView) {\n                return childView.rect;\n            })\n            .forEach(function(childViewRect) {\n                expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n                expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n            });\n\n        // calculate inner width and height\n        calculateRectSize(rect.inner);\n\n        // append additional margin (top and left margins are included in top and left automatically)\n        rect.outer.bottom += rect.element.marginBottom;\n        rect.outer.right += rect.element.marginRight;\n\n        // calculate outer width and height\n        calculateRectSize(rect.outer);\n\n        return rect;\n    };\n\n    var expandRect = function expandRect(parent, child) {\n        // adjust for parent offset\n        child.top += parent.top;\n        child.right += parent.left;\n        child.bottom += parent.top;\n        child.left += parent.left;\n\n        if (child.bottom > parent.bottom) {\n            parent.bottom = child.bottom;\n        }\n\n        if (child.right > parent.right) {\n            parent.right = child.right;\n        }\n    };\n\n    var calculateRectSize = function calculateRectSize(rect) {\n        rect.width = rect.right - rect.left;\n        rect.height = rect.bottom - rect.top;\n    };\n\n    var isNumber = function isNumber(value) {\n        return typeof value === 'number';\n    };\n\n    /**\n     * Determines if position is at destination\n     * @param position\n     * @param destination\n     * @param velocity\n     * @param errorMargin\n     * @returns {boolean}\n     */\n    var thereYet = function thereYet(position, destination, velocity) {\n        var errorMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n        return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n    };\n\n    /**\n     * Spring animation\n     */\n    var spring =\n        // default options\n        function spring() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$stiffness = _ref.stiffness,\n                stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n                _ref$damping = _ref.damping,\n                damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n                _ref$mass = _ref.mass,\n                mass = _ref$mass === void 0 ? 10 : _ref$mass;\n            var target = null;\n            var position = null;\n            var velocity = 0;\n            var resting = false;\n\n            // updates spring state\n            var interpolate = function interpolate(ts, skipToEndState) {\n                // in rest, don't animate\n                if (resting) return;\n\n                // need at least a target or position to do springy things\n                if (!(isNumber(target) && isNumber(position))) {\n                    resting = true;\n                    velocity = 0;\n                    return;\n                }\n\n                // calculate spring force\n                var f = -(position - target) * stiffness;\n\n                // update velocity by adding force based on mass\n                velocity += f / mass;\n\n                // update position by adding velocity\n                position += velocity;\n\n                // slow down based on amount of damping\n                velocity *= damping;\n\n                // we've arrived if we're near target and our velocity is near zero\n                if (thereYet(position, target, velocity) || skipToEndState) {\n                    position = target;\n                    velocity = 0;\n                    resting = true;\n\n                    // we done\n                    api.onupdate(position);\n                    api.oncomplete(position);\n                } else {\n                    // progress update\n                    api.onupdate(position);\n                }\n            };\n\n            /**\n             * Set new target value\n             * @param value\n             */\n            var setTarget = function setTarget(value) {\n                // if currently has no position, set target and position to this value\n                if (isNumber(value) && !isNumber(position)) {\n                    position = value;\n                }\n\n                // next target value will not be animated to\n                if (target === null) {\n                    target = value;\n                    position = value;\n                }\n\n                // let start moving to target\n                target = value;\n\n                // already at target\n                if (position === target || typeof target === 'undefined') {\n                    // now resting as target is current position, stop moving\n                    resting = true;\n                    velocity = 0;\n\n                    // done!\n                    api.onupdate(position);\n                    api.oncomplete(position);\n\n                    return;\n                }\n\n                resting = false;\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    set: setTarget,\n                    get: function get() {\n                        return target;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var easeLinear = function easeLinear(t) {\n        return t;\n    };\n    var easeInOutQuad = function easeInOutQuad(t) {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    };\n\n    var tween =\n        // default values\n        function tween() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$duration = _ref.duration,\n                duration = _ref$duration === void 0 ? 500 : _ref$duration,\n                _ref$easing = _ref.easing,\n                easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n                _ref$delay = _ref.delay,\n                delay = _ref$delay === void 0 ? 0 : _ref$delay;\n            var start = null;\n            var t;\n            var p;\n            var resting = true;\n            var reverse = false;\n            var target = null;\n\n            var interpolate = function interpolate(ts, skipToEndState) {\n                if (resting || target === null) return;\n\n                if (start === null) {\n                    start = ts;\n                }\n\n                if (ts - start < delay) return;\n\n                t = ts - start - delay;\n\n                if (t >= duration || skipToEndState) {\n                    t = 1;\n                    p = reverse ? 0 : 1;\n                    api.onupdate(p * target);\n                    api.oncomplete(p * target);\n                    resting = true;\n                } else {\n                    p = t / duration;\n                    api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n                }\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    get: function get() {\n                        return reverse ? 0 : target;\n                    },\n                    set: function set(value) {\n                        // is initial value\n                        if (target === null) {\n                            target = value;\n                            api.onupdate(value);\n                            api.oncomplete(value);\n                            return;\n                        }\n\n                        // want to tween to a smaller value and have a current value\n                        if (value < target) {\n                            target = 1;\n                            reverse = true;\n                        } else {\n                            // not tweening to a smaller value\n                            reverse = false;\n                            target = value;\n                        }\n\n                        // let's go!\n                        resting = false;\n                        start = null;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var animator = {\n        spring: spring,\n        tween: tween,\n    };\n\n    /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n    var createAnimator = function createAnimator(definition, category, property) {\n        // default is single definition\n        // we check if transform is set, if so, we check if property is set\n        var def =\n            definition[category] && typeof definition[category][property] === 'object'\n                ? definition[category][property]\n                : definition[category] || definition;\n\n        var type = typeof def === 'string' ? def : def.type;\n        var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n        return animator[type] ? animator[type](props) : null;\n    };\n\n    var addGetSet = function addGetSet(keys, obj, props) {\n        var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        obj = Array.isArray(obj) ? obj : [obj];\n        obj.forEach(function(o) {\n            keys.forEach(function(key) {\n                var name = key;\n                var getter = function getter() {\n                    return props[key];\n                };\n                var setter = function setter(value) {\n                    return (props[key] = value);\n                };\n\n                if (typeof key === 'object') {\n                    name = key.key;\n                    getter = key.getter || getter;\n                    setter = key.setter || setter;\n                }\n\n                if (o[name] && !overwrite) {\n                    return;\n                }\n\n                o[name] = {\n                    get: getter,\n                    set: setter,\n                };\n            });\n        });\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // setup animators\n\n    var animations = function animations(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI;\n        // initial properties\n        var initialProps = Object.assign({}, viewProps);\n\n        // list of all active animations\n        var animations = [];\n\n        // setup animators\n        forin(mixinConfig, function(property, animation) {\n            var animator = createAnimator(animation);\n            if (!animator) {\n                return;\n            }\n\n            // when the animator updates, update the view state value\n            animator.onupdate = function(value) {\n                viewProps[property] = value;\n            };\n\n            // set animator target\n            animator.target = initialProps[property];\n\n            // when value is set, set the animator target value\n            var prop = {\n                key: property,\n                setter: function setter(value) {\n                    // if already at target, we done!\n                    if (animator.target === value) {\n                        return;\n                    }\n\n                    animator.target = value;\n                },\n                getter: function getter() {\n                    return viewProps[property];\n                },\n            };\n\n            // add getters and setters\n            addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n            // add it to the list for easy updating from the _write method\n            animations.push(animator);\n        });\n\n        // expose internal write api\n        return {\n            write: function write(ts) {\n                var skipToEndState = document.hidden;\n                var resting = true;\n                animations.forEach(function(animation) {\n                    if (!animation.resting) resting = false;\n                    animation.interpolate(ts, skipToEndState);\n                });\n                return resting;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var addEvent = function addEvent(element) {\n        return function(type, fn) {\n            element.addEventListener(type, fn);\n        };\n    };\n\n    var removeEvent = function removeEvent(element) {\n        return function(type, fn) {\n            element.removeEventListener(type, fn);\n        };\n    };\n\n    // mixin\n    var listeners = function listeners(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            viewState = _ref.viewState,\n            view = _ref.view;\n        var events = [];\n\n        var add = addEvent(view.element);\n        var remove = removeEvent(view.element);\n\n        viewExternalAPI.on = function(type, fn) {\n            events.push({\n                type: type,\n                fn: fn,\n            });\n\n            add(type, fn);\n        };\n\n        viewExternalAPI.off = function(type, fn) {\n            events.splice(\n                events.findIndex(function(event) {\n                    return event.type === type && event.fn === fn;\n                }),\n                1\n            );\n\n            remove(type, fn);\n        };\n\n        return {\n            write: function write() {\n                // not busy\n                return true;\n            },\n            destroy: function destroy() {\n                events.forEach(function(event) {\n                    remove(event.type, event.fn);\n                });\n            },\n        };\n    };\n\n    // add to external api and link to props\n\n    var apis = function apis(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewExternalAPI = _ref.viewExternalAPI;\n        addGetSet(mixinConfig, viewExternalAPI, viewProps);\n    };\n\n    var isDefined = function isDefined(value) {\n        return value != null;\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // set initial state based on props in viewProps\n    // apply as transforms each frame\n\n    var defaults = {\n        opacity: 1,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        rotateX: 0,\n        rotateY: 0,\n        rotateZ: 0,\n        originX: 0,\n        originY: 0,\n    };\n\n    var styles = function styles(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            view = _ref.view;\n        // initial props\n        var initialProps = Object.assign({}, viewProps);\n\n        // current props\n        var currentProps = {};\n\n        // we will add those properties to the external API and link them to the viewState\n        addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n        // override rect on internal and external rect getter so it takes in account transforms\n        var getOffset = function getOffset() {\n            return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n        };\n\n        var getScale = function getScale() {\n            return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n        };\n        var getRect = function getRect() {\n            return view.rect\n                ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n                : null;\n        };\n        viewInternalAPI.rect = { get: getRect };\n        viewExternalAPI.rect = { get: getRect };\n\n        // apply view props\n        mixinConfig.forEach(function(key) {\n            viewProps[key] =\n                typeof initialProps[key] === 'undefined' ? defaults[key] : initialProps[key];\n        });\n\n        // expose api\n        return {\n            write: function write() {\n                // see if props have changed\n                if (!propsHaveChanged(currentProps, viewProps)) {\n                    return;\n                }\n\n                // moves element to correct position on screen\n                applyStyles(view.element, viewProps);\n\n                // store new transforms\n                Object.assign(currentProps, Object.assign({}, viewProps));\n\n                // no longer busy\n                return true;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n        // different amount of keys\n        if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n            return true;\n        }\n\n        // lets analyze the individual props\n        for (var prop in newProps) {\n            if (newProps[prop] !== currentProps[prop]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    var applyStyles = function applyStyles(element, _ref2) {\n        var opacity = _ref2.opacity,\n            perspective = _ref2.perspective,\n            translateX = _ref2.translateX,\n            translateY = _ref2.translateY,\n            scaleX = _ref2.scaleX,\n            scaleY = _ref2.scaleY,\n            rotateX = _ref2.rotateX,\n            rotateY = _ref2.rotateY,\n            rotateZ = _ref2.rotateZ,\n            originX = _ref2.originX,\n            originY = _ref2.originY,\n            width = _ref2.width,\n            height = _ref2.height;\n\n        var transforms = '';\n        var styles = '';\n\n        // handle transform origin\n        if (isDefined(originX) || isDefined(originY)) {\n            styles += 'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n        }\n\n        // transform order is relevant\n        // 0. perspective\n        if (isDefined(perspective)) {\n            transforms += 'perspective(' + perspective + 'px) ';\n        }\n\n        // 1. translate\n        if (isDefined(translateX) || isDefined(translateY)) {\n            transforms +=\n                'translate3d(' + (translateX || 0) + 'px, ' + (translateY || 0) + 'px, 0) ';\n        }\n\n        // 2. scale\n        if (isDefined(scaleX) || isDefined(scaleY)) {\n            transforms +=\n                'scale3d(' +\n                (isDefined(scaleX) ? scaleX : 1) +\n                ', ' +\n                (isDefined(scaleY) ? scaleY : 1) +\n                ', 1) ';\n        }\n\n        // 3. rotate\n        if (isDefined(rotateZ)) {\n            transforms += 'rotateZ(' + rotateZ + 'rad) ';\n        }\n\n        if (isDefined(rotateX)) {\n            transforms += 'rotateX(' + rotateX + 'rad) ';\n        }\n\n        if (isDefined(rotateY)) {\n            transforms += 'rotateY(' + rotateY + 'rad) ';\n        }\n\n        // add transforms\n        if (transforms.length) {\n            styles += 'transform:' + transforms + ';';\n        }\n\n        // add opacity\n        if (isDefined(opacity)) {\n            styles += 'opacity:' + opacity + ';';\n\n            // if we reach zero, we make the element inaccessible\n            if (opacity === 0) {\n                styles += 'visibility:hidden;';\n            }\n\n            // if we're below 100% opacity this element can't be clicked\n            if (opacity < 1) {\n                styles += 'pointer-events:none;';\n            }\n        }\n\n        // add height\n        if (isDefined(height)) {\n            styles += 'height:' + height + 'px;';\n        }\n\n        // add width\n        if (isDefined(width)) {\n            styles += 'width:' + width + 'px;';\n        }\n\n        // apply styles\n        var elementCurrentStyle = element.elementCurrentStyle || '';\n\n        // if new styles does not match current styles, lets update!\n        if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n            element.style.cssText = styles;\n            // store current styles so we can compare them to new styles later on\n            // _not_ getting the style value is faster\n            element.elementCurrentStyle = styles;\n        }\n    };\n\n    var Mixins = {\n        styles: styles,\n        listeners: listeners,\n        animations: animations,\n        apis: apis,\n    };\n\n    var updateRect = function updateRect() {\n        var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!element.layoutCalculated) {\n            rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n            rect.marginTop = parseInt(style.marginTop, 10) || 0;\n            rect.marginRight = parseInt(style.marginRight, 10) || 0;\n            rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n            rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n            element.layoutCalculated = true;\n        }\n\n        rect.left = element.offsetLeft || 0;\n        rect.top = element.offsetTop || 0;\n        rect.width = element.offsetWidth || 0;\n        rect.height = element.offsetHeight || 0;\n\n        rect.right = rect.left + rect.width;\n        rect.bottom = rect.top + rect.height;\n\n        rect.scrollTop = element.scrollTop;\n\n        rect.hidden = element.offsetParent === null;\n\n        return rect;\n    };\n\n    var createView =\n        // default view definition\n        function createView() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$tag = _ref.tag,\n                tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n                _ref$name = _ref.name,\n                name = _ref$name === void 0 ? null : _ref$name,\n                _ref$attributes = _ref.attributes,\n                attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n                _ref$read = _ref.read,\n                read = _ref$read === void 0 ? function() {} : _ref$read,\n                _ref$write = _ref.write,\n                write = _ref$write === void 0 ? function() {} : _ref$write,\n                _ref$create = _ref.create,\n                create = _ref$create === void 0 ? function() {} : _ref$create,\n                _ref$destroy = _ref.destroy,\n                destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n                _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n                filterFrameActionsForChild =\n                    _ref$filterFrameActio === void 0\n                        ? function(child, actions) {\n                              return actions;\n                          }\n                        : _ref$filterFrameActio,\n                _ref$didCreateView = _ref.didCreateView,\n                didCreateView = _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n                _ref$didWriteView = _ref.didWriteView,\n                didWriteView = _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n                _ref$ignoreRect = _ref.ignoreRect,\n                ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n                _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n                ignoreRectUpdate = _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n                _ref$mixins = _ref.mixins,\n                mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n            return function(\n                // each view requires reference to store\n                store\n            ) {\n                var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                // root element should not be changed\n                var element = createElement(tag, 'filepond--' + name, attributes);\n\n                // style reference should also not be changed\n                var style = window.getComputedStyle(element, null);\n\n                // element rectangle\n                var rect = updateRect();\n                var frameRect = null;\n\n                // rest state\n                var isResting = false;\n\n                // pretty self explanatory\n                var childViews = [];\n\n                // loaded mixins\n                var activeMixins = [];\n\n                // references to created children\n                var ref = {};\n\n                // state used for each instance\n                var state = {};\n\n                // list of writers that will be called to update this view\n                var writers = [\n                    write, // default writer\n                ];\n\n                var readers = [\n                    read, // default reader\n                ];\n\n                var destroyers = [\n                    destroy, // default destroy\n                ];\n\n                // core view methods\n                var getElement = function getElement() {\n                    return element;\n                };\n                var getChildViews = function getChildViews() {\n                    return childViews.concat();\n                };\n                var getReference = function getReference() {\n                    return ref;\n                };\n                var createChildView = function createChildView(store) {\n                    return function(view, props) {\n                        return view(store, props);\n                    };\n                };\n                var getRect = function getRect() {\n                    if (frameRect) {\n                        return frameRect;\n                    }\n                    frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n                    return frameRect;\n                };\n                var getStyle = function getStyle() {\n                    return style;\n                };\n\n                /**\n                 * Read data from DOM\n                 * @private\n                 */\n                var _read = function _read() {\n                    frameRect = null;\n\n                    // read child views\n                    childViews.forEach(function(child) {\n                        return child._read();\n                    });\n\n                    var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n                    if (shouldUpdate) {\n                        updateRect(rect, element, style);\n                    }\n\n                    // readers\n                    var api = { root: internalAPI, props: props, rect: rect };\n                    readers.forEach(function(reader) {\n                        return reader(api);\n                    });\n                };\n\n                /**\n                 * Write data to DOM\n                 * @private\n                 */\n                var _write = function _write(ts, frameActions, shouldOptimize) {\n                    // if no actions, we assume that the view is resting\n                    var resting = frameActions.length === 0;\n\n                    // writers\n                    writers.forEach(function(writer) {\n                        var writerResting = writer({\n                            props: props,\n                            root: internalAPI,\n                            actions: frameActions,\n                            timestamp: ts,\n                            shouldOptimize: shouldOptimize,\n                        });\n\n                        if (writerResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // run mixins\n                    activeMixins.forEach(function(mixin) {\n                        // if one of the mixins is still busy after write operation, we are not resting\n                        var mixinResting = mixin.write(ts);\n                        if (mixinResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // updates child views that are currently attached to the DOM\n                    childViews\n                        .filter(function(child) {\n                            return !!child.element.parentNode;\n                        })\n                        .forEach(function(child) {\n                            // if a child view is not resting, we are not resting\n                            var childResting = child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            if (!childResting) {\n                                resting = false;\n                            }\n                        });\n\n                    // append new elements to DOM and update those\n                    childViews\n                        //.filter(child => !child.element.parentNode)\n                        .forEach(function(child, index) {\n                            // skip\n                            if (child.element.parentNode) {\n                                return;\n                            }\n\n                            // append to DOM\n                            internalAPI.appendChild(child.element, index);\n\n                            // call read (need to know the size of these elements)\n                            child._read();\n\n                            // re-call write\n                            child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            // we just added somthing to the dom, no rest\n                            resting = false;\n                        });\n\n                    // update resting state\n                    isResting = resting;\n\n                    didWriteView({\n                        props: props,\n                        root: internalAPI,\n                        actions: frameActions,\n                        timestamp: ts,\n                    });\n\n                    // let parent know if we are resting\n                    return resting;\n                };\n\n                var _destroy = function _destroy() {\n                    activeMixins.forEach(function(mixin) {\n                        return mixin.destroy();\n                    });\n                    destroyers.forEach(function(destroyer) {\n                        destroyer({ root: internalAPI, props: props });\n                    });\n                    childViews.forEach(function(child) {\n                        return child._destroy();\n                    });\n                };\n\n                // sharedAPI\n                var sharedAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    style: {\n                        get: getStyle,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n                };\n\n                // private API definition\n                var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: getRect,\n                    },\n\n                    // access to custom children references\n                    ref: {\n                        get: getReference,\n                    },\n\n                    // dom modifiers\n                    is: function is(needle) {\n                        return name === needle;\n                    },\n                    appendChild: appendChild(element),\n                    createChildView: createChildView(store),\n                    linkView: function linkView(view) {\n                        childViews.push(view);\n                        return view;\n                    },\n                    unlinkView: function unlinkView(view) {\n                        childViews.splice(childViews.indexOf(view), 1);\n                    },\n                    appendChildView: appendChildView(element, childViews),\n                    removeChildView: removeChildView(element, childViews),\n                    registerWriter: function registerWriter(writer) {\n                        return writers.push(writer);\n                    },\n                    registerReader: function registerReader(reader) {\n                        return readers.push(reader);\n                    },\n                    registerDestroyer: function registerDestroyer(destroyer) {\n                        return destroyers.push(destroyer);\n                    },\n                    invalidateLayout: function invalidateLayout() {\n                        return (element.layoutCalculated = false);\n                    },\n\n                    // access to data store\n                    dispatch: store.dispatch,\n                    query: store.query,\n                });\n\n                // public view API methods\n                var externalAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n\n                    rect: {\n                        get: getRect,\n                    },\n\n                    resting: {\n                        get: function get() {\n                            return isResting;\n                        },\n                    },\n\n                    isRectIgnored: function isRectIgnored() {\n                        return ignoreRect;\n                    },\n                    _read: _read,\n                    _write: _write,\n                    _destroy: _destroy,\n                };\n\n                // mixin API methods\n                var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: function get() {\n                            return rect;\n                        },\n                    },\n                });\n\n                // add mixin functionality\n                Object.keys(mixins)\n                    .sort(function(a, b) {\n                        // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n                        if (a === 'styles') {\n                            return 1;\n                        } else if (b === 'styles') {\n                            return -1;\n                        }\n                        return 0;\n                    })\n                    .forEach(function(key) {\n                        var mixinAPI = Mixins[key]({\n                            mixinConfig: mixins[key],\n                            viewProps: props,\n                            viewState: state,\n                            viewInternalAPI: internalAPIDefinition,\n                            viewExternalAPI: externalAPIDefinition,\n                            view: createObject(mixinAPIDefinition),\n                        });\n\n                        if (mixinAPI) {\n                            activeMixins.push(mixinAPI);\n                        }\n                    });\n\n                // construct private api\n                var internalAPI = createObject(internalAPIDefinition);\n\n                // create the view\n                create({\n                    root: internalAPI,\n                    props: props,\n                });\n\n                // append created child views to root node\n                var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n                childViews.forEach(function(child, index) {\n                    internalAPI.appendChild(child.element, childCount + index);\n                });\n\n                // call did create\n                didCreateView(internalAPI);\n\n                // expose public api\n                return createObject(externalAPIDefinition);\n            };\n        };\n\n    var createPainter = function createPainter(read, write) {\n        var fps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n        var name = '__framePainter';\n\n        // set global painter\n        if (window[name]) {\n            window[name].readers.push(read);\n            window[name].writers.push(write);\n            return;\n        }\n\n        window[name] = {\n            readers: [read],\n            writers: [write],\n        };\n\n        var painter = window[name];\n\n        var interval = 1000 / fps;\n        var last = null;\n        var id = null;\n        var requestTick = null;\n        var cancelTick = null;\n\n        var setTimerType = function setTimerType() {\n            if (document.hidden) {\n                requestTick = function requestTick() {\n                    return window.setTimeout(function() {\n                        return tick(performance.now());\n                    }, interval);\n                };\n                cancelTick = function cancelTick() {\n                    return window.clearTimeout(id);\n                };\n            } else {\n                requestTick = function requestTick() {\n                    return window.requestAnimationFrame(tick);\n                };\n                cancelTick = function cancelTick() {\n                    return window.cancelAnimationFrame(id);\n                };\n            }\n        };\n\n        document.addEventListener('visibilitychange', function() {\n            if (cancelTick) cancelTick();\n            setTimerType();\n            tick(performance.now());\n        });\n\n        var tick = function tick(ts) {\n            // queue next tick\n            id = requestTick(tick);\n\n            // limit fps\n            if (!last) {\n                last = ts;\n            }\n\n            var delta = ts - last;\n\n            if (delta <= interval) {\n                // skip frame\n                return;\n            }\n\n            // align next frame\n            last = ts - (delta % interval);\n\n            // update view\n            painter.readers.forEach(function(read) {\n                return read();\n            });\n            painter.writers.forEach(function(write) {\n                return write(ts);\n            });\n        };\n\n        setTimerType();\n        tick(performance.now());\n\n        return {\n            pause: function pause() {\n                cancelTick(id);\n            },\n        };\n    };\n\n    var createRoute = function createRoute(routes, fn) {\n        return function(_ref) {\n            var root = _ref.root,\n                props = _ref.props,\n                _ref$actions = _ref.actions,\n                actions = _ref$actions === void 0 ? [] : _ref$actions,\n                timestamp = _ref.timestamp,\n                shouldOptimize = _ref.shouldOptimize;\n            actions\n                .filter(function(action) {\n                    return routes[action.type];\n                })\n                .forEach(function(action) {\n                    return routes[action.type]({\n                        root: root,\n                        props: props,\n                        action: action.data,\n                        timestamp: timestamp,\n                        shouldOptimize: shouldOptimize,\n                    });\n                });\n\n            if (fn) {\n                fn({\n                    root: root,\n                    props: props,\n                    actions: actions,\n                    timestamp: timestamp,\n                    shouldOptimize: shouldOptimize,\n                });\n            }\n        };\n    };\n\n    var insertBefore = function insertBefore(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n    };\n\n    var insertAfter = function insertAfter(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n    };\n\n    var isArray = function isArray(value) {\n        return Array.isArray(value);\n    };\n\n    var isEmpty = function isEmpty(value) {\n        return value == null;\n    };\n\n    var trim = function trim(str) {\n        return str.trim();\n    };\n\n    var toString = function toString(value) {\n        return '' + value;\n    };\n\n    var toArray = function toArray(value) {\n        var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n        if (isEmpty(value)) {\n            return [];\n        }\n        if (isArray(value)) {\n            return value;\n        }\n        return toString(value)\n            .split(splitter)\n            .map(trim)\n            .filter(function(str) {\n                return str.length;\n            });\n    };\n\n    var isBoolean = function isBoolean(value) {\n        return typeof value === 'boolean';\n    };\n\n    var toBoolean = function toBoolean(value) {\n        return isBoolean(value) ? value : value === 'true';\n    };\n\n    var isString = function isString(value) {\n        return typeof value === 'string';\n    };\n\n    var toNumber = function toNumber(value) {\n        return isNumber(value)\n            ? value\n            : isString(value)\n            ? toString(value).replace(/[a-z]+/gi, '')\n            : 0;\n    };\n\n    var toInt = function toInt(value) {\n        return parseInt(toNumber(value), 10);\n    };\n\n    var toFloat = function toFloat(value) {\n        return parseFloat(toNumber(value));\n    };\n\n    var isInt = function isInt(value) {\n        return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n    };\n\n    var toBytes = function toBytes(value) {\n        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        // is in bytes\n        if (isInt(value)) {\n            return value;\n        }\n\n        // is natural file size\n        var naturalFileSize = toString(value).trim();\n\n        // if is value in megabytes\n        if (/MB$/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n            return toInt(naturalFileSize) * base * base;\n        }\n\n        // if is value in kilobytes\n        if (/KB/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n            return toInt(naturalFileSize) * base;\n        }\n\n        return toInt(naturalFileSize);\n    };\n\n    var isFunction = function isFunction(value) {\n        return typeof value === 'function';\n    };\n\n    var toFunctionReference = function toFunctionReference(string) {\n        var ref = self;\n        var levels = string.split('.');\n        var level = null;\n        while ((level = levels.shift())) {\n            ref = ref[level];\n            if (!ref) {\n                return null;\n            }\n        }\n        return ref;\n    };\n\n    var methods = {\n        process: 'POST',\n        patch: 'PATCH',\n        revert: 'DELETE',\n        fetch: 'GET',\n        restore: 'GET',\n        load: 'GET',\n    };\n\n    var createServerAPI = function createServerAPI(outline) {\n        var api = {};\n\n        api.url = isString(outline) ? outline : outline.url || '';\n        api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n        api.headers = outline.headers ? outline.headers : {};\n\n        forin(methods, function(key) {\n            api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n        });\n\n        // remove process if no url or process on outline\n        api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n\n        // special treatment for remove\n        api.remove = outline.remove || null;\n\n        // remove generic headers from api object\n        delete api.headers;\n\n        return api;\n    };\n\n    var createAction = function createAction(name, outline, method, timeout, headers) {\n        // is explicitely set to null so disable\n        if (outline === null) {\n            return null;\n        }\n\n        // if is custom function, done! Dev handles everything.\n        if (typeof outline === 'function') {\n            return outline;\n        }\n\n        // build action object\n        var action = {\n            url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n            method: method,\n            headers: headers,\n            withCredentials: false,\n            timeout: timeout,\n            onload: null,\n            ondata: null,\n            onerror: null,\n        };\n\n        // is a single url\n        if (isString(outline)) {\n            action.url = outline;\n            return action;\n        }\n\n        // overwrite\n        Object.assign(action, outline);\n\n        // see if should reformat headers;\n        if (isString(action.headers)) {\n            var parts = action.headers.split(/:(.+)/);\n            action.headers = {\n                header: parts[0],\n                value: parts[1],\n            };\n        }\n\n        // if is bool withCredentials\n        action.withCredentials = toBoolean(action.withCredentials);\n\n        return action;\n    };\n\n    var toServerAPI = function toServerAPI(value) {\n        return createServerAPI(value);\n    };\n\n    var isNull = function isNull(value) {\n        return value === null;\n    };\n\n    var isObject = function isObject(value) {\n        return typeof value === 'object' && value !== null;\n    };\n\n    var isAPI = function isAPI(value) {\n        return (\n            isObject(value) &&\n            isString(value.url) &&\n            isObject(value.process) &&\n            isObject(value.revert) &&\n            isObject(value.restore) &&\n            isObject(value.fetch)\n        );\n    };\n\n    var getType = function getType(value) {\n        if (isArray(value)) {\n            return 'array';\n        }\n\n        if (isNull(value)) {\n            return 'null';\n        }\n\n        if (isInt(value)) {\n            return 'int';\n        }\n\n        if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n            return 'bytes';\n        }\n\n        if (isAPI(value)) {\n            return 'api';\n        }\n\n        return typeof value;\n    };\n\n    var replaceSingleQuotes = function replaceSingleQuotes(str) {\n        return str\n            .replace(/{\\s*'/g, '{\"')\n            .replace(/'\\s*}/g, '\"}')\n            .replace(/'\\s*:/g, '\":')\n            .replace(/:\\s*'/g, ':\"')\n            .replace(/,\\s*'/g, ',\"')\n            .replace(/'\\s*,/g, '\",');\n    };\n\n    var conversionTable = {\n        array: toArray,\n        boolean: toBoolean,\n        int: function int(value) {\n            return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n        },\n        number: toFloat,\n        float: toFloat,\n        bytes: toBytes,\n        string: function string(value) {\n            return isFunction(value) ? value : toString(value);\n        },\n        function: function _function(value) {\n            return toFunctionReference(value);\n        },\n        serverapi: toServerAPI,\n        object: function object(value) {\n            try {\n                return JSON.parse(replaceSingleQuotes(value));\n            } catch (e) {\n                return null;\n            }\n        },\n    };\n\n    var convertTo = function convertTo(value, type) {\n        return conversionTable[type](value);\n    };\n\n    var getValueByType = function getValueByType(newValue, defaultValue, valueType) {\n        // can always assign default value\n        if (newValue === defaultValue) {\n            return newValue;\n        }\n\n        // get the type of the new value\n        var newValueType = getType(newValue);\n\n        // is valid type?\n        if (newValueType !== valueType) {\n            // is string input, let's attempt to convert\n            var convertedValue = convertTo(newValue, valueType);\n\n            // what is the type now\n            newValueType = getType(convertedValue);\n\n            // no valid conversions found\n            if (convertedValue === null) {\n                throw 'Trying to assign value with incorrect type to \"' +\n                    option +\n                    '\", allowed type: \"' +\n                    valueType +\n                    '\"';\n            } else {\n                newValue = convertedValue;\n            }\n        }\n\n        // assign new value\n        return newValue;\n    };\n\n    var createOption = function createOption(defaultValue, valueType) {\n        var currentValue = defaultValue;\n        return {\n            enumerable: true,\n            get: function get() {\n                return currentValue;\n            },\n            set: function set(newValue) {\n                currentValue = getValueByType(newValue, defaultValue, valueType);\n            },\n        };\n    };\n\n    var createOptions = function createOptions(options) {\n        var obj = {};\n        forin(options, function(prop) {\n            var optionDefinition = options[prop];\n            obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n        });\n        return createObject(obj);\n    };\n\n    var createInitialState = function createInitialState(options) {\n        return {\n            // model\n            items: [],\n\n            // timeout used for calling update items\n            listUpdateTimeout: null,\n\n            // timeout used for stacking metadata updates\n            itemUpdateTimeout: null,\n\n            // queue of items waiting to be processed\n            processingQueue: [],\n\n            // options\n            options: createOptions(options),\n        };\n    };\n\n    var fromCamels = function fromCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string\n            .split(/(?=[A-Z])/)\n            .map(function(part) {\n                return part.toLowerCase();\n            })\n            .join(separator);\n    };\n\n    var createOptionAPI = function createOptionAPI(store, options) {\n        var obj = {};\n        forin(options, function(key) {\n            obj[key] = {\n                get: function get() {\n                    return store.getState().options[key];\n                },\n                set: function set(value) {\n                    store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n                        value: value,\n                    });\n                },\n            };\n        });\n        return obj;\n    };\n\n    var createOptionActions = function createOptionActions(options) {\n        return function(dispatch, query, state) {\n            var obj = {};\n            forin(options, function(key) {\n                var name = fromCamels(key, '_').toUpperCase();\n\n                obj['SET_' + name] = function(action) {\n                    try {\n                        state.options[key] = action.value;\n                    } catch (e) {} // nope, failed\n\n                    // we successfully set the value of this option\n                    dispatch('DID_SET_' + name, { value: state.options[key] });\n                };\n            });\n            return obj;\n        };\n    };\n\n    var createOptionQueries = function createOptionQueries(options) {\n        return function(state) {\n            var obj = {};\n            forin(options, function(key) {\n                obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n                    return state.options[key];\n                };\n            });\n            return obj;\n        };\n    };\n\n    var InteractionMethod = {\n        API: 1,\n        DROP: 2,\n        BROWSE: 3,\n        PASTE: 4,\n        NONE: 5,\n    };\n\n    var getUniqueId = function getUniqueId() {\n        return Math.random()\n            .toString(36)\n            .substr(2, 9);\n    };\n\n    function _typeof(obj) {\n        if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n            _typeof = function(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function(obj) {\n                return obj &&\n                    typeof Symbol === 'function' &&\n                    obj.constructor === Symbol &&\n                    obj !== Symbol.prototype\n                    ? 'symbol'\n                    : typeof obj;\n            };\n        }\n\n        return _typeof(obj);\n    }\n\n    var REACT_ELEMENT_TYPE;\n\n    function _jsx(type, props, key, children) {\n        if (!REACT_ELEMENT_TYPE) {\n            REACT_ELEMENT_TYPE =\n                (typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element')) ||\n                0xeac7;\n        }\n\n        var defaultProps = type && type.defaultProps;\n        var childrenLength = arguments.length - 3;\n\n        if (!props && childrenLength !== 0) {\n            props = {\n                children: void 0,\n            };\n        }\n\n        if (props && defaultProps) {\n            for (var propName in defaultProps) {\n                if (props[propName] === void 0) {\n                    props[propName] = defaultProps[propName];\n                }\n            }\n        } else if (!props) {\n            props = defaultProps || {};\n        }\n\n        if (childrenLength === 1) {\n            props.children = children;\n        } else if (childrenLength > 1) {\n            var childArray = new Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n                childArray[i] = arguments[i + 3];\n            }\n\n            props.children = childArray;\n        }\n\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: type,\n            key: key === undefined ? null : '' + key,\n            ref: null,\n            props: props,\n            _owner: null,\n        };\n    }\n\n    function _asyncIterator(iterable) {\n        var method;\n\n        if (typeof Symbol !== 'undefined') {\n            if (Symbol.asyncIterator) {\n                method = iterable[Symbol.asyncIterator];\n                if (method != null) return method.call(iterable);\n            }\n\n            if (Symbol.iterator) {\n                method = iterable[Symbol.iterator];\n                if (method != null) return method.call(iterable);\n            }\n        }\n\n        throw new TypeError('Object is not async iterable');\n    }\n\n    function _AwaitValue(value) {\n        this.wrapped = value;\n    }\n\n    function _AsyncGenerator(gen) {\n        var front, back;\n\n        function send(key, arg) {\n            return new Promise(function(resolve, reject) {\n                var request = {\n                    key: key,\n                    arg: arg,\n                    resolve: resolve,\n                    reject: reject,\n                    next: null,\n                };\n\n                if (back) {\n                    back = back.next = request;\n                } else {\n                    front = back = request;\n                    resume(key, arg);\n                }\n            });\n        }\n\n        function resume(key, arg) {\n            try {\n                var result = gen[key](arg);\n                var value = result.value;\n                var wrappedAwait = value instanceof _AwaitValue;\n                Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n                    function(arg) {\n                        if (wrappedAwait) {\n                            resume('next', arg);\n                            return;\n                        }\n\n                        settle(result.done ? 'return' : 'normal', arg);\n                    },\n                    function(err) {\n                        resume('throw', err);\n                    }\n                );\n            } catch (err) {\n                settle('throw', err);\n            }\n        }\n\n        function settle(type, value) {\n            switch (type) {\n                case 'return':\n                    front.resolve({\n                        value: value,\n                        done: true,\n                    });\n                    break;\n\n                case 'throw':\n                    front.reject(value);\n                    break;\n\n                default:\n                    front.resolve({\n                        value: value,\n                        done: false,\n                    });\n                    break;\n            }\n\n            front = front.next;\n\n            if (front) {\n                resume(front.key, front.arg);\n            } else {\n                back = null;\n            }\n        }\n\n        this._invoke = send;\n\n        if (typeof gen.return !== 'function') {\n            this.return = undefined;\n        }\n    }\n\n    if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n\n    _AsyncGenerator.prototype.next = function(arg) {\n        return this._invoke('next', arg);\n    };\n\n    _AsyncGenerator.prototype.throw = function(arg) {\n        return this._invoke('throw', arg);\n    };\n\n    _AsyncGenerator.prototype.return = function(arg) {\n        return this._invoke('return', arg);\n    };\n\n    function _wrapAsyncGenerator(fn) {\n        return function() {\n            return new _AsyncGenerator(fn.apply(this, arguments));\n        };\n    }\n\n    function _awaitAsyncGenerator(value) {\n        return new _AwaitValue(value);\n    }\n\n    function _asyncGeneratorDelegate(inner, awaitWrap) {\n        var iter = {},\n            waiting = false;\n\n        function pump(key, value) {\n            waiting = true;\n            value = new Promise(function(resolve) {\n                resolve(inner[key](value));\n            });\n            return {\n                done: false,\n                value: awaitWrap(value),\n            };\n        }\n\n        if (typeof Symbol === 'function' && Symbol.iterator) {\n            iter[Symbol.iterator] = function() {\n                return this;\n            };\n        }\n\n        iter.next = function(value) {\n            if (waiting) {\n                waiting = false;\n                return value;\n            }\n\n            return pump('next', value);\n        };\n\n        if (typeof inner.throw === 'function') {\n            iter.throw = function(value) {\n                if (waiting) {\n                    waiting = false;\n                    throw value;\n                }\n\n                return pump('throw', value);\n            };\n        }\n\n        if (typeof inner.return === 'function') {\n            iter.return = function(value) {\n                return pump('return', value);\n            };\n        }\n\n        return iter;\n    }\n\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self = this,\n                args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self, args);\n\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n                }\n\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n                }\n\n                _next(undefined);\n            });\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError('Cannot call a class as a function');\n        }\n    }\n\n    function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if ('value' in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n    }\n\n    function _defineEnumerableProperties(obj, descs) {\n        for (var key in descs) {\n            var desc = descs[key];\n            desc.configurable = desc.enumerable = true;\n            if ('value' in desc) desc.writable = true;\n            Object.defineProperty(obj, key, desc);\n        }\n\n        if (Object.getOwnPropertySymbols) {\n            var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n            for (var i = 0; i < objectSymbols.length; i++) {\n                var sym = objectSymbols[i];\n                var desc = descs[sym];\n                desc.configurable = desc.enumerable = true;\n                if ('value' in desc) desc.writable = true;\n                Object.defineProperty(obj, sym, desc);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defaults(obj, defaults) {\n        var keys = Object.getOwnPropertyNames(defaults);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n            if (value && value.configurable && obj[key] === undefined) {\n                Object.defineProperty(obj, key, value);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true,\n            });\n        } else {\n            obj[key] = value;\n        }\n\n        return obj;\n    }\n\n    function _extends() {\n        _extends =\n            Object.assign ||\n            function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n\n                return target;\n            };\n\n        return _extends.apply(this, arguments);\n    }\n\n    function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n            var ownKeys = Object.keys(source);\n\n            if (typeof Object.getOwnPropertySymbols === 'function') {\n                ownKeys = ownKeys.concat(\n                    Object.getOwnPropertySymbols(source).filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                    })\n                );\n            }\n\n            ownKeys.forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        }\n\n        return target;\n    }\n\n    function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n            var symbols = Object.getOwnPropertySymbols(object);\n            if (enumerableOnly)\n                symbols = symbols.filter(function(sym) {\n                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                });\n            keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n    }\n\n    function _objectSpread2(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n\n            if (i % 2) {\n                ownKeys(source, true).forEach(function(key) {\n                    _defineProperty(target, key, source[key]);\n                });\n            } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n            } else {\n                ownKeys(source).forEach(function(key) {\n                    Object.defineProperty(\n                        target,\n                        key,\n                        Object.getOwnPropertyDescriptor(source, key)\n                    );\n                });\n            }\n        }\n\n        return target;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== 'function' && superClass !== null) {\n            throw new TypeError('Super expression must either be null or a function');\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true,\n            },\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n    }\n\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf\n            ? Object.getPrototypeOf\n            : function _getPrototypeOf(o) {\n                  return o.__proto__ || Object.getPrototypeOf(o);\n              };\n        return _getPrototypeOf(o);\n    }\n\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf =\n            Object.setPrototypeOf ||\n            function _setPrototypeOf(o, p) {\n                o.__proto__ = p;\n                return o;\n            };\n\n        return _setPrototypeOf(o, p);\n    }\n\n    function isNativeReflectConstruct() {\n        if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === 'function') return true;\n\n        try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n            _construct = Reflect.construct;\n        } else {\n            _construct = function _construct(Parent, args, Class) {\n                var a = [null];\n                a.push.apply(a, args);\n                var Constructor = Function.bind.apply(Parent, a);\n                var instance = new Constructor();\n                if (Class) _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            };\n        }\n\n        return _construct.apply(null, arguments);\n    }\n\n    function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf('[native code]') !== -1;\n    }\n\n    function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n            if (Class === null || !_isNativeFunction(Class)) return Class;\n\n            if (typeof Class !== 'function') {\n                throw new TypeError('Super expression must either be null or a function');\n            }\n\n            if (typeof _cache !== 'undefined') {\n                if (_cache.has(Class)) return _cache.get(Class);\n\n                _cache.set(Class, Wrapper);\n            }\n\n            function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n            }\n\n            Wrapper.prototype = Object.create(Class.prototype, {\n                constructor: {\n                    value: Wrapper,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                },\n            });\n            return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n    }\n\n    function _instanceof(left, right) {\n        if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {\n            return !!right[Symbol.hasInstance](left);\n        } else {\n            return left instanceof right;\n        }\n    }\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule\n            ? obj\n            : {\n                  default: obj,\n              };\n    }\n\n    function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n            return obj;\n        } else {\n            var newObj = {};\n\n            if (obj != null) {\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc =\n                            Object.defineProperty && Object.getOwnPropertyDescriptor\n                                ? Object.getOwnPropertyDescriptor(obj, key)\n                                : {};\n\n                        if (desc.get || desc.set) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n            }\n\n            newObj.default = obj;\n            return newObj;\n        }\n    }\n\n    function _newArrowCheck(innerThis, boundThis) {\n        if (innerThis !== boundThis) {\n            throw new TypeError('Cannot instantiate an arrow function');\n        }\n    }\n\n    function _objectDestructuringEmpty(obj) {\n        if (obj == null) throw new TypeError('Cannot destructure undefined');\n    }\n\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n\n        return target;\n    }\n\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n            for (i = 0; i < sourceSymbolKeys.length; i++) {\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n\n        return target;\n    }\n\n    function _assertThisInitialized(self) {\n        if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n        if (call && (typeof call === 'object' || typeof call === 'function')) {\n            return call;\n        }\n\n        return _assertThisInitialized(self);\n    }\n\n    function _superPropBase(object, property) {\n        while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n\n        return object;\n    }\n\n    function _get(target, property, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.get) {\n            _get = Reflect.get;\n        } else {\n            _get = function _get(target, property, receiver) {\n                var base = _superPropBase(target, property);\n\n                if (!base) return;\n                var desc = Object.getOwnPropertyDescriptor(base, property);\n\n                if (desc.get) {\n                    return desc.get.call(receiver);\n                }\n\n                return desc.value;\n            };\n        }\n\n        return _get(target, property, receiver || target);\n    }\n\n    function set(target, property, value, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.set) {\n            set = Reflect.set;\n        } else {\n            set = function set(target, property, value, receiver) {\n                var base = _superPropBase(target, property);\n\n                var desc;\n\n                if (base) {\n                    desc = Object.getOwnPropertyDescriptor(base, property);\n\n                    if (desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    } else if (!desc.writable) {\n                        return false;\n                    }\n                }\n\n                desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n                if (desc) {\n                    if (!desc.writable) {\n                        return false;\n                    }\n\n                    desc.value = value;\n                    Object.defineProperty(receiver, property, desc);\n                } else {\n                    _defineProperty(receiver, property, value);\n                }\n\n                return true;\n            };\n        }\n\n        return set(target, property, value, receiver);\n    }\n\n    function _set(target, property, value, receiver, isStrict) {\n        var s = set(target, property, value, receiver || target);\n\n        if (!s && isStrict) {\n            throw new Error('failed to set property');\n        }\n\n        return value;\n    }\n\n    function _taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        return Object.freeze(\n            Object.defineProperties(strings, {\n                raw: {\n                    value: Object.freeze(raw),\n                },\n            })\n        );\n    }\n\n    function _taggedTemplateLiteralLoose(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        strings.raw = raw;\n        return strings;\n    }\n\n    function _temporalRef(val, name) {\n        if (val === _temporalUndefined) {\n            throw new ReferenceError(name + ' is not defined - temporal dead zone');\n        } else {\n            return val;\n        }\n    }\n\n    function _readOnlyError(name) {\n        throw new Error('\"' + name + '\" is read-only');\n    }\n\n    function _classNameTDZError(name) {\n        throw new Error('Class \"' + name + '\" cannot be referenced in computed property keys.');\n    }\n\n    var _temporalUndefined = {};\n\n    function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n    }\n\n    function _slicedToArrayLoose(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _nonIterableRest();\n    }\n\n    function _toArray(arr) {\n        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n    }\n\n    function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n            return arr2;\n        }\n    }\n\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n\n    function _iterableToArray(iter) {\n        if (\n            Symbol.iterator in Object(iter) ||\n            Object.prototype.toString.call(iter) === '[object Arguments]'\n        )\n            return Array.from(iter);\n    }\n\n    function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally {\n            try {\n                if (!_n && _i['return'] != null) _i['return']();\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n\n        return _arr;\n    }\n\n    function _iterableToArrayLimitLoose(arr, i) {\n        var _arr = [];\n\n        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {\n            _arr.push(_step.value);\n\n            if (i && _arr.length === i) break;\n        }\n\n        return _arr;\n    }\n\n    function _nonIterableSpread() {\n        throw new TypeError('Invalid attempt to spread non-iterable instance');\n    }\n\n    function _nonIterableRest() {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n\n    function _skipFirstGeneratorNext(fn) {\n        return function() {\n            var it = fn.apply(this, arguments);\n            it.next();\n            return it;\n        };\n    }\n\n    function _toPrimitive(input, hint) {\n        if (typeof input !== 'object' || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || 'default');\n            if (typeof res !== 'object') return res;\n            throw new TypeError('@@toPrimitive must return a primitive value.');\n        }\n\n        return (hint === 'string' ? String : Number)(input);\n    }\n\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, 'string');\n\n        return typeof key === 'symbol' ? key : String(key);\n    }\n\n    function _initializerWarningHelper(descriptor, context) {\n        throw new Error(\n            'Decorating class property failed. Please ensure that ' +\n                'proposal-class-properties is enabled and set to use loose mode. ' +\n                'To use proposal-class-properties in spec mode with decorators, wait for ' +\n                'the next major version of decorators in stage 2.'\n        );\n    }\n\n    function _initializerDefineProperty(target, property, descriptor, context) {\n        if (!descriptor) return;\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n\n    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key) {\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n\n        if ('value' in desc || desc.initializer) {\n            desc.writable = true;\n        }\n\n        desc = decorators\n            .slice()\n            .reverse()\n            .reduce(function(desc, decorator) {\n                return decorator(target, property, desc) || desc;\n            }, desc);\n\n        if (context && desc.initializer !== void 0) {\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0) {\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n\n    var id = 0;\n\n    function _classPrivateFieldLooseKey(name) {\n        return '__private_' + id++ + '_' + name;\n    }\n\n    function _classPrivateFieldLooseBase(receiver, privateKey) {\n        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n            throw new TypeError('attempted to use private field on non-instance');\n        }\n\n        return receiver;\n    }\n\n    function _classPrivateFieldGet(receiver, privateMap) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        if (descriptor.get) {\n            return descriptor.get.call(receiver);\n        }\n\n        return descriptor.value;\n    }\n\n    function _classPrivateFieldSet(receiver, privateMap, value) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        if (descriptor.set) {\n            descriptor.set.call(receiver, value);\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            descriptor.value = value;\n        }\n\n        return value;\n    }\n\n    function _classPrivateFieldDestructureSet(receiver, privateMap) {\n        if (!privateMap.has(receiver)) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        var descriptor = privateMap.get(receiver);\n\n        if (descriptor.set) {\n            if (!('__destrObj' in descriptor)) {\n                descriptor.__destrObj = {\n                    set value(v) {\n                        descriptor.set.call(receiver, v);\n                    },\n                };\n            }\n\n            return descriptor.__destrObj;\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            return descriptor;\n        }\n    }\n\n    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return descriptor.value;\n    }\n\n    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        if (!descriptor.writable) {\n            throw new TypeError('attempted to set read only private field');\n        }\n\n        descriptor.value = value;\n        return value;\n    }\n\n    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return method;\n    }\n\n    function _classStaticPrivateMethodSet() {\n        throw new TypeError('attempted to set read only static private field');\n    }\n\n    function _decorate(decorators, factory, superClass, mixins) {\n        var api = _getDecoratorsApi();\n\n        if (mixins) {\n            for (var i = 0; i < mixins.length; i++) {\n                api = mixins[i](api);\n            }\n        }\n\n        var r = factory(function initialize(O) {\n            api.initializeInstanceElements(O, decorated.elements);\n        }, superClass);\n        var decorated = api.decorateClass(\n            _coalesceClassElements(r.d.map(_createElementDescriptor)),\n            decorators\n        );\n        api.initializeClassElements(r.F, decorated.elements);\n        return api.runClassFinishers(r.F, decorated.finishers);\n    }\n\n    function _getDecoratorsApi() {\n        _getDecoratorsApi = function() {\n            return api;\n        };\n\n        var api = {\n            elementsDefinitionOrder: [['method'], ['field']],\n            initializeInstanceElements: function(O, elements) {\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        if (element.kind === kind && element.placement === 'own') {\n                            this.defineClassElement(O, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            initializeClassElements: function(F, elements) {\n                var proto = F.prototype;\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        var placement = element.placement;\n\n                        if (\n                            element.kind === kind &&\n                            (placement === 'static' || placement === 'prototype')\n                        ) {\n                            var receiver = placement === 'static' ? F : proto;\n                            this.defineClassElement(receiver, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            defineClassElement: function(receiver, element) {\n                var descriptor = element.descriptor;\n\n                if (element.kind === 'field') {\n                    var initializer = element.initializer;\n                    descriptor = {\n                        enumerable: descriptor.enumerable,\n                        writable: descriptor.writable,\n                        configurable: descriptor.configurable,\n                        value: initializer === void 0 ? void 0 : initializer.call(receiver),\n                    };\n                }\n\n                Object.defineProperty(receiver, element.key, descriptor);\n            },\n            decorateClass: function(elements, decorators) {\n                var newElements = [];\n                var finishers = [];\n                var placements = {\n                    static: [],\n                    prototype: [],\n                    own: [],\n                };\n                elements.forEach(function(element) {\n                    this.addElementPlacement(element, placements);\n                }, this);\n                elements.forEach(function(element) {\n                    if (!_hasDecorators(element)) return newElements.push(element);\n                    var elementFinishersExtras = this.decorateElement(element, placements);\n                    newElements.push(elementFinishersExtras.element);\n                    newElements.push.apply(newElements, elementFinishersExtras.extras);\n                    finishers.push.apply(finishers, elementFinishersExtras.finishers);\n                }, this);\n\n                if (!decorators) {\n                    return {\n                        elements: newElements,\n                        finishers: finishers,\n                    };\n                }\n\n                var result = this.decorateConstructor(newElements, decorators);\n                finishers.push.apply(finishers, result.finishers);\n                result.finishers = finishers;\n                return result;\n            },\n            addElementPlacement: function(element, placements, silent) {\n                var keys = placements[element.placement];\n\n                if (!silent && keys.indexOf(element.key) !== -1) {\n                    throw new TypeError('Duplicated element (' + element.key + ')');\n                }\n\n                keys.push(element.key);\n            },\n            decorateElement: function(element, placements) {\n                var extras = [];\n                var finishers = [];\n\n                for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n                    var keys = placements[element.placement];\n                    keys.splice(keys.indexOf(element.key), 1);\n                    var elementObject = this.fromElementDescriptor(element);\n                    var elementFinisherExtras = this.toElementFinisherExtras(\n                        (0, decorators[i])(elementObject) || elementObject\n                    );\n                    element = elementFinisherExtras.element;\n                    this.addElementPlacement(element, placements);\n\n                    if (elementFinisherExtras.finisher) {\n                        finishers.push(elementFinisherExtras.finisher);\n                    }\n\n                    var newExtras = elementFinisherExtras.extras;\n\n                    if (newExtras) {\n                        for (var j = 0; j < newExtras.length; j++) {\n                            this.addElementPlacement(newExtras[j], placements);\n                        }\n\n                        extras.push.apply(extras, newExtras);\n                    }\n                }\n\n                return {\n                    element: element,\n                    finishers: finishers,\n                    extras: extras,\n                };\n            },\n            decorateConstructor: function(elements, decorators) {\n                var finishers = [];\n\n                for (var i = decorators.length - 1; i >= 0; i--) {\n                    var obj = this.fromClassDescriptor(elements);\n                    var elementsAndFinisher = this.toClassDescriptor(\n                        (0, decorators[i])(obj) || obj\n                    );\n\n                    if (elementsAndFinisher.finisher !== undefined) {\n                        finishers.push(elementsAndFinisher.finisher);\n                    }\n\n                    if (elementsAndFinisher.elements !== undefined) {\n                        elements = elementsAndFinisher.elements;\n\n                        for (var j = 0; j < elements.length - 1; j++) {\n                            for (var k = j + 1; k < elements.length; k++) {\n                                if (\n                                    elements[j].key === elements[k].key &&\n                                    elements[j].placement === elements[k].placement\n                                ) {\n                                    throw new TypeError(\n                                        'Duplicated element (' + elements[j].key + ')'\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return {\n                    elements: elements,\n                    finishers: finishers,\n                };\n            },\n            fromElementDescriptor: function(element) {\n                var obj = {\n                    kind: element.kind,\n                    key: element.key,\n                    placement: element.placement,\n                    descriptor: element.descriptor,\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                if (element.kind === 'field') obj.initializer = element.initializer;\n                return obj;\n            },\n            toElementDescriptors: function(elementObjects) {\n                if (elementObjects === undefined) return;\n                return _toArray(elementObjects).map(function(elementObject) {\n                    var element = this.toElementDescriptor(elementObject);\n                    this.disallowProperty(elementObject, 'finisher', 'An element descriptor');\n                    this.disallowProperty(elementObject, 'extras', 'An element descriptor');\n                    return element;\n                }, this);\n            },\n            toElementDescriptor: function(elementObject) {\n                var kind = String(elementObject.kind);\n\n                if (kind !== 'method' && kind !== 'field') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .kind property must be either \"method\" or' +\n                            ' \"field\", but a decorator created an element descriptor with' +\n                            ' .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                var key = _toPropertyKey(elementObject.key);\n\n                var placement = String(elementObject.placement);\n\n                if (placement !== 'static' && placement !== 'prototype' && placement !== 'own') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .placement property must be one of \"static\",' +\n                            ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n                            ' with .placement \"' +\n                            placement +\n                            '\"'\n                    );\n                }\n\n                var descriptor = elementObject.descriptor;\n                this.disallowProperty(elementObject, 'elements', 'An element descriptor');\n                var element = {\n                    kind: kind,\n                    key: key,\n                    placement: placement,\n                    descriptor: Object.assign({}, descriptor),\n                };\n\n                if (kind !== 'field') {\n                    this.disallowProperty(elementObject, 'initializer', 'A method descriptor');\n                } else {\n                    this.disallowProperty(\n                        descriptor,\n                        'get',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'set',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'value',\n                        'The property descriptor of a field descriptor'\n                    );\n                    element.initializer = elementObject.initializer;\n                }\n\n                return element;\n            },\n            toElementFinisherExtras: function(elementObject) {\n                var element = this.toElementDescriptor(elementObject);\n\n                var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n                var extras = this.toElementDescriptors(elementObject.extras);\n                return {\n                    element: element,\n                    finisher: finisher,\n                    extras: extras,\n                };\n            },\n            fromClassDescriptor: function(elements) {\n                var obj = {\n                    kind: 'class',\n                    elements: elements.map(this.fromElementDescriptor, this),\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                return obj;\n            },\n            toClassDescriptor: function(obj) {\n                var kind = String(obj.kind);\n\n                if (kind !== 'class') {\n                    throw new TypeError(\n                        'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n                            ' created a class descriptor with .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                this.disallowProperty(obj, 'key', 'A class descriptor');\n                this.disallowProperty(obj, 'placement', 'A class descriptor');\n                this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n                this.disallowProperty(obj, 'initializer', 'A class descriptor');\n                this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n                var finisher = _optionalCallableProperty(obj, 'finisher');\n\n                var elements = this.toElementDescriptors(obj.elements);\n                return {\n                    elements: elements,\n                    finisher: finisher,\n                };\n            },\n            runClassFinishers: function(constructor, finishers) {\n                for (var i = 0; i < finishers.length; i++) {\n                    var newConstructor = (0, finishers[i])(constructor);\n\n                    if (newConstructor !== undefined) {\n                        if (typeof newConstructor !== 'function') {\n                            throw new TypeError('Finishers must return a constructor.');\n                        }\n\n                        constructor = newConstructor;\n                    }\n                }\n\n                return constructor;\n            },\n            disallowProperty: function(obj, name, objectType) {\n                if (obj[name] !== undefined) {\n                    throw new TypeError(objectType + \" can't have a .\" + name + ' property.');\n                }\n            },\n        };\n        return api;\n    }\n\n    function _createElementDescriptor(def) {\n        var key = _toPropertyKey(def.key);\n\n        var descriptor;\n\n        if (def.kind === 'method') {\n            descriptor = {\n                value: def.value,\n                writable: true,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'get') {\n            descriptor = {\n                get: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'set') {\n            descriptor = {\n                set: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'field') {\n            descriptor = {\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            };\n        }\n\n        var element = {\n            kind: def.kind === 'field' ? 'field' : 'method',\n            key: key,\n            placement: def.static ? 'static' : def.kind === 'field' ? 'own' : 'prototype',\n            descriptor: descriptor,\n        };\n        if (def.decorators) element.decorators = def.decorators;\n        if (def.kind === 'field') element.initializer = def.value;\n        return element;\n    }\n\n    function _coalesceGetterSetter(element, other) {\n        if (element.descriptor.get !== undefined) {\n            other.descriptor.get = element.descriptor.get;\n        } else {\n            other.descriptor.set = element.descriptor.set;\n        }\n    }\n\n    function _coalesceClassElements(elements) {\n        var newElements = [];\n\n        var isSameElement = function(other) {\n            return (\n                other.kind === 'method' &&\n                other.key === element.key &&\n                other.placement === element.placement\n            );\n        };\n\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var other;\n\n            if (element.kind === 'method' && (other = newElements.find(isSameElement))) {\n                if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n                    if (_hasDecorators(element) || _hasDecorators(other)) {\n                        throw new ReferenceError(\n                            'Duplicated methods (' + element.key + \") can't be decorated.\"\n                        );\n                    }\n\n                    other.descriptor = element.descriptor;\n                } else {\n                    if (_hasDecorators(element)) {\n                        if (_hasDecorators(other)) {\n                            throw new ReferenceError(\n                                \"Decorators can't be placed on different accessors with for \" +\n                                    'the same property (' +\n                                    element.key +\n                                    ').'\n                            );\n                        }\n\n                        other.decorators = element.decorators;\n                    }\n\n                    _coalesceGetterSetter(element, other);\n                }\n            } else {\n                newElements.push(element);\n            }\n        }\n\n        return newElements;\n    }\n\n    function _hasDecorators(element) {\n        return element.decorators && element.decorators.length;\n    }\n\n    function _isDataDescriptor(desc) {\n        return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n    }\n\n    function _optionalCallableProperty(obj, name) {\n        var value = obj[name];\n\n        if (value !== undefined && typeof value !== 'function') {\n            throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n        }\n\n        return value;\n    }\n\n    function _classPrivateMethodGet(receiver, privateSet, fn) {\n        if (!privateSet.has(receiver)) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        return fn;\n    }\n\n    function _classPrivateMethodSet() {\n        throw new TypeError('attempted to reassign private method');\n    }\n\n    function _wrapRegExp(re, groups) {\n        _wrapRegExp = function(re, groups) {\n            return new BabelRegExp(re, groups);\n        };\n\n        var _RegExp = _wrapNativeSuper(RegExp);\n\n        var _super = RegExp.prototype;\n\n        var _groups = new WeakMap();\n\n        function BabelRegExp(re, groups) {\n            var _this = _RegExp.call(this, re);\n\n            _groups.set(_this, groups);\n\n            return _this;\n        }\n\n        _inherits(BabelRegExp, _RegExp);\n\n        BabelRegExp.prototype.exec = function(str) {\n            var result = _super.exec.call(this, str);\n\n            if (result) result.groups = buildGroups(result, this);\n            return result;\n        };\n\n        BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n            if (typeof substitution === 'string') {\n                var groups = _groups.get(this);\n\n                return _super[Symbol.replace].call(\n                    this,\n                    str,\n                    substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n                        return '$' + groups[name];\n                    })\n                );\n            } else if (typeof substitution === 'function') {\n                var _this = this;\n\n                return _super[Symbol.replace].call(this, str, function() {\n                    var args = [];\n                    args.push.apply(args, arguments);\n\n                    if (typeof args[args.length - 1] !== 'object') {\n                        args.push(buildGroups(args, _this));\n                    }\n\n                    return substitution.apply(this, args);\n                });\n            } else {\n                return _super[Symbol.replace].call(this, str, substitution);\n            }\n        };\n\n        function buildGroups(result, re) {\n            var g = _groups.get(re);\n\n            return Object.keys(g).reduce(function(groups, name) {\n                groups[name] = result[g[name]];\n                return groups;\n            }, Object.create(null));\n        }\n\n        return _wrapRegExp.apply(this, arguments);\n    }\n\n    var arrayRemove = function arrayRemove(arr, index) {\n        return arr.splice(index, 1);\n    };\n\n    var run = function run(cb, sync) {\n        if (sync) {\n            cb();\n        } else if (document.hidden) {\n            Promise.resolve(1).then(cb);\n        } else {\n            setTimeout(cb, 0);\n        }\n    };\n\n    var on = function on() {\n        var listeners = [];\n        var off = function off(event, cb) {\n            arrayRemove(\n                listeners,\n                listeners.findIndex(function(listener) {\n                    return listener.event === event && (listener.cb === cb || !cb);\n                })\n            );\n        };\n        var _fire = function fire(event, args, sync) {\n            listeners\n                .filter(function(listener) {\n                    return listener.event === event;\n                })\n                .map(function(listener) {\n                    return listener.cb;\n                })\n                .forEach(function(cb) {\n                    return run(function() {\n                        return cb.apply(void 0, _toConsumableArray(args));\n                    }, sync);\n                });\n        };\n        return {\n            fireSync: function fireSync(event) {\n                for (\n                    var _len = arguments.length,\n                        args = new Array(_len > 1 ? _len - 1 : 0),\n                        _key = 1;\n                    _key < _len;\n                    _key++\n                ) {\n                    args[_key - 1] = arguments[_key];\n                }\n                _fire(event, args, true);\n            },\n            fire: function fire(event) {\n                for (\n                    var _len2 = arguments.length,\n                        args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n                        _key2 = 1;\n                    _key2 < _len2;\n                    _key2++\n                ) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _fire(event, args, false);\n            },\n            on: function on(event, cb) {\n                listeners.push({ event: event, cb: cb });\n            },\n            onOnce: function onOnce(event, _cb) {\n                listeners.push({\n                    event: event,\n                    cb: function cb() {\n                        off(event, _cb);\n                        _cb.apply(void 0, arguments);\n                    },\n                });\n            },\n            off: off,\n        };\n    };\n\n    var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n        src,\n        target,\n        excluded\n    ) {\n        Object.getOwnPropertyNames(src)\n            .filter(function(property) {\n                return !excluded.includes(property);\n            })\n            .forEach(function(key) {\n                return Object.defineProperty(\n                    target,\n                    key,\n                    Object.getOwnPropertyDescriptor(src, key)\n                );\n            });\n    };\n\n    var PRIVATE = [\n        'fire',\n        'process',\n        'revert',\n        'load',\n        'on',\n        'off',\n        'onOnce',\n        'retryLoad',\n        'extend',\n        'archive',\n        'archived',\n        'release',\n        'released',\n        'requestProcessing',\n        'freeze',\n    ];\n\n    var createItemAPI = function createItemAPI(item) {\n        var api = {};\n        copyObjectPropertiesToObject(item, api, PRIVATE);\n        return api;\n    };\n\n    var removeReleasedItems = function removeReleasedItems(items) {\n        items.forEach(function(item, index) {\n            if (item.released) {\n                arrayRemove(items, index);\n            }\n        });\n    };\n\n    var ItemStatus = {\n        INIT: 1,\n        IDLE: 2,\n        PROCESSING_QUEUED: 9,\n        PROCESSING: 3,\n        PROCESSING_COMPLETE: 5,\n        PROCESSING_ERROR: 6,\n        PROCESSING_REVERT_ERROR: 10,\n        LOADING: 7,\n        LOAD_ERROR: 8,\n    };\n\n    var FileOrigin = {\n        INPUT: 1,\n        LIMBO: 2,\n        LOCAL: 3,\n    };\n\n    var getNonNumeric = function getNonNumeric(str) {\n        return /[^0-9]+/.exec(str);\n    };\n\n    var getDecimalSeparator = function getDecimalSeparator() {\n        return getNonNumeric((1.1).toLocaleString())[0];\n    };\n\n    var getThousandsSeparator = function getThousandsSeparator() {\n        // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n        // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n        var decimalSeparator = getDecimalSeparator();\n        var thousandsStringWithSeparator = (1000.0).toLocaleString();\n        var thousandsStringWithoutSeparator = (1000.0).toString();\n        if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n            return getNonNumeric(thousandsStringWithSeparator)[0];\n        }\n        return decimalSeparator === '.' ? ',' : '.';\n    };\n\n    var Type = {\n        BOOLEAN: 'boolean',\n        INT: 'int',\n        NUMBER: 'number',\n        STRING: 'string',\n        ARRAY: 'array',\n        OBJECT: 'object',\n        FUNCTION: 'function',\n        ACTION: 'action',\n        SERVER_API: 'serverapi',\n        REGEX: 'regex',\n    };\n\n    // all registered filters\n    var filters = [];\n\n    // loops over matching filters and passes options to each filter, returning the mapped results\n    var applyFilterChain = function applyFilterChain(key, value, utils) {\n        return new Promise(function(resolve, reject) {\n            // find matching filters for this key\n            var matchingFilters = filters\n                .filter(function(f) {\n                    return f.key === key;\n                })\n                .map(function(f) {\n                    return f.cb;\n                });\n\n            // resolve now\n            if (matchingFilters.length === 0) {\n                resolve(value);\n                return;\n            }\n\n            // first filter to kick things of\n            var initialFilter = matchingFilters.shift();\n\n            // chain filters\n            matchingFilters\n                .reduce(\n                    // loop over promises passing value to next promise\n                    function(current, next) {\n                        return current.then(function(value) {\n                            return next(value, utils);\n                        });\n                    },\n\n                    // call initial filter, will return a promise\n                    initialFilter(value, utils)\n\n                    // all executed\n                )\n                .then(function(value) {\n                    return resolve(value);\n                })\n                .catch(function(error) {\n                    return reject(error);\n                });\n        });\n    };\n\n    var applyFilters = function applyFilters(key, value, utils) {\n        return filters\n            .filter(function(f) {\n                return f.key === key;\n            })\n            .map(function(f) {\n                return f.cb(value, utils);\n            });\n    };\n\n    // adds a new filter to the list\n    var addFilter = function addFilter(key, cb) {\n        return filters.push({ key: key, cb: cb });\n    };\n\n    var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n        return Object.assign(defaultOptions, additionalOptions);\n    };\n\n    var getOptions = function getOptions() {\n        return Object.assign({}, defaultOptions);\n    };\n\n    var setOptions = function setOptions(opts) {\n        forin(opts, function(key, value) {\n            // key does not exist, so this option cannot be set\n            if (!defaultOptions[key]) {\n                return;\n            }\n            defaultOptions[key][0] = getValueByType(\n                value,\n                defaultOptions[key][0],\n                defaultOptions[key][1]\n            );\n        });\n    };\n\n    // default options on app\n    var defaultOptions = {\n        // the id to add to the root element\n        id: [null, Type.STRING],\n\n        // input field name to use\n        name: ['filepond', Type.STRING],\n\n        // disable the field\n        disabled: [false, Type.BOOLEAN],\n\n        // classname to put on wrapper\n        className: [null, Type.STRING],\n\n        // is the field required\n        required: [false, Type.BOOLEAN],\n\n        // Allow media capture when value is set\n        captureMethod: [null, Type.STRING],\n        // - \"camera\", \"microphone\" or \"camcorder\",\n        // - Does not work with multiple on apple devices\n        // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n        // sync `acceptedFileTypes` property with `accept` attribute\n        allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n        // Feature toggles\n        allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n        allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n        allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n        allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n        allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n        allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n        allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n        allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n        allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n        allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n        // Try store file if `server` not set\n        storeAsFile: [false, Type.BOOLEAN],\n\n        // Revert mode\n        forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n        // Input requirements\n        maxFiles: [null, Type.INT], // Max number of files\n        checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n        // Where to put file\n        itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n        itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n        itemInsertInterval: [75, Type.INT],\n\n        // Drag 'n Drop related\n        dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n        dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n        dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n        ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n        // Upload related\n        instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n        maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n        allowMinimumUploadDuration: [true, Type.BOOLEAN], // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened\n\n        // Chunks\n        chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n        chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n        chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n        chunkRetryDelays: [[500, 1000, 3000], Type.ARRAY], // Amount of times to retry upload of a chunk when it fails\n\n        // The server api end points to use for uploading (see docs)\n        server: [null, Type.SERVER_API],\n\n        // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n        fileSizeBase: [1000, Type.INT],\n\n        // Labels and status messages\n        labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n        labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n        labelIdle: [\n            'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n            Type.STRING,\n        ],\n\n        labelInvalidField: ['Field contains invalid files', Type.STRING],\n        labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n        labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n        labelFileCountSingular: ['file in list', Type.STRING],\n        labelFileCountPlural: ['files in list', Type.STRING],\n        labelFileLoading: ['Loading', Type.STRING],\n        labelFileAdded: ['Added', Type.STRING], // assistive only\n        labelFileLoadError: ['Error during load', Type.STRING],\n        labelFileRemoved: ['Removed', Type.STRING], // assistive only\n        labelFileRemoveError: ['Error during remove', Type.STRING],\n        labelFileProcessing: ['Uploading', Type.STRING],\n        labelFileProcessingComplete: ['Upload complete', Type.STRING],\n        labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n        labelFileProcessingError: ['Error during upload', Type.STRING],\n        labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n        labelTapToCancel: ['tap to cancel', Type.STRING],\n        labelTapToRetry: ['tap to retry', Type.STRING],\n        labelTapToUndo: ['tap to undo', Type.STRING],\n\n        labelButtonRemoveItem: ['Remove', Type.STRING],\n        labelButtonAbortItemLoad: ['Abort', Type.STRING],\n        labelButtonRetryItemLoad: ['Retry', Type.STRING],\n        labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n        labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n        labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n        labelButtonProcessItem: ['Upload', Type.STRING],\n\n        // make sure width and height plus viewpox are even numbers so icons are nicely centered\n        iconRemove: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconProcess: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconRetry: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconUndo: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconDone: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        // event handlers\n        oninit: [null, Type.FUNCTION],\n        onwarning: [null, Type.FUNCTION],\n        onerror: [null, Type.FUNCTION],\n        onactivatefile: [null, Type.FUNCTION],\n        oninitfile: [null, Type.FUNCTION],\n        onaddfilestart: [null, Type.FUNCTION],\n        onaddfileprogress: [null, Type.FUNCTION],\n        onaddfile: [null, Type.FUNCTION],\n        onprocessfilestart: [null, Type.FUNCTION],\n        onprocessfileprogress: [null, Type.FUNCTION],\n        onprocessfileabort: [null, Type.FUNCTION],\n        onprocessfilerevert: [null, Type.FUNCTION],\n        onprocessfile: [null, Type.FUNCTION],\n        onprocessfiles: [null, Type.FUNCTION],\n        onremovefile: [null, Type.FUNCTION],\n        onpreparefile: [null, Type.FUNCTION],\n        onupdatefiles: [null, Type.FUNCTION],\n        onreorderfiles: [null, Type.FUNCTION],\n\n        // hooks\n        beforeDropFile: [null, Type.FUNCTION],\n        beforeAddFile: [null, Type.FUNCTION],\n        beforeRemoveFile: [null, Type.FUNCTION],\n        beforePrepareFile: [null, Type.FUNCTION],\n\n        // styles\n        stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n        stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n        styleItemPanelAspectRatio: [null, Type.STRING],\n        styleButtonRemoveItemPosition: ['left', Type.STRING],\n        styleButtonProcessItemPosition: ['right', Type.STRING],\n        styleLoadIndicatorPosition: ['right', Type.STRING],\n        styleProgressIndicatorPosition: ['right', Type.STRING],\n        styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n        // custom initial files array\n        files: [[], Type.ARRAY],\n\n        // show support by displaying credits\n        credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY],\n    };\n\n    var getItemByQuery = function getItemByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return items[0] || null;\n        }\n\n        // query is index\n        if (isInt(query)) {\n            return items[query] || null;\n        }\n\n        // if query is item, get the id\n        if (typeof query === 'object') {\n            query = query.id;\n        }\n\n        // assume query is a string and return item by id\n        return (\n            items.find(function(item) {\n                return item.id === query;\n            }) || null\n        );\n    };\n\n    var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(aspectRatio) {\n        if (isEmpty(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (/:/.test(aspectRatio)) {\n            var parts = aspectRatio.split(':');\n            return parts[1] / parts[0];\n        }\n        return parseFloat(aspectRatio);\n    };\n\n    var getActiveItems = function getActiveItems(items) {\n        return items.filter(function(item) {\n            return !item.archived;\n        });\n    };\n\n    var Status = {\n        EMPTY: 0,\n        IDLE: 1, // waiting\n        ERROR: 2, // a file is in error state\n        BUSY: 3, // busy processing or loading\n        READY: 4, // all files uploaded\n    };\n\n    var res = null;\n    var canUpdateFileInput = function canUpdateFileInput() {\n        if (res === null) {\n            try {\n                var dataTransfer = new DataTransfer();\n                dataTransfer.items.add(new File(['hello world'], 'This_Works.txt'));\n                var el = document.createElement('input');\n                el.setAttribute('type', 'file');\n                el.files = dataTransfer.files;\n                res = el.files.length === 1;\n            } catch (err) {\n                res = false;\n            }\n        }\n        return res;\n    };\n\n    var ITEM_ERROR = [\n        ItemStatus.LOAD_ERROR,\n        ItemStatus.PROCESSING_ERROR,\n        ItemStatus.PROCESSING_REVERT_ERROR,\n    ];\n\n    var ITEM_BUSY = [\n        ItemStatus.LOADING,\n        ItemStatus.PROCESSING,\n        ItemStatus.PROCESSING_QUEUED,\n        ItemStatus.INIT,\n    ];\n\n    var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n    var isItemInErrorState = function isItemInErrorState(item) {\n        return ITEM_ERROR.includes(item.status);\n    };\n    var isItemInBusyState = function isItemInBusyState(item) {\n        return ITEM_BUSY.includes(item.status);\n    };\n    var isItemInReadyState = function isItemInReadyState(item) {\n        return ITEM_READY.includes(item.status);\n    };\n\n    var isAsync = function isAsync(state) {\n        return (\n            isObject(state.options.server) &&\n            (isObject(state.options.server.process) || isFunction(state.options.server.process))\n        );\n    };\n\n    var queries = function queries(state) {\n        return {\n            GET_STATUS: function GET_STATUS() {\n                var items = getActiveItems(state.items);\n                var EMPTY = Status.EMPTY,\n                    ERROR = Status.ERROR,\n                    BUSY = Status.BUSY,\n                    IDLE = Status.IDLE,\n                    READY = Status.READY;\n\n                if (items.length === 0) return EMPTY;\n\n                if (items.some(isItemInErrorState)) return ERROR;\n\n                if (items.some(isItemInBusyState)) return BUSY;\n\n                if (items.some(isItemInReadyState)) return READY;\n\n                return IDLE;\n            },\n\n            GET_ITEM: function GET_ITEM(query) {\n                return getItemByQuery(state.items, query);\n            },\n\n            GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n                return getItemByQuery(getActiveItems(state.items), query);\n            },\n\n            GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n                return getActiveItems(state.items);\n            },\n\n            GET_ITEMS: function GET_ITEMS() {\n                return state.items;\n            },\n\n            GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.filename : null;\n            },\n\n            GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.fileSize : null;\n            },\n\n            GET_STYLES: function GET_STYLES() {\n                return Object.keys(state.options)\n                    .filter(function(key) {\n                        return /^style/.test(key);\n                    })\n                    .map(function(option) {\n                        return {\n                            name: option,\n                            value: state.options[option],\n                        };\n                    });\n            },\n\n            GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n                var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n                var aspectRatio = isShapeCircle\n                    ? 1\n                    : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n                return aspectRatio;\n            },\n\n            GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n                return state.options.styleItemPanelAspectRatio;\n            },\n\n            GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n                return getActiveItems(state.items).filter(function(item) {\n                    return item.status === status;\n                });\n            },\n\n            GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n                return getActiveItems(state.items).length;\n            },\n\n            SHOULD_UPDATE_FILE_INPUT: function SHOULD_UPDATE_FILE_INPUT() {\n                return state.options.storeAsFile && canUpdateFileInput() && !isAsync(state);\n            },\n\n            IS_ASYNC: function IS_ASYNC() {\n                return isAsync(state);\n            },\n        };\n    };\n\n    var hasRoomForItem = function hasRoomForItem(state) {\n        var count = getActiveItems(state.items).length;\n\n        // if cannot have multiple items, to add one item it should currently not contain items\n        if (!state.options.allowMultiple) {\n            return count === 0;\n        }\n\n        // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n        var maxFileCount = state.options.maxFiles;\n        if (maxFileCount === null) {\n            return true;\n        }\n\n        // we check if the current count is smaller than the max count, if so, another file can still be added\n        if (count < maxFileCount) {\n            return true;\n        }\n\n        // no more room for another file\n        return false;\n    };\n\n    var limit = function limit(value, min, max) {\n        return Math.max(Math.min(max, value), min);\n    };\n\n    var arrayInsert = function arrayInsert(arr, index, item) {\n        return arr.splice(index, 0, item);\n    };\n\n    var insertItem = function insertItem(items, item, index) {\n        if (isEmpty(item)) {\n            return null;\n        }\n\n        // if index is undefined, append\n        if (typeof index === 'undefined') {\n            items.push(item);\n            return item;\n        }\n\n        // limit the index to the size of the items array\n        index = limit(index, 0, items.length);\n\n        // add item to array\n        arrayInsert(items, index, item);\n\n        // expose\n        return item;\n    };\n\n    var isBase64DataURI = function isBase64DataURI(str) {\n        return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n            str\n        );\n    };\n\n    var getFilenameFromURL = function getFilenameFromURL(url) {\n        return url\n            .split('/')\n            .pop()\n            .split('?')\n            .shift();\n    };\n\n    var getExtensionFromFilename = function getExtensionFromFilename(name) {\n        return name.split('.').pop();\n    };\n\n    var guesstimateExtension = function guesstimateExtension(type) {\n        // if no extension supplied, exit here\n        if (typeof type !== 'string') {\n            return '';\n        }\n\n        // get subtype\n        var subtype = type.split('/').pop();\n\n        // is svg subtype\n        if (/svg/.test(subtype)) {\n            return 'svg';\n        }\n\n        if (/zip|compressed/.test(subtype)) {\n            return 'zip';\n        }\n\n        if (/plain/.test(subtype)) {\n            return 'txt';\n        }\n\n        if (/msword/.test(subtype)) {\n            return 'doc';\n        }\n\n        // if is valid subtype\n        if (/[a-z]+/.test(subtype)) {\n            // always use jpg extension\n            if (subtype === 'jpeg') {\n                return 'jpg';\n            }\n\n            // return subtype\n            return subtype;\n        }\n\n        return '';\n    };\n\n    var leftPad = function leftPad(value) {\n        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        return (padding + value).slice(-padding.length);\n    };\n\n    var getDateString = function getDateString() {\n        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n        return (\n            date.getFullYear() +\n            '-' +\n            leftPad(date.getMonth() + 1, '00') +\n            '-' +\n            leftPad(date.getDate(), '00') +\n            '_' +\n            leftPad(date.getHours(), '00') +\n            '-' +\n            leftPad(date.getMinutes(), '00') +\n            '-' +\n            leftPad(date.getSeconds(), '00')\n        );\n    };\n\n    var getFileFromBlob = function getFileFromBlob(blob, filename) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var extension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var file =\n            typeof type === 'string'\n                ? blob.slice(0, blob.size, type)\n                : blob.slice(0, blob.size, blob.type);\n        file.lastModifiedDate = new Date();\n\n        // copy relative path\n        if (blob._relativePath) file._relativePath = blob._relativePath;\n\n        // if blob has name property, use as filename if no filename supplied\n        if (!isString(filename)) {\n            filename = getDateString();\n        }\n\n        // if filename supplied but no extension and filename has extension\n        if (filename && extension === null && getExtensionFromFilename(filename)) {\n            file.name = filename;\n        } else {\n            extension = extension || guesstimateExtension(file.type);\n            file.name = filename + (extension ? '.' + extension : '');\n        }\n\n        return file;\n    };\n\n    var getBlobBuilder = function getBlobBuilder() {\n        return (window.BlobBuilder =\n            window.BlobBuilder ||\n            window.WebKitBlobBuilder ||\n            window.MozBlobBuilder ||\n            window.MSBlobBuilder);\n    };\n\n    var createBlob = function createBlob(arrayBuffer, mimeType) {\n        var BB = getBlobBuilder();\n\n        if (BB) {\n            var bb = new BB();\n            bb.append(arrayBuffer);\n            return bb.getBlob(mimeType);\n        }\n\n        return new Blob([arrayBuffer], {\n            type: mimeType,\n        });\n    };\n\n    var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n        byteString,\n        mimeType\n    ) {\n        var ab = new ArrayBuffer(byteString.length);\n        var ia = new Uint8Array(ab);\n\n        for (var i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n\n        return createBlob(ab, mimeType);\n    };\n\n    var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(dataURI) {\n        return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n    };\n\n    var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(dataURI) {\n        // get data part of string (remove data:image/jpeg...,)\n        var data = dataURI.split(',')[1];\n\n        // remove any whitespace as that causes InvalidCharacterError in IE\n        return data.replace(/\\s/g, '');\n    };\n\n    var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(dataURI) {\n        return atob(getBase64DataFromBase64DataURI(dataURI));\n    };\n\n    var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n        var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n        var byteString = getByteStringFromBase64DataURI(dataURI);\n\n        return getBlobFromByteStringWithMimeType(byteString, mimeType);\n    };\n\n    var getFileFromBase64DataURI = function getFileFromBase64DataURI(dataURI, filename, extension) {\n        return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n    };\n\n    var getFileNameFromHeader = function getFileNameFromHeader(header) {\n        // test if is content disposition header, if not exit\n        if (!/^content-disposition:/i.test(header)) return null;\n\n        // get filename parts\n        var matches = header\n            .split(/filename=|filename\\*=.+''/)\n            .splice(1)\n            .map(function(name) {\n                return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n            })\n            .filter(function(name) {\n                return name.length;\n            });\n\n        return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n    };\n\n    var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n        if (/content-length:/i.test(header)) {\n            var size = header.match(/[0-9]+/)[0];\n            return size ? parseInt(size, 10) : null;\n        }\n        return null;\n    };\n\n    var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n        if (/x-content-transfer-id:/i.test(header)) {\n            var id = (header.split(':')[1] || '').trim();\n            return id || null;\n        }\n        return null;\n    };\n\n    var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n        var info = {\n            source: null,\n            name: null,\n            size: null,\n        };\n\n        var rows = headers.split('\\n');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for (\n                var _iterator = rows[Symbol.iterator](), _step;\n                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n                _iteratorNormalCompletion = true\n            ) {\n                var header = _step.value;\n\n                var name = getFileNameFromHeader(header);\n                if (name) {\n                    info.name = name;\n                    continue;\n                }\n\n                var size = getFileSizeFromHeader(header);\n                if (size) {\n                    info.size = size;\n                    continue;\n                }\n\n                var source = getTranfserIdFromHeader(header);\n                if (source) {\n                    info.source = source;\n                    continue;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return info;\n    };\n\n    var createFileLoader = function createFileLoader(fetchFn) {\n        var state = {\n            source: null,\n            complete: false,\n            progress: 0,\n            size: null,\n            timestamp: null,\n            duration: 0,\n            request: null,\n        };\n\n        var getProgress = function getProgress() {\n            return state.progress;\n        };\n        var abort = function abort() {\n            if (state.request && state.request.abort) {\n                state.request.abort();\n            }\n        };\n\n        // load source\n        var load = function load() {\n            // get quick reference\n            var source = state.source;\n\n            api.fire('init', source);\n\n            // Load Files\n            if (source instanceof File) {\n                api.fire('load', source);\n            } else if (source instanceof Blob) {\n                // Load blobs, set default name to current date\n                api.fire('load', getFileFromBlob(source, source.name));\n            } else if (isBase64DataURI(source)) {\n                // Load base 64, set default name to current date\n                api.fire('load', getFileFromBase64DataURI(source));\n            } else {\n                // Deal as if is external URL, let's load it!\n                loadURL(source);\n            }\n        };\n\n        // loads a url\n        var loadURL = function loadURL(url) {\n            // is remote url and no fetch method supplied\n            if (!fetchFn) {\n                api.fire('error', {\n                    type: 'error',\n                    body: \"Can't load URL\",\n                    code: 400,\n                });\n\n                return;\n            }\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // load file\n            state.request = fetchFn(\n                url,\n                function(response) {\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // done!\n                    state.complete = true;\n\n                    // turn blob response into a file\n                    if (response instanceof Blob) {\n                        response = getFileFromBlob(\n                            response,\n                            response.name || getFilenameFromURL(url)\n                        );\n                    }\n\n                    api.fire(\n                        'load',\n                        // if has received blob, we go with blob, if no response, we return null\n                        response instanceof Blob ? response : response ? response.body : null\n                    );\n                },\n                function(error) {\n                    api.fire(\n                        'error',\n                        typeof error === 'string'\n                            ? {\n                                  type: 'error',\n                                  code: 0,\n                                  body: error,\n                              }\n                            : error\n                    );\n                },\n                function(computable, current, total) {\n                    // collected some meta data already\n                    if (total) {\n                        state.size = total;\n                    }\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // if we can't compute progress, we're not going to fire progress events\n                    if (!computable) {\n                        state.progress = null;\n                        return;\n                    }\n\n                    // update progress percentage\n                    state.progress = current / total;\n\n                    // expose\n                    api.fire('progress', state.progress);\n                },\n                function() {\n                    api.fire('abort');\n                },\n                function(response) {\n                    var fileinfo = getFileInfoFromHeaders(\n                        typeof response === 'string' ? response : response.headers\n                    );\n                    api.fire('meta', {\n                        size: state.size || fileinfo.size,\n                        filename: fileinfo.name,\n                        source: fileinfo.source,\n                    });\n                }\n            );\n        };\n\n        var api = Object.assign({}, on(), {\n            setSource: function setSource(source) {\n                return (state.source = source);\n            },\n            getProgress: getProgress, // file load progress\n            abort: abort, // abort file load\n            load: load, // start load\n        });\n\n        return api;\n    };\n\n    var isGet = function isGet(method) {\n        return /GET|HEAD/.test(method);\n    };\n\n    var sendRequest = function sendRequest(data, url, options) {\n        var api = {\n            onheaders: function onheaders() {},\n            onprogress: function onprogress() {},\n            onload: function onload() {},\n            ontimeout: function ontimeout() {},\n            onerror: function onerror() {},\n            onabort: function onabort() {},\n            abort: function abort() {\n                aborted = true;\n                xhr.abort();\n            },\n        };\n\n        // timeout identifier, only used when timeout is defined\n        var aborted = false;\n        var headersReceived = false;\n\n        // set default options\n        options = Object.assign(\n            {\n                method: 'POST',\n                headers: {},\n                withCredentials: false,\n            },\n            options\n        );\n\n        // encode url\n        url = encodeURI(url);\n\n        // if method is GET, add any received data to url\n\n        if (isGet(options.method) && data) {\n            url =\n                '' +\n                url +\n                encodeURIComponent(typeof data === 'string' ? data : JSON.stringify(data));\n        }\n\n        // create request\n        var xhr = new XMLHttpRequest();\n\n        // progress of load\n        var process = isGet(options.method) ? xhr : xhr.upload;\n        process.onprogress = function(e) {\n            // no progress event when aborted ( onprogress is called once after abort() )\n            if (aborted) {\n                return;\n            }\n\n            api.onprogress(e.lengthComputable, e.loaded, e.total);\n        };\n\n        // tries to get header info to the app as fast as possible\n        xhr.onreadystatechange = function() {\n            // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n            if (xhr.readyState < 2) {\n                return;\n            }\n\n            // no server response\n            if (xhr.readyState === 4 && xhr.status === 0) {\n                return;\n            }\n\n            if (headersReceived) {\n                return;\n            }\n\n            headersReceived = true;\n\n            // we've probably received some useful data in response headers\n            api.onheaders(xhr);\n        };\n\n        // load successful\n        xhr.onload = function() {\n            // is classified as valid response\n            if (xhr.status >= 200 && xhr.status < 300) {\n                api.onload(xhr);\n            } else {\n                api.onerror(xhr);\n            }\n        };\n\n        // error during load\n        xhr.onerror = function() {\n            return api.onerror(xhr);\n        };\n\n        // request aborted\n        xhr.onabort = function() {\n            aborted = true;\n            api.onabort();\n        };\n\n        // request timeout\n        xhr.ontimeout = function() {\n            return api.ontimeout(xhr);\n        };\n\n        // open up open up!\n        xhr.open(options.method, url, true);\n\n        // set timeout if defined (do it after open so IE11 plays ball)\n        if (isInt(options.timeout)) {\n            xhr.timeout = options.timeout;\n        }\n\n        // add headers\n        Object.keys(options.headers).forEach(function(key) {\n            var value = unescape(encodeURIComponent(options.headers[key]));\n            xhr.setRequestHeader(key, value);\n        });\n\n        // set type of response\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n\n        // set credentials\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        // let's send our data\n        xhr.send(data);\n\n        return api;\n    };\n\n    var createResponse = function createResponse(type, code, body, headers) {\n        return {\n            type: type,\n            code: code,\n            body: body,\n            headers: headers,\n        };\n    };\n\n    var createTimeoutResponse = function createTimeoutResponse(cb) {\n        return function(xhr) {\n            cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n        };\n    };\n\n    var hasQS = function hasQS(str) {\n        return /\\?/.test(str);\n    };\n    var buildURL = function buildURL() {\n        var url = '';\n        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n            parts[_key] = arguments[_key];\n        }\n        parts.forEach(function(part) {\n            url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n        });\n        return url;\n    };\n\n    var createFetchFunction = function createFetchFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied\n        if (!action || !isString(action.url)) {\n            return null;\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal handler\n        return function(url, load, error, progress, abort, headers) {\n            // do local or remote request based on if the url is external\n            var request = sendRequest(\n                url,\n                buildURL(apiUrl, action.url),\n                Object.assign({}, action, {\n                    responseType: 'blob',\n                })\n            );\n\n            request.onload = function(xhr) {\n                // get headers\n                var headers = xhr.getAllResponseHeaders();\n\n                // get filename\n                var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n                // create response\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        action.method === 'HEAD'\n                            ? null\n                            : getFileFromBlob(onload(xhr.response), filename),\n                        headers\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onheaders = function(xhr) {\n                headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var ChunkStatus = {\n        QUEUED: 0,\n        COMPLETE: 1,\n        PROCESSING: 2,\n        ERROR: 3,\n        WAITING: 4,\n    };\n\n    /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n    // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n    var processFileChunked = function processFileChunked(\n        apiUrl,\n        action,\n        name,\n        file,\n        metadata,\n        load,\n        error,\n        progress,\n        abort,\n        transfer,\n        options\n    ) {\n        // all chunks\n        var chunks = [];\n        var chunkTransferId = options.chunkTransferId,\n            chunkServer = options.chunkServer,\n            chunkSize = options.chunkSize,\n            chunkRetryDelays = options.chunkRetryDelays;\n\n        // default state\n        var state = {\n            serverId: chunkTransferId,\n            aborted: false,\n        };\n\n        // set onload handlers\n        var ondata =\n            action.ondata ||\n            function(fd) {\n                return fd;\n            };\n        var onload =\n            action.onload ||\n            function(xhr, method) {\n                return method === 'HEAD' ? xhr.getResponseHeader('Upload-Offset') : xhr.response;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // create server hook\n        var requestTransferId = function requestTransferId(cb) {\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata)\n                    : Object.assign({}, action.headers, {\n                          'Upload-Length': file.size,\n                      });\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        var requestTransferOffset = function requestTransferOffset(cb) {\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(state.serverId)\n                    : Object.assign({}, action.headers);\n\n            var requestParams = {\n                headers: headers,\n                method: 'HEAD',\n            };\n\n            var request = sendRequest(null, requestUrl, requestParams);\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        // create chunks\n        var lastChunkIndex = Math.floor(file.size / chunkSize);\n        for (var i = 0; i <= lastChunkIndex; i++) {\n            var offset = i * chunkSize;\n            var data = file.slice(offset, offset + chunkSize, 'application/offset+octet-stream');\n            chunks[i] = {\n                index: i,\n                size: data.size,\n                offset: offset,\n                data: data,\n                file: file,\n                progress: 0,\n                retries: _toConsumableArray(chunkRetryDelays),\n                status: ChunkStatus.QUEUED,\n                error: null,\n                request: null,\n                timeout: null,\n            };\n        }\n\n        var completeProcessingChunks = function completeProcessingChunks() {\n            return load(state.serverId);\n        };\n\n        var canProcessChunk = function canProcessChunk(chunk) {\n            return chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n        };\n\n        var processChunk = function processChunk(chunk) {\n            // processing is paused, wait here\n            if (state.aborted) return;\n\n            // get next chunk to process\n            chunk = chunk || chunks.find(canProcessChunk);\n\n            // no more chunks to process\n            if (!chunk) {\n                // all done?\n                if (\n                    chunks.every(function(chunk) {\n                        return chunk.status === ChunkStatus.COMPLETE;\n                    })\n                ) {\n                    completeProcessingChunks();\n                }\n\n                // no chunk to handle\n                return;\n            }\n\n            // now processing this chunk\n            chunk.status = ChunkStatus.PROCESSING;\n            chunk.progress = null;\n\n            // allow parsing of formdata\n            var ondata =\n                chunkServer.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onerror =\n                chunkServer.onerror ||\n                function(res) {\n                    return null;\n                };\n\n            // send request object\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof chunkServer.headers === 'function'\n                    ? chunkServer.headers(chunk)\n                    : Object.assign({}, chunkServer.headers, {\n                          'Content-Type': 'application/offset+octet-stream',\n                          'Upload-Offset': chunk.offset,\n                          'Upload-Length': file.size,\n                          'Upload-Name': file.name,\n                      });\n\n            var request = (chunk.request = sendRequest(\n                ondata(chunk.data),\n                requestUrl,\n                Object.assign({}, chunkServer, {\n                    headers: headers,\n                })\n            ));\n\n            request.onload = function() {\n                // done!\n                chunk.status = ChunkStatus.COMPLETE;\n\n                // remove request reference\n                chunk.request = null;\n\n                // start processing more chunks\n                processChunks();\n            };\n\n            request.onprogress = function(lengthComputable, loaded, total) {\n                chunk.progress = lengthComputable ? loaded : null;\n                updateTotalProgress();\n            };\n\n            request.onerror = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                chunk.error = onerror(xhr.response) || xhr.statusText;\n                if (!retryProcessChunk(chunk)) {\n                    error(\n                        createResponse(\n                            'error',\n                            xhr.status,\n                            onerror(xhr.response) || xhr.statusText,\n                            xhr.getAllResponseHeaders()\n                        )\n                    );\n                }\n            };\n\n            request.ontimeout = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                if (!retryProcessChunk(chunk)) {\n                    createTimeoutResponse(error)(xhr);\n                }\n            };\n\n            request.onabort = function() {\n                chunk.status = ChunkStatus.QUEUED;\n                chunk.request = null;\n                abort();\n            };\n        };\n\n        var retryProcessChunk = function retryProcessChunk(chunk) {\n            // no more retries left\n            if (chunk.retries.length === 0) return false;\n\n            // new retry\n            chunk.status = ChunkStatus.WAITING;\n            clearTimeout(chunk.timeout);\n            chunk.timeout = setTimeout(function() {\n                processChunk(chunk);\n            }, chunk.retries.shift());\n\n            // we're going to retry\n            return true;\n        };\n\n        var updateTotalProgress = function updateTotalProgress() {\n            // calculate total progress fraction\n            var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n                if (p === null || chunk.progress === null) return null;\n                return p + chunk.progress;\n            }, 0);\n\n            // can't compute progress\n            if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n            // calculate progress values\n            var totalSize = chunks.reduce(function(total, chunk) {\n                return total + chunk.size;\n            }, 0);\n\n            // can update progress indicator\n            progress(true, totalBytesTransfered, totalSize);\n        };\n\n        // process new chunks\n        var processChunks = function processChunks() {\n            var totalProcessing = chunks.filter(function(chunk) {\n                return chunk.status === ChunkStatus.PROCESSING;\n            }).length;\n            if (totalProcessing >= 1) return;\n            processChunk();\n        };\n\n        var abortChunks = function abortChunks() {\n            chunks.forEach(function(chunk) {\n                clearTimeout(chunk.timeout);\n                if (chunk.request) {\n                    chunk.request.abort();\n                }\n            });\n        };\n\n        // let's go!\n        if (!state.serverId) {\n            requestTransferId(function(serverId) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // pass back to item so we can use it if something goes wrong\n                transfer(serverId);\n\n                // store internally\n                state.serverId = serverId;\n                processChunks();\n            });\n        } else {\n            requestTransferOffset(function(offset) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // mark chunks with lower offset as complete\n                chunks\n                    .filter(function(chunk) {\n                        return chunk.offset < offset;\n                    })\n                    .forEach(function(chunk) {\n                        chunk.status = ChunkStatus.COMPLETE;\n                        chunk.progress = chunk.size;\n                    });\n\n                // continue processing\n                processChunks();\n            });\n        }\n\n        return {\n            abort: function abort() {\n                state.aborted = true;\n                abortChunks();\n            },\n        };\n    };\n\n    /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n    var createFileProcessorFunction = function createFileProcessorFunction(\n        apiUrl,\n        action,\n        name,\n        options\n    ) {\n        return function(file, metadata, load, error, progress, abort, transfer) {\n            // no file received\n            if (!file) return;\n\n            // if was passed a file, and we can chunk it, exit here\n            var canChunkUpload = options.chunkUploads;\n            var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n            var willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n            if (file instanceof Blob && willChunkUpload)\n                return processFileChunked(\n                    apiUrl,\n                    action,\n                    name,\n                    file,\n                    metadata,\n                    load,\n                    error,\n                    progress,\n                    abort,\n                    transfer,\n                    options\n                );\n\n            // set handlers\n            var ondata =\n                action.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onload =\n                action.onload ||\n                function(res) {\n                    return res;\n                };\n            var onerror =\n                action.onerror ||\n                function(res) {\n                    return null;\n                };\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata) || {}\n                    : Object.assign(\n                          {},\n\n                          action.headers\n                      );\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // create formdata object\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) {\n                formData.append(name, JSON.stringify(metadata));\n            }\n\n            // Turn into an array of objects so no matter what the input, we can handle it the same way\n            (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(function(item) {\n                formData.append(\n                    name,\n                    item.file,\n                    item.name === null ? item.file.name : '' + item.name + item.file.name\n                );\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var createProcessorFunction = function createProcessorFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        var name = arguments.length > 2 ? arguments[2] : undefined;\n        var options = arguments.length > 3 ? arguments[3] : undefined;\n\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function')\n            return function() {\n                for (\n                    var _len = arguments.length, params = new Array(_len), _key = 0;\n                    _key < _len;\n                    _key++\n                ) {\n                    params[_key] = arguments[_key];\n                }\n                return action.apply(void 0, [name].concat(params, [options]));\n            };\n\n        // no action supplied\n        if (!action || !isString(action.url)) return null;\n\n        // internal handler\n        return createFileProcessorFunction(apiUrl, action, name, options);\n    };\n\n    /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n    var createRevertFunction = function createRevertFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // is custom implementation\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied, return stub function, interface will work, but file won't be removed\n        if (!action || !isString(action.url)) {\n            return function(uniqueFileId, load) {\n                return load();\n            };\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal implementation\n        return function(uniqueFileId, load, error) {\n            var request = sendRequest(\n                uniqueFileId,\n                apiUrl + action.url,\n                action // contains method, headers and withCredentials properties\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n\n            return request;\n        };\n    };\n\n    var getRandomNumber = function getRandomNumber() {\n        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        return min + Math.random() * (max - min);\n    };\n\n    var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(cb) {\n        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var tickMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n        var tickMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n        var timeout = null;\n        var start = Date.now();\n\n        var tick = function tick() {\n            var runtime = Date.now() - start;\n            var delay = getRandomNumber(tickMin, tickMax);\n\n            if (runtime + delay > duration) {\n                delay = runtime + delay - duration;\n            }\n\n            var progress = runtime / duration;\n            if (progress >= 1 || document.hidden) {\n                cb(1);\n                return;\n            }\n\n            cb(progress);\n\n            timeout = setTimeout(tick, delay);\n        };\n\n        if (duration > 0) tick();\n\n        return {\n            clear: function clear() {\n                clearTimeout(timeout);\n            },\n        };\n    };\n\n    var createFileProcessor = function createFileProcessor(processFn, options) {\n        var state = {\n            complete: false,\n            perceivedProgress: 0,\n            perceivedPerformanceUpdater: null,\n            progress: null,\n            timestamp: null,\n            perceivedDuration: 0,\n            duration: 0,\n            request: null,\n            response: null,\n        };\n        var allowMinimumUploadDuration = options.allowMinimumUploadDuration;\n\n        var process = function process(file, metadata) {\n            var progressFn = function progressFn() {\n                // we've not yet started the real download, stop here\n                // the request might not go through, for instance, there might be some server trouble\n                // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n                if (state.duration === 0 || state.progress === null) return;\n\n                // as we're now processing, fire the progress event\n                api.fire('progress', api.getProgress());\n            };\n\n            var completeFn = function completeFn() {\n                state.complete = true;\n                api.fire('load-perceived', state.response.body);\n            };\n\n            // let's start processing\n            api.fire('start');\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // create perceived performance progress indicator\n            state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n                function(progress) {\n                    state.perceivedProgress = progress;\n                    state.perceivedDuration = Date.now() - state.timestamp;\n\n                    progressFn();\n\n                    // if fake progress is done, and a response has been received,\n                    // and we've not yet called the complete method\n                    if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                        // we done!\n                        completeFn();\n                    }\n                },\n                // random delay as in a list of files you start noticing\n                // files uploading at the exact same speed\n                allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0\n            );\n\n            // remember request so we can abort it later\n            state.request = processFn(\n                // the file to process\n                file,\n\n                // the metadata to send along\n                metadata,\n\n                // callbacks (load, error, progress, abort, transfer)\n                // load expects the body to be a server id if\n                // you want to make use of revert\n                function(response) {\n                    // we put the response in state so we can access\n                    // it outside of this method\n                    state.response = isObject(response)\n                        ? response\n                        : {\n                              type: 'load',\n                              code: 200,\n                              body: '' + response,\n                              headers: {},\n                          };\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // force progress to 1 as we're now done\n                    state.progress = 1;\n\n                    // actual load is done let's share results\n                    api.fire('load', state.response.body);\n\n                    // we are really done\n                    // if perceived progress is 1 ( wait for perceived progress to complete )\n                    // or if server does not support progress ( null )\n                    if (\n                        !allowMinimumUploadDuration ||\n                        (allowMinimumUploadDuration && state.perceivedProgress === 1)\n                    ) {\n                        completeFn();\n                    }\n                },\n\n                // error is expected to be an object with type, code, body\n                function(error) {\n                    // cancel updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // update others about this error\n                    api.fire(\n                        'error',\n                        isObject(error)\n                            ? error\n                            : {\n                                  type: 'error',\n                                  code: 0,\n                                  body: '' + error,\n                              }\n                    );\n                },\n\n                // actual processing progress\n                function(computable, current, total) {\n                    // update actual duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // update actual progress\n                    state.progress = computable ? current / total : null;\n\n                    progressFn();\n                },\n\n                // abort does not expect a value\n                function() {\n                    // stop updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // fire the abort event so we can switch visuals\n                    api.fire('abort', state.response ? state.response.body : null);\n                },\n\n                // register the id for this transfer\n                function(transferId) {\n                    api.fire('transfer', transferId);\n                }\n            );\n        };\n\n        var abort = function abort() {\n            // no request running, can't abort\n            if (!state.request) return;\n\n            // stop updater\n            state.perceivedPerformanceUpdater.clear();\n\n            // abort actual request\n            if (state.request.abort) state.request.abort();\n\n            // if has response object, we've completed the request\n            state.complete = true;\n        };\n\n        var reset = function reset() {\n            abort();\n            state.complete = false;\n            state.perceivedProgress = 0;\n            state.progress = 0;\n            state.timestamp = null;\n            state.perceivedDuration = 0;\n            state.duration = 0;\n            state.request = null;\n            state.response = null;\n        };\n\n        var getProgress = allowMinimumUploadDuration\n            ? function() {\n                  return state.progress ? Math.min(state.progress, state.perceivedProgress) : null;\n              }\n            : function() {\n                  return state.progress || null;\n              };\n\n        var getDuration = allowMinimumUploadDuration\n            ? function() {\n                  return Math.min(state.duration, state.perceivedDuration);\n              }\n            : function() {\n                  return state.duration;\n              };\n\n        var api = Object.assign({}, on(), {\n            process: process, // start processing file\n            abort: abort, // abort active process request\n            getProgress: getProgress,\n            getDuration: getDuration,\n            reset: reset,\n        });\n\n        return api;\n    };\n\n    var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n        return name.substr(0, name.lastIndexOf('.')) || name;\n    };\n\n    var createFileStub = function createFileStub(source) {\n        var data = [source.name, source.size, source.type];\n\n        // is blob or base64, then we need to set the name\n        if (source instanceof Blob || isBase64DataURI(source)) {\n            data[0] = source.name || getDateString();\n        } else if (isBase64DataURI(source)) {\n            // if is base64 data uri we need to determine the average size and type\n            data[1] = source.length;\n            data[2] = getMimeTypeFromBase64DataURI(source);\n        } else if (isString(source)) {\n            // url\n            data[0] = getFilenameFromURL(source);\n            data[1] = 0;\n            data[2] = 'application/octet-stream';\n        }\n\n        return {\n            name: data[0],\n            size: data[1],\n            type: data[2],\n        };\n    };\n\n    var isFile = function isFile(value) {\n        return !!(value instanceof File || (value instanceof Blob && value.name));\n    };\n\n    var deepCloneObject = function deepCloneObject(src) {\n        if (!isObject(src)) return src;\n        var target = isArray(src) ? [] : {};\n        for (var key in src) {\n            if (!src.hasOwnProperty(key)) continue;\n            var v = src[key];\n            target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n        }\n        return target;\n    };\n\n    var createItem = function createItem() {\n        var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var serverFileReference =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        // unique id for this item, is used to identify the item across views\n        var id = getUniqueId();\n\n        /**\n         * Internal item state\n         */\n        var state = {\n            // is archived\n            archived: false,\n\n            // if is frozen, no longer fires events\n            frozen: false,\n\n            // removed from view\n            released: false,\n\n            // original source\n            source: null,\n\n            // file model reference\n            file: file,\n\n            // id of file on server\n            serverFileReference: serverFileReference,\n\n            // id of file transfer on server\n            transferId: null,\n\n            // is aborted\n            processingAborted: false,\n\n            // current item status\n            status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n\n            // active processes\n            activeLoader: null,\n            activeProcessor: null,\n        };\n\n        // callback used when abort processing is called to link back to the resolve method\n        var abortProcessingRequestComplete = null;\n\n        /**\n         * Externally added item metadata\n         */\n        var metadata = {};\n\n        // item data\n        var setStatus = function setStatus(status) {\n            return (state.status = status);\n        };\n\n        // fire event unless the item has been archived\n        var fire = function fire(event) {\n            if (state.released || state.frozen) return;\n            for (\n                var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                params[_key - 1] = arguments[_key];\n            }\n            api.fire.apply(api, [event].concat(params));\n        };\n\n        // file data\n        var getFileExtension = function getFileExtension() {\n            return getExtensionFromFilename(state.file.name);\n        };\n        var getFileType = function getFileType() {\n            return state.file.type;\n        };\n        var getFileSize = function getFileSize() {\n            return state.file.size;\n        };\n        var getFile = function getFile() {\n            return state.file;\n        };\n\n        //\n        // logic to load a file\n        //\n        var load = function load(source, loader, onload) {\n            // remember the original item source\n            state.source = source;\n\n            // source is known\n            api.fireSync('init');\n\n            // file stub is already there\n            if (state.file) {\n                api.fireSync('load-skip');\n                return;\n            }\n\n            // set a stub file object while loading the actual data\n            state.file = createFileStub(source);\n\n            // starts loading\n            loader.on('init', function() {\n                fire('load-init');\n            });\n\n            // we'eve received a size indication, let's update the stub\n            loader.on('meta', function(meta) {\n                // set size of file stub\n                state.file.size = meta.size;\n\n                // set name of file stub\n                state.file.filename = meta.filename;\n\n                // if has received source, we done\n                if (meta.source) {\n                    origin = FileOrigin.LIMBO;\n                    state.serverFileReference = meta.source;\n                    state.status = ItemStatus.PROCESSING_COMPLETE;\n                }\n\n                // size has been updated\n                fire('load-meta');\n            });\n\n            // the file is now loading we need to update the progress indicators\n            loader.on('progress', function(progress) {\n                setStatus(ItemStatus.LOADING);\n\n                fire('load-progress', progress);\n            });\n\n            // an error was thrown while loading the file, we need to switch to error state\n            loader.on('error', function(error) {\n                setStatus(ItemStatus.LOAD_ERROR);\n\n                fire('load-request-error', error);\n            });\n\n            // user or another process aborted the file load (cannot retry)\n            loader.on('abort', function() {\n                setStatus(ItemStatus.INIT);\n                fire('load-abort');\n            });\n\n            // done loading\n            loader.on('load', function(file) {\n                // as we've now loaded the file the loader is no longer required\n                state.activeLoader = null;\n\n                // called when file has loaded succesfully\n                var success = function success(result) {\n                    // set (possibly) transformed file\n                    state.file = isFile(result) ? result : state.file;\n\n                    // file received\n                    if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                        setStatus(ItemStatus.PROCESSING_COMPLETE);\n                    } else {\n                        setStatus(ItemStatus.IDLE);\n                    }\n\n                    fire('load');\n                };\n\n                var error = function error(result) {\n                    // set original file\n                    state.file = file;\n                    fire('load-meta');\n\n                    setStatus(ItemStatus.LOAD_ERROR);\n                    fire('load-file-error', result);\n                };\n\n                // if we already have a server file reference, we don't need to call the onload method\n                if (state.serverFileReference) {\n                    success(file);\n                    return;\n                }\n\n                // no server id, let's give this file the full treatment\n                onload(file, success, error);\n            });\n\n            // set loader source data\n            loader.setSource(source);\n\n            // set as active loader\n            state.activeLoader = loader;\n\n            // load the source data\n            loader.load();\n        };\n\n        var retryLoad = function retryLoad() {\n            if (!state.activeLoader) {\n                return;\n            }\n            state.activeLoader.load();\n        };\n\n        var abortLoad = function abortLoad() {\n            if (state.activeLoader) {\n                state.activeLoader.abort();\n                return;\n            }\n            setStatus(ItemStatus.INIT);\n            fire('load-abort');\n        };\n\n        //\n        // logic to process a file\n        //\n        var process = function process(processor, onprocess) {\n            // processing was aborted\n            if (state.processingAborted) {\n                state.processingAborted = false;\n                return;\n            }\n\n            // now processing\n            setStatus(ItemStatus.PROCESSING);\n\n            // reset abort callback\n            abortProcessingRequestComplete = null;\n\n            // if no file loaded we'll wait for the load event\n            if (!(state.file instanceof Blob)) {\n                api.on('load', function() {\n                    process(processor, onprocess);\n                });\n                return;\n            }\n\n            // setup processor\n            processor.on('load', function(serverFileReference) {\n                // need this id to be able to revert the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n            });\n\n            // register transfer id\n            processor.on('transfer', function(transferId) {\n                // need this id to be able to revert the upload\n                state.transferId = transferId;\n            });\n\n            processor.on('load-perceived', function(serverFileReference) {\n                // no longer required\n                state.activeProcessor = null;\n\n                // need this id to be able to rever the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.PROCESSING_COMPLETE);\n                fire('process-complete', serverFileReference);\n            });\n\n            processor.on('start', function() {\n                fire('process-start');\n            });\n\n            processor.on('error', function(error) {\n                state.activeProcessor = null;\n                setStatus(ItemStatus.PROCESSING_ERROR);\n                fire('process-error', error);\n            });\n\n            processor.on('abort', function(serverFileReference) {\n                state.activeProcessor = null;\n\n                // if file was uploaded but processing was cancelled during perceived processor time store file reference\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.IDLE);\n                fire('process-abort');\n\n                // has timeout so doesn't interfere with remove action\n                if (abortProcessingRequestComplete) {\n                    abortProcessingRequestComplete();\n                }\n            });\n\n            processor.on('progress', function(progress) {\n                fire('process-progress', progress);\n            });\n\n            // when successfully transformed\n            var success = function success(file) {\n                // if was archived in the mean time, don't process\n                if (state.archived) return;\n\n                // process file!\n                processor.process(file, Object.assign({}, metadata));\n            };\n\n            // something went wrong during transform phase\n            var error = console.error;\n\n            // start processing the file\n            onprocess(state.file, success, error);\n\n            // set as active processor\n            state.activeProcessor = processor;\n        };\n\n        var requestProcessing = function requestProcessing() {\n            state.processingAborted = false;\n            setStatus(ItemStatus.PROCESSING_QUEUED);\n        };\n\n        var abortProcessing = function abortProcessing() {\n            return new Promise(function(resolve) {\n                if (!state.activeProcessor) {\n                    state.processingAborted = true;\n\n                    setStatus(ItemStatus.IDLE);\n                    fire('process-abort');\n\n                    resolve();\n                    return;\n                }\n\n                abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n                    resolve();\n                };\n\n                state.activeProcessor.abort();\n            });\n        };\n\n        //\n        // logic to revert a processed file\n        //\n        var revert = function revert(revertFileUpload, forceRevert) {\n            return new Promise(function(resolve, reject) {\n                // a completed upload will have a serverFileReference, a failed chunked upload where\n                // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n                var serverTransferId =\n                    state.serverFileReference !== null\n                        ? state.serverFileReference\n                        : state.transferId;\n\n                // cannot revert without a server id for this process\n                if (serverTransferId === null) {\n                    resolve();\n                    return;\n                }\n\n                // revert the upload (fire and forget)\n                revertFileUpload(\n                    serverTransferId,\n                    function() {\n                        // reset file server id and transfer id as now it's not available on the server\n                        state.serverFileReference = null;\n                        state.transferId = null;\n                        resolve();\n                    },\n                    function(error) {\n                        // don't set error state when reverting is optional, it will always resolve\n                        if (!forceRevert) {\n                            resolve();\n                            return;\n                        }\n\n                        // oh no errors\n                        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                        fire('process-revert-error');\n                        reject(error);\n                    }\n                );\n\n                // fire event\n                setStatus(ItemStatus.IDLE);\n                fire('process-revert');\n            });\n        };\n\n        // exposed methods\n        var _setMetadata = function setMetadata(key, value, silent) {\n            var keys = key.split('.');\n            var root = keys[0];\n            var last = keys.pop();\n            var data = metadata;\n            keys.forEach(function(key) {\n                return (data = data[key]);\n            });\n\n            // compare old value against new value, if they're the same, we're not updating\n            if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n            // update value\n            data[last] = value;\n\n            // fire update\n            fire('metadata-update', {\n                key: root,\n                value: metadata[root],\n                silent: silent,\n            });\n        };\n\n        var getMetadata = function getMetadata(key) {\n            return deepCloneObject(key ? metadata[key] : metadata);\n        };\n\n        var api = Object.assign(\n            {\n                id: {\n                    get: function get() {\n                        return id;\n                    },\n                },\n                origin: {\n                    get: function get() {\n                        return origin;\n                    },\n                    set: function set(value) {\n                        return (origin = value);\n                    },\n                },\n                serverId: {\n                    get: function get() {\n                        return state.serverFileReference;\n                    },\n                },\n                transferId: {\n                    get: function get() {\n                        return state.transferId;\n                    },\n                },\n                status: {\n                    get: function get() {\n                        return state.status;\n                    },\n                },\n                filename: {\n                    get: function get() {\n                        return state.file.name;\n                    },\n                },\n                filenameWithoutExtension: {\n                    get: function get() {\n                        return getFilenameWithoutExtension(state.file.name);\n                    },\n                },\n                fileExtension: { get: getFileExtension },\n                fileType: { get: getFileType },\n                fileSize: { get: getFileSize },\n                file: { get: getFile },\n                relativePath: {\n                    get: function get() {\n                        return state.file._relativePath;\n                    },\n                },\n\n                source: {\n                    get: function get() {\n                        return state.source;\n                    },\n                },\n\n                getMetadata: getMetadata,\n                setMetadata: function setMetadata(key, value, silent) {\n                    if (isObject(key)) {\n                        var data = key;\n                        Object.keys(data).forEach(function(key) {\n                            _setMetadata(key, data[key], value);\n                        });\n                        return key;\n                    }\n                    _setMetadata(key, value, silent);\n                    return value;\n                },\n\n                extend: function extend(name, handler) {\n                    return (itemAPI[name] = handler);\n                },\n\n                abortLoad: abortLoad,\n                retryLoad: retryLoad,\n                requestProcessing: requestProcessing,\n                abortProcessing: abortProcessing,\n\n                load: load,\n                process: process,\n                revert: revert,\n            },\n\n            on(),\n            {\n                freeze: function freeze() {\n                    return (state.frozen = true);\n                },\n\n                release: function release() {\n                    return (state.released = true);\n                },\n                released: {\n                    get: function get() {\n                        return state.released;\n                    },\n                },\n\n                archive: function archive() {\n                    return (state.archived = true);\n                },\n                archived: {\n                    get: function get() {\n                        return state.archived;\n                    },\n                },\n            }\n        );\n\n        // create it here instead of returning it instantly so we can extend it later\n        var itemAPI = createObject(api);\n\n        return itemAPI;\n    };\n\n    var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return 0;\n        }\n\n        // invalid queries\n        if (!isString(query)) {\n            return -1;\n        }\n\n        // return item by id (or -1 if not found)\n        return items.findIndex(function(item) {\n            return item.id === query;\n        });\n    };\n\n    var getItemById = function getItemById(items, itemId) {\n        var index = getItemIndexByQuery(items, itemId);\n        if (index < 0) {\n            return;\n        }\n        return items[index] || null;\n    };\n\n    var fetchBlob = function fetchBlob(url, load, error, progress, abort, headers) {\n        var request = sendRequest(null, url, {\n            method: 'GET',\n            responseType: 'blob',\n        });\n\n        request.onload = function(xhr) {\n            // get headers\n            var headers = xhr.getAllResponseHeaders();\n\n            // get filename\n            var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n            // create response\n            load(\n                createResponse('load', xhr.status, getFileFromBlob(xhr.response, filename), headers)\n            );\n        };\n\n        request.onerror = function(xhr) {\n            error(createResponse('error', xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n\n        request.onheaders = function(xhr) {\n            headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n\n        // should return request\n        return request;\n    };\n\n    var getDomainFromURL = function getDomainFromURL(url) {\n        if (url.indexOf('//') === 0) {\n            url = location.protocol + url;\n        }\n        return url\n            .toLowerCase()\n            .replace('blob:', '')\n            .replace(/([a-z])?:\\/\\//, '$1')\n            .split('/')[0];\n    };\n\n    var isExternalURL = function isExternalURL(url) {\n        return (\n            (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n            getDomainFromURL(location.href) !== getDomainFromURL(url)\n        );\n    };\n\n    var dynamicLabel = function dynamicLabel(label) {\n        return function() {\n            return isFunction(label) ? label.apply(void 0, arguments) : label;\n        };\n    };\n\n    var isMockItem = function isMockItem(item) {\n        return !isFile(item.file);\n    };\n\n    var listUpdated = function listUpdated(dispatch, state) {\n        clearTimeout(state.listUpdateTimeout);\n        state.listUpdateTimeout = setTimeout(function() {\n            dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n        }, 0);\n    };\n\n    var optionalPromise = function optionalPromise(fn) {\n        for (\n            var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n            _key < _len;\n            _key++\n        ) {\n            params[_key - 1] = arguments[_key];\n        }\n        return new Promise(function(resolve) {\n            if (!fn) {\n                return resolve(true);\n            }\n\n            var result = fn.apply(void 0, params);\n\n            if (result == null) {\n                return resolve(true);\n            }\n\n            if (typeof result === 'boolean') {\n                return resolve(result);\n            }\n\n            if (typeof result.then === 'function') {\n                result.then(resolve);\n            }\n        });\n    };\n\n    var sortItems = function sortItems(state, compare) {\n        state.items.sort(function(a, b) {\n            return compare(createItemAPI(a), createItemAPI(b));\n        });\n    };\n\n    // returns item based on state\n    var getItemByQueryFromState = function getItemByQueryFromState(state, itemHandler) {\n        return function() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var query = _ref.query,\n                _ref$success = _ref.success,\n                success = _ref$success === void 0 ? function() {} : _ref$success,\n                _ref$failure = _ref.failure,\n                failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n                options = _objectWithoutProperties(_ref, ['query', 'success', 'failure']);\n            var item = getItemByQuery(state.items, query);\n            if (!item) {\n                failure({\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                });\n\n                return;\n            }\n            itemHandler(item, success, failure, options || {});\n        };\n    };\n\n    var actions = function actions(dispatch, query, state) {\n        return {\n            /**\n             * Aborts all ongoing processes\n             */\n            ABORT_ALL: function ABORT_ALL() {\n                getActiveItems(state.items).forEach(function(item) {\n                    item.freeze();\n                    item.abortLoad();\n                    item.abortProcessing();\n                });\n            },\n\n            /**\n             * Sets initial files\n             */\n            DID_SET_FILES: function DID_SET_FILES(_ref2) {\n                var _ref2$value = _ref2.value,\n                    value = _ref2$value === void 0 ? [] : _ref2$value;\n                // map values to file objects\n                var files = value.map(function(file) {\n                    return {\n                        source: file.source ? file.source : file,\n                        options: file.options,\n                    };\n                });\n\n                // loop over files, if file is in list, leave it be, if not, remove\n                // test if items should be moved\n                var activeItems = getActiveItems(state.items);\n\n                activeItems.forEach(function(item) {\n                    // if item not is in new value, remove\n                    if (\n                        !files.find(function(file) {\n                            return file.source === item.source || file.source === item.file;\n                        })\n                    ) {\n                        dispatch('REMOVE_ITEM', { query: item, remove: false });\n                    }\n                });\n\n                // add new files\n                activeItems = getActiveItems(state.items);\n                files.forEach(function(file, index) {\n                    // if file is already in list\n                    if (\n                        activeItems.find(function(item) {\n                            return item.source === file.source || item.file === file.source;\n                        })\n                    )\n                        return;\n\n                    // not in list, add\n                    dispatch(\n                        'ADD_ITEM',\n                        Object.assign({}, file, {\n                            interactionMethod: InteractionMethod.NONE,\n                            index: index,\n                        })\n                    );\n                });\n            },\n\n            DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n                var id = _ref3.id,\n                    action = _ref3.action,\n                    change = _ref3.change;\n                // don't do anything\n                if (change.silent) return;\n\n                // if is called multiple times in close succession we combined all calls together to save resources\n                clearTimeout(state.itemUpdateTimeout);\n                state.itemUpdateTimeout = setTimeout(function() {\n                    var item = getItemById(state.items, id);\n\n                    // only revert and attempt to upload when we're uploading to a server\n                    if (!query('IS_ASYNC')) {\n                        // should we update the output data\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                            action: action,\n                            change: change,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            if (!shouldPrepareOutput) return;\n\n                            dispatch(\n                                'REQUEST_PREPARE_OUTPUT',\n                                {\n                                    query: id,\n                                    item: item,\n                                    success: function success(file) {\n                                        dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                    },\n                                },\n\n                                true\n                            );\n                        });\n\n                        return;\n                    }\n\n                    // if is local item we need to enable upload button so change can be propagated to server\n                    if (item.origin === FileOrigin.LOCAL) {\n                        dispatch('DID_LOAD_ITEM', {\n                            id: item.id,\n                            error: null,\n                            serverFileReference: item.source,\n                        });\n                    }\n\n                    // for async scenarios\n                    var upload = function upload() {\n                        // we push this forward a bit so the interface is updated correctly\n                        setTimeout(function() {\n                            dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n                        }, 32);\n                    };\n\n                    var revert = function revert(doUpload) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(doUpload ? upload : function() {})\n                            .catch(function() {});\n                    };\n\n                    var abort = function abort(doUpload) {\n                        item.abortProcessing().then(doUpload ? upload : function() {});\n                    };\n\n                    // if we should re-upload the file immediately\n                    if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                        return revert(state.options.instantUpload);\n                    }\n\n                    // if currently uploading, cancel upload\n                    if (item.status === ItemStatus.PROCESSING) {\n                        return abort(state.options.instantUpload);\n                    }\n\n                    if (state.options.instantUpload) {\n                        upload();\n                    }\n                }, 0);\n            },\n\n            MOVE_ITEM: function MOVE_ITEM(_ref4) {\n                var query = _ref4.query,\n                    index = _ref4.index;\n                var item = getItemByQuery(state.items, query);\n                if (!item) return;\n                var currentIndex = state.items.indexOf(item);\n                index = limit(index, 0, state.items.length - 1);\n                if (currentIndex === index) return;\n                state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n            },\n\n            SORT: function SORT(_ref5) {\n                var compare = _ref5.compare;\n                sortItems(state, compare);\n                dispatch('DID_SORT_ITEMS', {\n                    items: query('GET_ACTIVE_ITEMS'),\n                });\n            },\n\n            ADD_ITEMS: function ADD_ITEMS(_ref6) {\n                var items = _ref6.items,\n                    index = _ref6.index,\n                    interactionMethod = _ref6.interactionMethod,\n                    _ref6$success = _ref6.success,\n                    success = _ref6$success === void 0 ? function() {} : _ref6$success,\n                    _ref6$failure = _ref6.failure,\n                    failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n                var currentIndex = index;\n\n                if (index === -1 || typeof index === 'undefined') {\n                    var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n                    var totalItems = query('GET_TOTAL_ITEMS');\n                    currentIndex = insertLocation === 'before' ? 0 : totalItems;\n                }\n\n                var ignoredFiles = query('GET_IGNORED_FILES');\n                var isValidFile = function isValidFile(source) {\n                    return isFile(source)\n                        ? !ignoredFiles.includes(source.name.toLowerCase())\n                        : !isEmpty(source);\n                };\n                var validItems = items.filter(isValidFile);\n\n                var promises = validItems.map(function(source) {\n                    return new Promise(function(resolve, reject) {\n                        dispatch('ADD_ITEM', {\n                            interactionMethod: interactionMethod,\n                            source: source.source || source,\n                            success: resolve,\n                            failure: reject,\n                            index: currentIndex++,\n                            options: source.options || {},\n                        });\n                    });\n                });\n\n                Promise.all(promises)\n                    .then(success)\n                    .catch(failure);\n            },\n\n            /**\n             * @param source\n             * @param index\n             * @param interactionMethod\n             */\n            ADD_ITEM: function ADD_ITEM(_ref7) {\n                var source = _ref7.source,\n                    _ref7$index = _ref7.index,\n                    index = _ref7$index === void 0 ? -1 : _ref7$index,\n                    interactionMethod = _ref7.interactionMethod,\n                    _ref7$success = _ref7.success,\n                    success = _ref7$success === void 0 ? function() {} : _ref7$success,\n                    _ref7$failure = _ref7.failure,\n                    failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n                    _ref7$options = _ref7.options,\n                    options = _ref7$options === void 0 ? {} : _ref7$options;\n                // if no source supplied\n                if (isEmpty(source)) {\n                    failure({\n                        error: createResponse('error', 0, 'No source'),\n                        file: null,\n                    });\n\n                    return;\n                }\n\n                // filter out invalid file items, used to filter dropped directory contents\n                if (\n                    isFile(source) &&\n                    state.options.ignoredFiles.includes(source.name.toLowerCase())\n                ) {\n                    // fail silently\n                    return;\n                }\n\n                // test if there's still room in the list of files\n                if (!hasRoomForItem(state)) {\n                    // if multiple allowed, we can't replace\n                    // or if only a single item is allowed but we're not allowed to replace it we exit\n                    if (\n                        state.options.allowMultiple ||\n                        (!state.options.allowMultiple && !state.options.allowReplace)\n                    ) {\n                        var error = createResponse('warning', 0, 'Max files');\n\n                        dispatch('DID_THROW_MAX_FILES', {\n                            source: source,\n                            error: error,\n                        });\n\n                        failure({ error: error, file: null });\n\n                        return;\n                    }\n\n                    // let's replace the item\n                    // id of first item we're about to remove\n                    var _item = getActiveItems(state.items)[0];\n\n                    // if has been processed remove it from the server as well\n                    if (\n                        _item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        var forceRevert = query('GET_FORCE_REVERT');\n                        _item\n                            .revert(\n                                createRevertFunction(\n                                    state.options.server.url,\n                                    state.options.server.revert\n                                ),\n                                forceRevert\n                            )\n                            .then(function() {\n                                if (!forceRevert) return;\n\n                                // try to add now\n                                dispatch('ADD_ITEM', {\n                                    source: source,\n                                    index: index,\n                                    interactionMethod: interactionMethod,\n                                    success: success,\n                                    failure: failure,\n                                    options: options,\n                                });\n                            })\n                            .catch(function() {}); // no need to handle this catch state for now\n\n                        if (forceRevert) return;\n                    }\n\n                    // remove first item as it will be replaced by this item\n                    dispatch('REMOVE_ITEM', { query: _item.id });\n                }\n\n                // where did the file originate\n                var origin =\n                    options.type === 'local'\n                        ? FileOrigin.LOCAL\n                        : options.type === 'limbo'\n                        ? FileOrigin.LIMBO\n                        : FileOrigin.INPUT;\n\n                // create a new blank item\n                var item = createItem(\n                    // where did this file come from\n                    origin,\n\n                    // an input file never has a server file reference\n                    origin === FileOrigin.INPUT ? null : source,\n\n                    // file mock data, if defined\n                    options.file\n                );\n\n                // set initial meta data\n                Object.keys(options.metadata || {}).forEach(function(key) {\n                    item.setMetadata(key, options.metadata[key]);\n                });\n\n                // created the item, let plugins add methods\n                applyFilters('DID_CREATE_ITEM', item, { query: query, dispatch: dispatch });\n\n                // where to insert new items\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n                // adjust index if is not allowed to pick location\n                if (!state.options.itemInsertLocationFreedom) {\n                    index = itemInsertLocation === 'before' ? -1 : state.items.length;\n                }\n\n                // add item to list\n                insertItem(state.items, item, index);\n\n                // sort items in list\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // get a quick reference to the item id\n                var id = item.id;\n\n                // observe item events\n                item.on('init', function() {\n                    dispatch('DID_INIT_ITEM', { id: id });\n                });\n\n                item.on('load-init', function() {\n                    dispatch('DID_START_ITEM_LOAD', { id: id });\n                });\n\n                item.on('load-meta', function() {\n                    dispatch('DID_UPDATE_ITEM_META', { id: id });\n                });\n\n                item.on('load-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('load-request-error', function(error) {\n                    var mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n\n                    // is client error, no way to recover\n                    if (error.code >= 400 && error.code < 500) {\n                        dispatch('DID_THROW_ITEM_INVALID', {\n                            id: id,\n                            error: error,\n                            status: {\n                                main: mainStatus,\n                                sub: error.code + ' (' + error.body + ')',\n                            },\n                        });\n\n                        // reject the file so can be dealt with through API\n                        failure({ error: error, file: createItemAPI(item) });\n                        return;\n                    }\n\n                    // is possible server error, so might be possible to retry\n                    dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: mainStatus,\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('load-file-error', function(error) {\n                    dispatch('DID_THROW_ITEM_INVALID', {\n                        id: id,\n                        error: error.status,\n                        status: error.status,\n                    });\n\n                    failure({ error: error.status, file: createItemAPI(item) });\n                });\n\n                item.on('load-abort', function() {\n                    dispatch('REMOVE_ITEM', { query: id });\n                });\n\n                item.on('load-skip', function() {\n                    dispatch('COMPLETE_LOAD_ITEM', {\n                        query: id,\n                        item: item,\n                        data: {\n                            source: source,\n                            success: success,\n                        },\n                    });\n                });\n\n                item.on('load', function() {\n                    var handleAdd = function handleAdd(shouldAdd) {\n                        // no should not add this file\n                        if (!shouldAdd) {\n                            dispatch('REMOVE_ITEM', {\n                                query: id,\n                            });\n\n                            return;\n                        }\n\n                        // now interested in metadata updates\n                        item.on('metadata-update', function(change) {\n                            dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n                        });\n\n                        // let plugins decide if the output data should be prepared at this point\n                        // means we'll do this and wait for idle state\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            var loadComplete = function loadComplete() {\n                                dispatch('COMPLETE_LOAD_ITEM', {\n                                    query: id,\n                                    item: item,\n                                    data: {\n                                        source: source,\n                                        success: success,\n                                    },\n                                });\n\n                                listUpdated(dispatch, state);\n                            };\n\n                            // exit\n                            if (shouldPrepareOutput) {\n                                // wait for idle state and then run PREPARE_OUTPUT\n                                dispatch(\n                                    'REQUEST_PREPARE_OUTPUT',\n                                    {\n                                        query: id,\n                                        item: item,\n                                        success: function success(file) {\n                                            dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                            loadComplete();\n                                        },\n                                    },\n\n                                    true\n                                );\n\n                                return;\n                            }\n\n                            loadComplete();\n                        });\n                    };\n\n                    // item loaded, allow plugins to\n                    // - read data (quickly)\n                    // - add metadata\n                    applyFilterChain('DID_LOAD_ITEM', item, { query: query, dispatch: dispatch })\n                        .then(function() {\n                            optionalPromise(query('GET_BEFORE_ADD_FILE'), createItemAPI(item)).then(\n                                handleAdd\n                            );\n                        })\n                        .catch(function(e) {\n                            if (!e || !e.error || !e.status) return handleAdd(false);\n                            dispatch('DID_THROW_ITEM_INVALID', {\n                                id: id,\n                                error: e.error,\n                                status: e.status,\n                            });\n                        });\n                });\n\n                item.on('process-start', function() {\n                    dispatch('DID_START_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('process-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-revert-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-complete', function(serverFileReference) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: id,\n                        error: null,\n                        serverFileReference: serverFileReference,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n                });\n\n                item.on('process-abort', function() {\n                    dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-revert', function() {\n                    dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n                });\n\n                // let view know the item has been inserted\n                dispatch('DID_ADD_ITEM', {\n                    id: id,\n                    index: index,\n                    interactionMethod: interactionMethod,\n                });\n\n                listUpdated(dispatch, state);\n\n                // start loading the source\n                var _ref8 = state.options.server || {},\n                    url = _ref8.url,\n                    load = _ref8.load,\n                    restore = _ref8.restore,\n                    fetch = _ref8.fetch;\n\n                item.load(\n                    source,\n\n                    // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n                    createFileLoader(\n                        origin === FileOrigin.INPUT\n                            ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                              isString(source) && isExternalURL(source)\n                                ? fetch\n                                    ? createFetchFunction(url, fetch)\n                                    : fetchBlob // remote url\n                                : fetchBlob // try to fetch url\n                            : // limbo or local\n                            origin === FileOrigin.LIMBO\n                            ? createFetchFunction(url, restore) // limbo\n                            : createFetchFunction(url, load) // local\n                    ),\n\n                    // called when the file is loaded so it can be piped through the filters\n                    function(file, success, error) {\n                        // let's process the file\n                        applyFilterChain('LOAD_FILE', file, { query: query })\n                            .then(success)\n                            .catch(error);\n                    }\n                );\n            },\n\n            REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n                var item = _ref9.item,\n                    success = _ref9.success,\n                    _ref9$failure = _ref9.failure,\n                    failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n                // error response if item archived\n                var err = {\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                };\n\n                // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n                if (item.archived) return failure(err);\n\n                // allow plugins to alter the file data\n                applyFilterChain('PREPARE_OUTPUT', item.file, { query: query, item: item }).then(\n                    function(result) {\n                        applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n                            query: query,\n                            item: item,\n                        }).then(function(result) {\n                            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                            if (item.archived) return failure(err);\n\n                            // we done!\n                            success(result);\n                        });\n                    }\n                );\n            },\n\n            COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n                var item = _ref10.item,\n                    data = _ref10.data;\n                var success = data.success,\n                    source = data.source;\n\n                // sort items in list\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // let interface know the item has loaded\n                dispatch('DID_LOAD_ITEM', {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: item.origin === FileOrigin.INPUT ? null : source,\n                });\n\n                // item has been successfully loaded and added to the\n                // list of items so can now be safely returned for use\n                success(createItemAPI(item));\n\n                // if this is a local server file we need to show a different state\n                if (item.origin === FileOrigin.LOCAL) {\n                    dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n                    return;\n                }\n\n                // if is a temp server file we prevent async upload call here (as the file is already on the server)\n                if (item.origin === FileOrigin.LIMBO) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: item.id,\n                        error: null,\n                        serverFileReference: source,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', {\n                        id: item.id,\n                        value: item.serverId || source,\n                    });\n\n                    return;\n                }\n\n                // id we are allowed to upload the file immediately, lets do it\n                if (query('IS_ASYNC') && state.options.instantUpload) {\n                    dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n                }\n            },\n\n            RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                // try loading the source one more time\n                item.retryLoad();\n            }),\n\n            REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(item, _success, failure) {\n                dispatch(\n                    'REQUEST_PREPARE_OUTPUT',\n                    {\n                        query: item.id,\n                        item: item,\n                        success: function success(file) {\n                            dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n                            _success({\n                                file: item,\n                                output: file,\n                            });\n                        },\n                        failure: failure,\n                    },\n\n                    true\n                );\n            }),\n\n            REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n                item,\n                success,\n                failure\n            ) {\n                // cannot be queued (or is already queued)\n                var itemCanBeQueuedForProcessing =\n                    // waiting for something\n                    item.status === ItemStatus.IDLE ||\n                    // processing went wrong earlier\n                    item.status === ItemStatus.PROCESSING_ERROR;\n\n                // not ready to be processed\n                if (!itemCanBeQueuedForProcessing) {\n                    var processNow = function processNow() {\n                        return dispatch('REQUEST_ITEM_PROCESSING', {\n                            query: item,\n                            success: success,\n                            failure: failure,\n                        });\n                    };\n\n                    var process = function process() {\n                        return document.hidden ? processNow() : setTimeout(processNow, 32);\n                    };\n\n                    // if already done processing or tried to revert but didn't work, try again\n                    if (\n                        item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(process)\n                            .catch(function() {}); // don't continue with processing if something went wrong\n                    } else if (item.status === ItemStatus.PROCESSING) {\n                        item.abortProcessing().then(process);\n                    }\n\n                    return;\n                }\n\n                // already queued for processing\n                if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n                item.requestProcessing();\n\n                dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n                dispatch('PROCESS_ITEM', { query: item, success: success, failure: failure }, true);\n            }),\n\n            PROCESS_ITEM: getItemByQueryFromState(state, function(item, success, failure) {\n                var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n                var totalCurrentUploads = query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING)\n                    .length;\n\n                // queue and wait till queue is freed up\n                if (totalCurrentUploads === maxParallelUploads) {\n                    // queue for later processing\n                    state.processingQueue.push({\n                        id: item.id,\n                        success: success,\n                        failure: failure,\n                    });\n\n                    // stop it!\n                    return;\n                }\n\n                // if was not queued or is already processing exit here\n                if (item.status === ItemStatus.PROCESSING) return;\n\n                var processNext = function processNext() {\n                    // process queueud items\n                    var queueEntry = state.processingQueue.shift();\n\n                    // no items left\n                    if (!queueEntry) return;\n\n                    // get item reference\n                    var id = queueEntry.id,\n                        success = queueEntry.success,\n                        failure = queueEntry.failure;\n                    var itemReference = getItemByQuery(state.items, id);\n\n                    // if item was archived while in queue, jump to next\n                    if (!itemReference || itemReference.archived) {\n                        processNext();\n                        return;\n                    }\n\n                    // process queued item\n                    dispatch(\n                        'PROCESS_ITEM',\n                        { query: id, success: success, failure: failure },\n                        true\n                    );\n                };\n\n                // we done function\n                item.onOnce('process-complete', function() {\n                    success(createItemAPI(item));\n                    processNext();\n\n                    // if origin is local, and we're instant uploading, trigger remove of original\n                    // as revert will remove file from list\n                    var server = state.options.server;\n                    var instantUpload = state.options.instantUpload;\n                    if (\n                        instantUpload &&\n                        item.origin === FileOrigin.LOCAL &&\n                        isFunction(server.remove)\n                    ) {\n                        var noop = function noop() {};\n                        item.origin = FileOrigin.LIMBO;\n                        state.options.server.remove(item.source, noop, noop);\n                    }\n\n                    // All items processed? No errors?\n                    var allItemsProcessed =\n                        query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE).length ===\n                        state.items.length;\n                    if (allItemsProcessed) {\n                        dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n                    }\n                });\n\n                // we error function\n                item.onOnce('process-error', function(error) {\n                    failure({ error: error, file: createItemAPI(item) });\n                    processNext();\n                });\n\n                // start file processing\n                var options = state.options;\n                item.process(\n                    createFileProcessor(\n                        createProcessorFunction(\n                            options.server.url,\n                            options.server.process,\n                            options.name,\n                            {\n                                chunkTransferId: item.transferId,\n                                chunkServer: options.server.patch,\n                                chunkUploads: options.chunkUploads,\n                                chunkForce: options.chunkForce,\n                                chunkSize: options.chunkSize,\n                                chunkRetryDelays: options.chunkRetryDelays,\n                            }\n                        ),\n\n                        {\n                            allowMinimumUploadDuration: query('GET_ALLOW_MINIMUM_UPLOAD_DURATION'),\n                        }\n                    ),\n\n                    // called when the file is about to be processed so it can be piped through the transform filters\n                    function(file, success, error) {\n                        // allow plugins to alter the file data\n                        applyFilterChain('PREPARE_OUTPUT', file, { query: query, item: item })\n                            .then(function(file) {\n                                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                                success(file);\n                            })\n                            .catch(error);\n                    }\n                );\n            }),\n\n            RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n            }),\n\n            REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n                optionalPromise(query('GET_BEFORE_REMOVE_FILE'), createItemAPI(item)).then(function(\n                    shouldRemove\n                ) {\n                    if (!shouldRemove) {\n                        return;\n                    }\n                    dispatch('REMOVE_ITEM', { query: item });\n                });\n            }),\n\n            RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n                item.release();\n            }),\n\n            REMOVE_ITEM: getItemByQueryFromState(state, function(item, success, failure, options) {\n                var removeFromView = function removeFromView() {\n                    // get id reference\n                    var id = item.id;\n\n                    // archive the item, this does not remove it from the list\n                    getItemById(state.items, id).archive();\n\n                    // tell the view the item has been removed\n                    dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n                    // now the list has been modified\n                    listUpdated(dispatch, state);\n\n                    // correctly removed\n                    success(createItemAPI(item));\n                };\n\n                // if this is a local file and the `server.remove` function has been configured,\n                // send source there so dev can remove file from server\n                var server = state.options.server;\n                if (\n                    item.origin === FileOrigin.LOCAL &&\n                    server &&\n                    isFunction(server.remove) &&\n                    options.remove !== false\n                ) {\n                    dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n                    server.remove(\n                        item.source,\n                        function() {\n                            return removeFromView();\n                        },\n                        function(status) {\n                            dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                                id: item.id,\n                                error: createResponse('error', 0, status, null),\n                                status: {\n                                    main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                                    sub: state.options.labelTapToRetry,\n                                },\n                            });\n                        }\n                    );\n                } else {\n                    // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n                    if (\n                        (options.revert &&\n                            item.origin !== FileOrigin.LOCAL &&\n                            item.serverId !== null) ||\n                        // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                        // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                        // revert before removing from the view...\n                        (state.options.chunkUploads && item.file.size > state.options.chunkSize) ||\n                        (state.options.chunkUploads && state.options.chunkForce)\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        );\n                    }\n\n                    // can now safely remove from view\n                    removeFromView();\n                }\n            }),\n\n            ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                item.abortLoad();\n            }),\n\n            ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // test if is already processed\n                if (item.serverId) {\n                    dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n                    return;\n                }\n\n                // abort\n                item.abortProcessing().then(function() {\n                    var shouldRemove = state.options.instantUpload;\n                    if (shouldRemove) {\n                        dispatch('REMOVE_ITEM', { query: item.id });\n                    }\n                });\n            }),\n\n            REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // not instant uploading, revert immediately\n                if (!state.options.instantUpload) {\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                    return;\n                }\n\n                // if we're instant uploading the file will also be removed if we revert,\n                // so if a before remove file hook is defined we need to run it now\n                var handleRevert = function handleRevert(shouldRevert) {\n                    if (!shouldRevert) return;\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                };\n\n                var fn = query('GET_BEFORE_REMOVE_FILE');\n                if (!fn) {\n                    return handleRevert(true);\n                }\n\n                var requestRemoveResult = fn(createItemAPI(item));\n                if (requestRemoveResult == null) {\n                    // undefined or null\n                    return handleRevert(true);\n                }\n\n                if (typeof requestRemoveResult === 'boolean') {\n                    return handleRevert(requestRemoveResult);\n                }\n\n                if (typeof requestRemoveResult.then === 'function') {\n                    requestRemoveResult.then(handleRevert);\n                }\n            }),\n\n            REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                )\n                    .then(function() {\n                        var shouldRemove = state.options.instantUpload || isMockItem(item);\n                        if (shouldRemove) {\n                            dispatch('REMOVE_ITEM', { query: item.id });\n                        }\n                    })\n                    .catch(function() {});\n            }),\n\n            SET_OPTIONS: function SET_OPTIONS(_ref11) {\n                var options = _ref11.options;\n                forin(options, function(key, value) {\n                    dispatch('SET_' + fromCamels(key, '_').toUpperCase(), { value: value });\n                });\n            },\n        };\n    };\n\n    var formatFilename = function formatFilename(name) {\n        return name;\n    };\n\n    var createElement$1 = function createElement(tagName) {\n        return document.createElement(tagName);\n    };\n\n    var text = function text(node, value) {\n        var textNode = node.childNodes[0];\n        if (!textNode) {\n            textNode = document.createTextNode(value);\n            node.appendChild(textNode);\n        } else if (value !== textNode.nodeValue) {\n            textNode.nodeValue = value;\n        }\n    };\n\n    var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n        return {\n            x: centerX + radius * Math.cos(angleInRadians),\n            y: centerY + radius * Math.sin(angleInRadians),\n        };\n    };\n\n    var describeArc = function describeArc(x, y, radius, startAngle, endAngle, arcSweep) {\n        var start = polarToCartesian(x, y, radius, endAngle);\n        var end = polarToCartesian(x, y, radius, startAngle);\n        return ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');\n    };\n\n    var percentageArc = function percentageArc(x, y, radius, from, to) {\n        var arcSweep = 1;\n        if (to > from && to - from <= 0.5) {\n            arcSweep = 0;\n        }\n        if (from > to && from - to >= 0.5) {\n            arcSweep = 0;\n        }\n        return describeArc(\n            x,\n            y,\n            radius,\n            Math.min(0.9999, from) * 360,\n            Math.min(0.9999, to) * 360,\n            arcSweep\n        );\n    };\n\n    var create = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // start at 0\n        props.spin = false;\n        props.progress = 0;\n        props.opacity = 0;\n\n        // svg\n        var svg = createElement('svg');\n        root.ref.path = createElement('path', {\n            'stroke-width': 2,\n            'stroke-linecap': 'round',\n        });\n\n        svg.appendChild(root.ref.path);\n\n        root.ref.svg = svg;\n\n        root.appendChild(svg);\n    };\n\n    var write = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        if (props.opacity === 0) {\n            return;\n        }\n\n        if (props.align) {\n            root.element.dataset.align = props.align;\n        }\n\n        // get width of stroke\n        var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n        // calculate size of ring\n        var size = root.rect.element.width * 0.5;\n\n        // ring state\n        var ringFrom = 0;\n        var ringTo = 0;\n\n        // now in busy mode\n        if (props.spin) {\n            ringFrom = 0;\n            ringTo = 0.5;\n        } else {\n            ringFrom = 0;\n            ringTo = props.progress;\n        }\n\n        // get arc path\n        var coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n\n        // update progress bar\n        attr(root.ref.path, 'd', coordinates);\n\n        // hide while contains 0 value\n        attr(root.ref.path, 'stroke-opacity', props.spin || props.progress > 0 ? 1 : 0);\n    };\n\n    var progressIndicator = createView({\n        tag: 'div',\n        name: 'progress-indicator',\n        ignoreRectUpdate: true,\n        ignoreRect: true,\n        create: create,\n        write: write,\n        mixins: {\n            apis: ['progress', 'spin', 'align'],\n            styles: ['opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 500 },\n                progress: {\n                    type: 'spring',\n                    stiffness: 0.95,\n                    damping: 0.65,\n                    mass: 10,\n                },\n            },\n        },\n    });\n\n    var create$1 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.innerHTML = (props.icon || '') + ('<span>' + props.label + '</span>');\n\n        props.isDisabled = false;\n    };\n\n    var write$1 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        var isDisabled = props.isDisabled;\n        var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n        if (shouldDisable && !isDisabled) {\n            props.isDisabled = true;\n            attr(root.element, 'disabled', 'disabled');\n        } else if (!shouldDisable && isDisabled) {\n            props.isDisabled = false;\n            root.element.removeAttribute('disabled');\n        }\n    };\n\n    var fileActionButton = createView({\n        tag: 'button',\n        attributes: {\n            type: 'button',\n        },\n\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'file-action-button',\n        mixins: {\n            apis: ['label'],\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n\n            listeners: true,\n        },\n\n        create: create$1,\n        write: write$1,\n    });\n\n    var toNaturalFileSize = function toNaturalFileSize(bytes) {\n        var decimalSeparator =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n        // no negative byte sizes\n        bytes = Math.round(Math.abs(bytes));\n\n        var KB = base;\n        var MB = base * base;\n        var GB = base * base * base;\n\n        // just bytes\n        if (bytes < KB) {\n            return bytes + ' bytes';\n        }\n\n        // kilobytes\n        if (bytes < MB) {\n            return Math.floor(bytes / KB) + ' KB';\n        }\n\n        // megabytes\n        if (bytes < GB) {\n            return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';\n        }\n\n        // gigabytes\n        return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';\n    };\n\n    var removeDecimalsWhenZero = function removeDecimalsWhenZero(value, decimalCount, separator) {\n        return value\n            .toFixed(decimalCount)\n            .split('.')\n            .filter(function(part) {\n                return part !== '0';\n            })\n            .join(separator);\n    };\n\n    var create$2 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // filename\n        var fileName = createElement$1('span');\n        fileName.className = 'filepond--file-info-main';\n        // hide for screenreaders\n        // the file is contained in a fieldset with legend that contains the filename\n        // no need to read it twice\n        attr(fileName, 'aria-hidden', 'true');\n        root.appendChild(fileName);\n        root.ref.fileName = fileName;\n\n        // filesize\n        var fileSize = createElement$1('span');\n        fileSize.className = 'filepond--file-info-sub';\n        root.appendChild(fileSize);\n        root.ref.fileSize = fileSize;\n\n        // set initial values\n        text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n        text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFile = function updateFile(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        text(\n            root.ref.fileSize,\n            toNaturalFileSize(\n                root.query('GET_ITEM_SIZE', props.id),\n                '.',\n                root.query('GET_FILE_SIZE_BASE')\n            )\n        );\n\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props;\n        // if size is available don't fallback to unknown size message\n        if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n            updateFile({ root: root, props: props });\n            return;\n        }\n\n        text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n    };\n\n    var fileInfo = createView({\n        name: 'file-info',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: updateFile,\n            DID_UPDATE_ITEM_META: updateFile,\n            DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n            DID_THROW_ITEM_INVALID: updateFileSizeOnError,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$2,\n        mixins: {\n            styles: ['translateX', 'translateY'],\n            animations: {\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var toPercentage = function toPercentage(value) {\n        return Math.round(value * 100);\n    };\n\n    var create$3 = function create(_ref) {\n        var root = _ref.root;\n\n        // main status\n        var main = createElement$1('span');\n        main.className = 'filepond--file-status-main';\n        root.appendChild(main);\n        root.ref.main = main;\n\n        // sub status\n        var sub = createElement$1('span');\n        sub.className = 'filepond--file-status-sub';\n        root.appendChild(sub);\n        root.ref.sub = sub;\n\n        didSetItemLoadProgress({ root: root, action: { progress: null } });\n    };\n\n    var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_LOADING')\n                : root.query('GET_LABEL_FILE_LOADING') + ' ' + toPercentage(action.progress) + '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_PROCESSING')\n                : root.query('GET_LABEL_FILE_PROCESSING') +\n                  ' ' +\n                  toPercentage(action.progress) +\n                  '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n        var root = _ref4.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n        var root = _ref5.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n    };\n\n    var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n        var root = _ref6.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n    };\n\n    var clear = function clear(_ref7) {\n        var root = _ref7.root;\n        text(root.ref.main, '');\n        text(root.ref.sub, '');\n    };\n\n    var error = function error(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        text(root.ref.main, action.status.main);\n        text(root.ref.sub, action.status.sub);\n    };\n\n    var fileStatus = createView({\n        name: 'file-status',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: clear,\n            DID_REVERT_ITEM_PROCESSING: clear,\n            DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n            DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n            DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n            DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n            DID_THROW_ITEM_LOAD_ERROR: error,\n            DID_THROW_ITEM_INVALID: error,\n            DID_THROW_ITEM_PROCESSING_ERROR: error,\n            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n            DID_THROW_ITEM_REMOVE_ERROR: error,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$3,\n        mixins: {\n            styles: ['translateX', 'translateY', 'opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 250 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    /**\n     * Button definitions for the file view\n     */\n\n    var Buttons = {\n        AbortItemLoad: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n            action: 'ABORT_ITEM_LOAD',\n            className: 'filepond--action-abort-item-load',\n            align: 'LOAD_INDICATOR_POSITION', // right\n        },\n        RetryItemLoad: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n            action: 'RETRY_ITEM_LOAD',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-load',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RemoveItem: {\n            label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n            action: 'REQUEST_REMOVE_ITEM',\n            icon: 'GET_ICON_REMOVE',\n            className: 'filepond--action-remove-item',\n            align: 'BUTTON_REMOVE_ITEM_POSITION', // left\n        },\n        ProcessItem: {\n            label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n            action: 'REQUEST_ITEM_PROCESSING',\n            icon: 'GET_ICON_PROCESS',\n            className: 'filepond--action-process-item',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        AbortItemProcessing: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n            action: 'ABORT_ITEM_PROCESSING',\n            className: 'filepond--action-abort-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RetryItemProcessing: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n            action: 'RETRY_ITEM_PROCESSING',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RevertItemProcessing: {\n            label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n            action: 'REQUEST_REVERT_ITEM_PROCESSING',\n            icon: 'GET_ICON_UNDO',\n            className: 'filepond--action-revert-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n    };\n\n    // make a list of buttons, we can then remove buttons from this list if they're disabled\n    var ButtonKeys = [];\n    forin(Buttons, function(key) {\n        ButtonKeys.push(key);\n    });\n\n    var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n        if (getRemoveIndicatorAligment(root) === 'right') return 0;\n        var buttonRect = root.ref.buttonRemoveItem.rect.element;\n        return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n    };\n\n    var calculateButtonWidth = function calculateButtonWidth(root) {\n        var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n        return buttonRect.width;\n    };\n\n    // Force on full pixels so text stays crips\n    var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n    };\n    var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n    };\n\n    var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n        return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n    };\n    var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(root) {\n        return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n    };\n    var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n        return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n    };\n\n    var DefaultStyle = {\n        buttonAbortItemLoad: { opacity: 0 },\n        buttonRetryItemLoad: { opacity: 0 },\n        buttonRemoveItem: { opacity: 0 },\n        buttonProcessItem: { opacity: 0 },\n        buttonAbortItemProcessing: { opacity: 0 },\n        buttonRetryItemProcessing: { opacity: 0 },\n        buttonRevertItemProcessing: { opacity: 0 },\n        loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n        processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },\n        processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n        info: { translateX: 0, translateY: 0, opacity: 0 },\n        status: { translateX: 0, translateY: 0, opacity: 0 },\n    };\n\n    var IdleStyle = {\n        buttonRemoveItem: { opacity: 1 },\n        buttonProcessItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { translateX: calculateFileInfoOffset },\n    };\n\n    var ProcessingStyle = {\n        buttonAbortItemProcessing: { opacity: 1 },\n        processProgressIndicator: { opacity: 1 },\n        status: { opacity: 1 },\n    };\n\n    var StyleMap = {\n        DID_THROW_ITEM_INVALID: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset, opacity: 1 },\n        },\n\n        DID_START_ITEM_LOAD: {\n            buttonAbortItemLoad: { opacity: 1 },\n            loadProgressIndicator: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_LOAD_ERROR: {\n            buttonRetryItemLoad: { opacity: 1 },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_START_ITEM_REMOVE: {\n            processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 0 },\n        },\n\n        DID_THROW_ITEM_REMOVE_ERROR: {\n            processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1, translateX: calculateFileInfoOffset },\n        },\n\n        DID_LOAD_ITEM: IdleStyle,\n        DID_LOAD_LOCAL_ITEM: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_START_ITEM_PROCESSING: ProcessingStyle,\n        DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n        DID_COMPLETE_ITEM_PROCESSING: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            info: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_PROCESSING_ERROR: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonRetryItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { opacity: 1 },\n        },\n\n        DID_ABORT_ITEM_PROCESSING: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonProcessItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_REVERT_ITEM_PROCESSING: IdleStyle,\n    };\n\n    // complete indicator view\n    var processingCompleteIndicatorView = createView({\n        create: function create(_ref) {\n            var root = _ref.root;\n            root.element.innerHTML = root.query('GET_ICON_DONE');\n        },\n        name: 'processing-complete-indicator',\n        ignoreRect: true,\n        mixins: {\n            styles: ['scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$4 = function create(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // copy Buttons object\n        var LocalButtons = Object.keys(Buttons).reduce(function(prev, curr) {\n            prev[curr] = Object.assign({}, Buttons[curr]);\n            return prev;\n        }, {});\n        var id = props.id;\n\n        // allow reverting upload\n        var allowRevert = root.query('GET_ALLOW_REVERT');\n\n        // allow remove file\n        var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n        // allow processing upload\n        var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n        // is instant uploading, need this to determine the icon of the undo button\n        var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n        // is async set up\n        var isAsync = root.query('IS_ASYNC');\n\n        // should align remove item buttons\n        var alignRemoveItemButton = root.query('GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN');\n\n        // enabled buttons array\n        var buttonFilter;\n        if (isAsync) {\n            if (allowProcess && !allowRevert) {\n                // only remove revert button\n                buttonFilter = function buttonFilter(key) {\n                    return !/RevertItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && allowRevert) {\n                // only remove process button\n                buttonFilter = function buttonFilter(key) {\n                    return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && !allowRevert) {\n                // remove all process buttons\n                buttonFilter = function buttonFilter(key) {\n                    return !/Process/.test(key);\n                };\n            }\n        } else {\n            // no process controls available\n            buttonFilter = function buttonFilter(key) {\n                return !/Process/.test(key);\n            };\n        }\n\n        var enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n\n        // update icon and label for revert button when instant uploading\n        if (instantUpload && allowRevert) {\n            LocalButtons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n            LocalButtons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n        }\n\n        // remove last button (revert) if not allowed\n        if (isAsync && !allowRevert) {\n            var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            map.info.translateX = calculateFileHorizontalCenterOffset;\n            map.info.translateY = calculateFileVerticalCenterOffset;\n            map.status.translateY = calculateFileVerticalCenterOffset;\n            map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // should align center\n        if (isAsync && !allowProcess) {\n            [\n                'DID_START_ITEM_PROCESSING',\n                'DID_REQUEST_ITEM_PROCESSING',\n                'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n                'DID_THROW_ITEM_PROCESSING_ERROR',\n            ].forEach(function(key) {\n                StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n            });\n            StyleMap['DID_THROW_ITEM_PROCESSING_ERROR'].status.translateX = calculateButtonWidth;\n        }\n\n        // move remove button to right\n        if (alignRemoveItemButton && allowRevert) {\n            LocalButtons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n            var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            _map.info.translateX = calculateFileInfoOffset;\n            _map.status.translateY = calculateFileVerticalCenterOffset;\n            _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // show/hide RemoveItem button\n        if (!allowRemove) {\n            LocalButtons['RemoveItem'].disabled = true;\n        }\n\n        // create the button views\n        forin(LocalButtons, function(key, definition) {\n            // create button\n            var buttonView = root.createChildView(fileActionButton, {\n                label: root.query(definition.label),\n                icon: root.query(definition.icon),\n                opacity: 0,\n            });\n\n            // should be appended?\n            if (enabledButtons.includes(key)) {\n                root.appendChildView(buttonView);\n            }\n\n            // toggle\n            if (definition.disabled) {\n                buttonView.element.setAttribute('disabled', 'disabled');\n                buttonView.element.setAttribute('hidden', 'hidden');\n            }\n\n            // add position attribute\n            buttonView.element.dataset.align = root.query('GET_STYLE_' + definition.align);\n\n            // add class\n            buttonView.element.classList.add(definition.className);\n\n            // handle interactions\n            buttonView.on('click', function(e) {\n                e.stopPropagation();\n                if (definition.disabled) return;\n                root.dispatch(definition.action, { query: id });\n            });\n\n            // set reference\n            root.ref['button' + key] = buttonView;\n        });\n\n        // checkmark\n        root.ref.processingCompleteIndicator = root.appendChildView(\n            root.createChildView(processingCompleteIndicatorView)\n        );\n\n        root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n            'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n        );\n\n        // create file info view\n        root.ref.info = root.appendChildView(root.createChildView(fileInfo, { id: id }));\n\n        // create file status view\n        root.ref.status = root.appendChildView(root.createChildView(fileStatus, { id: id }));\n\n        // add progress indicators\n        var loadIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION'),\n            })\n        );\n\n        loadIndicatorView.element.classList.add('filepond--load-indicator');\n        root.ref.loadProgressIndicator = loadIndicatorView;\n\n        var progressIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION'),\n            })\n        );\n\n        progressIndicatorView.element.classList.add('filepond--process-indicator');\n        root.ref.processProgressIndicator = progressIndicatorView;\n\n        // current active styles\n        root.ref.activeStyles = [];\n    };\n\n    var write$2 = function write(_ref3) {\n        var root = _ref3.root,\n            actions = _ref3.actions,\n            props = _ref3.props;\n        // route actions\n        route({ root: root, actions: actions, props: props });\n\n        // select last state change action\n        var action = actions\n            .concat()\n            .filter(function(action) {\n                return /^DID_/.test(action.type);\n            })\n            .reverse()\n            .find(function(action) {\n                return StyleMap[action.type];\n            });\n\n        // a new action happened, let's get the matching styles\n        if (action) {\n            // define new active styles\n            root.ref.activeStyles = [];\n\n            var stylesToApply = StyleMap[action.type];\n            forin(DefaultStyle, function(name, defaultStyles) {\n                // get reference to control\n                var control = root.ref[name];\n\n                // loop over all styles for this control\n                forin(defaultStyles, function(key, defaultValue) {\n                    var value =\n                        stylesToApply[name] && typeof stylesToApply[name][key] !== 'undefined'\n                            ? stylesToApply[name][key]\n                            : defaultValue;\n                    root.ref.activeStyles.push({ control: control, key: key, value: value });\n                });\n            });\n        }\n\n        // apply active styles to element\n        root.ref.activeStyles.forEach(function(_ref4) {\n            var control = _ref4.control,\n                key = _ref4.key,\n                value = _ref4.value;\n            control[key] = typeof value === 'function' ? value(root) : value;\n        });\n    };\n\n    var route = createRoute({\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n            _ref5\n        ) {\n            var root = _ref5.root,\n                action = _ref5.action;\n            root.ref.buttonAbortItemProcessing.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(_ref6) {\n            var root = _ref6.root,\n                action = _ref6.action;\n            root.ref.buttonAbortItemLoad.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n            _ref7\n        ) {\n            var root = _ref7.root,\n                action = _ref7.action;\n            root.ref.buttonAbortItemRemoval.label = action.value;\n        },\n        DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n            var root = _ref8.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n            var root = _ref9.root;\n            root.ref.loadProgressIndicator.spin = true;\n            root.ref.loadProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n            var root = _ref10.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(_ref11) {\n            var root = _ref11.root,\n                action = _ref11.action;\n            root.ref.loadProgressIndicator.spin = false;\n            root.ref.loadProgressIndicator.progress = action.progress;\n        },\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(_ref12) {\n            var root = _ref12.root,\n                action = _ref12.action;\n            root.ref.processProgressIndicator.spin = false;\n            root.ref.processProgressIndicator.progress = action.progress;\n        },\n    });\n\n    var file = createView({\n        create: create$4,\n        write: write$2,\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        name: 'file',\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$5 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // filename\n        root.ref.fileName = createElement$1('legend');\n        root.appendChild(root.ref.fileName);\n\n        // file appended\n        root.ref.file = root.appendChildView(root.createChildView(file, { id: props.id }));\n\n        // data has moved to data.js\n        root.ref.data = false;\n    };\n\n    /**\n     * Data storage\n     */\n    var didLoadItem = function didLoadItem(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // updates the legend of the fieldset so screenreaders can better group buttons\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var fileWrapper = createView({\n        create: create$5,\n        ignoreRect: true,\n        write: createRoute({\n            DID_LOAD_ITEM: didLoadItem,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        tag: 'fieldset',\n        name: 'file-wrapper',\n    });\n\n    var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n    var create$6 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        [\n            {\n                name: 'top',\n            },\n\n            {\n                name: 'center',\n                props: {\n                    translateY: null,\n                    scaleY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        scaleY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY', 'scaleY'],\n                },\n            },\n\n            {\n                name: 'bottom',\n                props: {\n                    translateY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        translateY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY'],\n                },\n            },\n        ].forEach(function(section) {\n            createSection(root, section, props.name);\n        });\n\n        root.element.classList.add('filepond--' + props.name);\n\n        root.ref.scalable = null;\n    };\n\n    var createSection = function createSection(root, section, className) {\n        var viewConstructor = createView({\n            name: 'panel-' + section.name + ' filepond--' + className,\n            mixins: section.mixins,\n            ignoreRectUpdate: true,\n        });\n\n        var view = root.createChildView(viewConstructor, section.props);\n\n        root.ref[section.name] = root.appendChildView(view);\n    };\n\n    var write$3 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n\n        // update scalable state\n        if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n            root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n            root.element.dataset.scalable = root.ref.scalable;\n        }\n\n        // no height, can't set\n        if (!props.height) return;\n\n        // get child rects\n        var topRect = root.ref.top.rect.element;\n        var bottomRect = root.ref.bottom.rect.element;\n\n        // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n        var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n        // offset center part\n        root.ref.center.translateY = topRect.height;\n\n        // scale center part\n        // use math ceil to prevent transparent lines because of rounding errors\n        root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n\n        // offset bottom part\n        root.ref.bottom.translateY = height - bottomRect.height;\n    };\n\n    var panel = createView({\n        name: 'panel',\n        read: function read(_ref3) {\n            var root = _ref3.root,\n                props = _ref3.props;\n            return (props.heightCurrent = root.ref.bottom.translateY);\n        },\n        write: write$3,\n        create: create$6,\n        ignoreRect: true,\n        mixins: {\n            apis: ['height', 'heightCurrent', 'scalable'],\n        },\n    });\n\n    var createDragHelper = function createDragHelper(items) {\n        var itemIds = items.map(function(item) {\n            return item.id;\n        });\n        var prevIndex = undefined;\n        return {\n            setIndex: function setIndex(index) {\n                prevIndex = index;\n            },\n            getIndex: function getIndex() {\n                return prevIndex;\n            },\n            getItemIndex: function getItemIndex(item) {\n                return itemIds.indexOf(item.id);\n            },\n        };\n    };\n\n    var ITEM_TRANSLATE_SPRING = {\n        type: 'spring',\n        stiffness: 0.75,\n        damping: 0.45,\n        mass: 10,\n    };\n\n    var ITEM_SCALE_SPRING = 'spring';\n\n    var StateMap = {\n        DID_START_ITEM_LOAD: 'busy',\n        DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n        DID_THROW_ITEM_INVALID: 'load-invalid',\n        DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n        DID_LOAD_ITEM: 'idle',\n        DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n        DID_START_ITEM_REMOVE: 'busy',\n        DID_START_ITEM_PROCESSING: 'busy processing',\n        DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n        DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n        DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n        DID_ABORT_ITEM_PROCESSING: 'cancelled',\n        DID_REVERT_ITEM_PROCESSING: 'idle',\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$7 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // select\n        root.ref.handleClick = function(e) {\n            return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n        };\n\n        // set id\n        root.element.id = 'filepond--item-' + props.id;\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // file view\n        root.ref.container = root.appendChildView(\n            root.createChildView(fileWrapper, { id: props.id })\n        );\n\n        // file panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'item-panel' }));\n\n        // default start height\n        root.ref.panel.height = null;\n\n        // by default not marked for removal\n        props.markedForRemoval = false;\n\n        // if not allowed to reorder file items, exit here\n        if (!root.query('GET_ALLOW_REORDER')) return;\n\n        // set to idle so shows grab cursor\n        root.element.dataset.dragState = 'idle';\n\n        var grab = function grab(e) {\n            if (!e.isPrimary) return;\n\n            var removedActivateListener = false;\n\n            var origin = {\n                x: e.pageX,\n                y: e.pageY,\n            };\n\n            props.dragOrigin = {\n                x: root.translateX,\n                y: root.translateY,\n            };\n\n            props.dragCenter = {\n                x: e.offsetX,\n                y: e.offsetY,\n            };\n\n            var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n            root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n            var drag = function drag(e) {\n                if (!e.isPrimary) return;\n\n                e.stopPropagation();\n                e.preventDefault();\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                // if dragged stop listening to clicks, will re-add when done dragging\n                var dist =\n                    props.dragOffset.x * props.dragOffset.x +\n                    props.dragOffset.y * props.dragOffset.y;\n                if (dist > 16 && !removedActivateListener) {\n                    removedActivateListener = true;\n                    root.element.removeEventListener('click', root.ref.handleClick);\n                }\n\n                root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n            };\n\n            var drop = function drop(e) {\n                if (!e.isPrimary) return;\n\n                document.removeEventListener('pointermove', drag);\n                document.removeEventListener('pointerup', drop);\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n                // start listening to clicks again\n                if (removedActivateListener) {\n                    setTimeout(function() {\n                        return root.element.addEventListener('click', root.ref.handleClick);\n                    }, 0);\n                }\n            };\n\n            document.addEventListener('pointermove', drag);\n            document.addEventListener('pointerup', drop);\n        };\n\n        root.element.addEventListener('pointerdown', grab);\n    };\n\n    var route$1 = createRoute({\n        DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n            var root = _ref2.root,\n                action = _ref2.action;\n            root.height = action.height;\n        },\n    });\n\n    var write$4 = createRoute(\n        {\n            DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n                var root = _ref3.root,\n                    props = _ref3.props;\n                props.dragOrigin = {\n                    x: root.translateX,\n                    y: root.translateY,\n                };\n            },\n            DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n                var root = _ref4.root;\n                root.element.dataset.dragState = 'drag';\n            },\n            DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n                var root = _ref5.root,\n                    props = _ref5.props;\n                props.dragOffset = null;\n                props.dragOrigin = null;\n                root.element.dataset.dragState = 'drop';\n            },\n        },\n        function(_ref6) {\n            var root = _ref6.root,\n                actions = _ref6.actions,\n                props = _ref6.props,\n                shouldOptimize = _ref6.shouldOptimize;\n\n            if (root.element.dataset.dragState === 'drop') {\n                if (root.scaleX <= 1) {\n                    root.element.dataset.dragState = 'idle';\n                }\n            }\n\n            // select last state change action\n            var action = actions\n                .concat()\n                .filter(function(action) {\n                    return /^DID_/.test(action.type);\n                })\n                .reverse()\n                .find(function(action) {\n                    return StateMap[action.type];\n                });\n\n            // no need to set same state twice\n            if (action && action.type !== props.currentState) {\n                // set current state\n                props.currentState = action.type;\n\n                // set state\n                root.element.dataset.filepondItemState = StateMap[props.currentState] || '';\n            }\n\n            // route actions\n            var aspectRatio =\n                root.query('GET_ITEM_PANEL_ASPECT_RATIO') || root.query('GET_PANEL_ASPECT_RATIO');\n            if (!aspectRatio) {\n                route$1({ root: root, actions: actions, props: props });\n                if (!root.height && root.ref.container.rect.element.height > 0) {\n                    root.height = root.ref.container.rect.element.height;\n                }\n            } else if (!shouldOptimize) {\n                root.height = root.rect.element.width * aspectRatio;\n            }\n\n            // sync panel height with item height\n            if (shouldOptimize) {\n                root.ref.panel.height = null;\n            }\n\n            root.ref.panel.height = root.height;\n        }\n    );\n\n    var item = createView({\n        create: create$7,\n        write: write$4,\n        destroy: function destroy(_ref7) {\n            var root = _ref7.root,\n                props = _ref7.props;\n            root.element.removeEventListener('click', root.ref.handleClick);\n            root.dispatch('RELEASE_ITEM', { query: props.id });\n        },\n        tag: 'li',\n        name: 'item',\n        mixins: {\n            apis: [\n                'id',\n                'interactionMethod',\n                'markedForRemoval',\n                'spawnDate',\n                'dragCenter',\n                'dragOrigin',\n                'dragOffset',\n            ],\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity', 'height'],\n\n            animations: {\n                scaleX: ITEM_SCALE_SPRING,\n                scaleY: ITEM_SCALE_SPRING,\n                translateX: ITEM_TRANSLATE_SPRING,\n                translateY: ITEM_TRANSLATE_SPRING,\n                opacity: { type: 'tween', duration: 150 },\n            },\n        },\n    });\n\n    var getItemsPerRow = function(horizontalSpace, itemWidth) {\n        // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n\n        return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n    };\n\n    var getItemIndexByPosition = function getItemIndexByPosition(view, children, positionInView) {\n        if (!positionInView) return;\n\n        var horizontalSpace = view.rect.element.width;\n        // const children = view.childViews;\n        var l = children.length;\n        var last = null;\n\n        // -1, don't move items to accomodate (either add to top or bottom)\n        if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n        // let's get the item width\n        var item = children[0];\n        var itemRect = item.rect.element;\n        var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n        var itemWidth = itemRect.width + itemHorizontalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            for (var index = 0; index < l; index++) {\n                var child = children[index];\n                var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n                if (positionInView.top < childMid) {\n                    return index;\n                }\n            }\n            return l;\n        }\n\n        // grid\n        var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n        var itemHeight = itemRect.height + itemVerticalMargin;\n        for (var _index = 0; _index < l; _index++) {\n            var indexX = _index % itemsPerRow;\n            var indexY = Math.floor(_index / itemsPerRow);\n\n            var offsetX = indexX * itemWidth;\n            var offsetY = indexY * itemHeight;\n\n            var itemTop = offsetY - itemRect.marginTop;\n            var itemRight = offsetX + itemWidth;\n            var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n            if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n                if (positionInView.left < itemRight) {\n                    return _index;\n                } else if (_index !== l - 1) {\n                    last = _index;\n                } else {\n                    last = null;\n                }\n            }\n        }\n\n        if (last !== null) {\n            return last;\n        }\n\n        return l;\n    };\n\n    var dropAreaDimensions = {\n        height: 0,\n        width: 0,\n        get getHeight() {\n            return this.height;\n        },\n        set setHeight(val) {\n            if (this.height === 0 || val === 0) this.height = val;\n        },\n        get getWidth() {\n            return this.width;\n        },\n        set setWidth(val) {\n            if (this.width === 0 || val === 0) this.width = val;\n        },\n        setDimensions: function setDimensions(height, width) {\n            if (this.height === 0 || height === 0) this.height = height;\n            if (this.width === 0 || width === 0) this.width = width;\n        },\n    };\n\n    var create$8 = function create(_ref) {\n        var root = _ref.root;\n        // need to set role to list as otherwise it won't be read as a list by VoiceOver\n        attr(root.element, 'role', 'list');\n\n        root.ref.lastItemSpanwDate = Date.now();\n    };\n\n    /**\n     * Inserts a new item\n     * @param root\n     * @param action\n     */\n    var addItemView = function addItemView(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var id = action.id,\n            index = action.index,\n            interactionMethod = action.interactionMethod;\n\n        root.ref.addIndex = index;\n\n        var now = Date.now();\n        var spawnDate = now;\n        var opacity = 1;\n\n        if (interactionMethod !== InteractionMethod.NONE) {\n            opacity = 0;\n            var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n            var dist = now - root.ref.lastItemSpanwDate;\n            spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n        }\n\n        root.ref.lastItemSpanwDate = spawnDate;\n\n        root.appendChildView(\n            root.createChildView(\n                // view type\n                item,\n\n                // props\n                {\n                    spawnDate: spawnDate,\n                    id: id,\n                    opacity: opacity,\n                    interactionMethod: interactionMethod,\n                }\n            ),\n\n            index\n        );\n    };\n\n    var moveItem = function moveItem(item, x, y) {\n        var vx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var vy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n        // set to null to remove animation while dragging\n        if (item.dragOffset) {\n            item.translateX = null;\n            item.translateY = null;\n            item.translateX = item.dragOrigin.x + item.dragOffset.x;\n            item.translateY = item.dragOrigin.y + item.dragOffset.y;\n            item.scaleX = 1.025;\n            item.scaleY = 1.025;\n        } else {\n            item.translateX = x;\n            item.translateY = y;\n\n            if (Date.now() > item.spawnDate) {\n                // reveal element\n                if (item.opacity === 0) {\n                    introItemView(item, x, y, vx, vy);\n                }\n\n                // make sure is default scale every frame\n                item.scaleX = 1;\n                item.scaleY = 1;\n                item.opacity = 1;\n            }\n        }\n    };\n\n    var introItemView = function introItemView(item, x, y, vx, vy) {\n        if (item.interactionMethod === InteractionMethod.NONE) {\n            item.translateX = null;\n            item.translateX = x;\n            item.translateY = null;\n            item.translateY = y;\n        } else if (item.interactionMethod === InteractionMethod.DROP) {\n            item.translateX = null;\n            item.translateX = x - vx * 20;\n\n            item.translateY = null;\n            item.translateY = y - vy * 10;\n\n            item.scaleX = 0.8;\n            item.scaleY = 0.8;\n        } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n            item.translateY = null;\n            item.translateY = y - 30;\n        } else if (item.interactionMethod === InteractionMethod.API) {\n            item.translateX = null;\n            item.translateX = x - 30;\n            item.translateY = null;\n        }\n    };\n\n    /**\n     * Removes an existing item\n     * @param root\n     * @param action\n     */\n    var removeItemView = function removeItemView(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var id = action.id;\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        // if no view found, exit\n        if (!view) {\n            return;\n        }\n\n        // animate view out of view\n        view.scaleX = 0.9;\n        view.scaleY = 0.9;\n        view.opacity = 0;\n\n        // mark for removal\n        view.markedForRemoval = true;\n    };\n\n    var getItemHeight = function getItemHeight(child) {\n        return (\n            child.rect.element.height +\n            child.rect.element.marginBottom * 0.5 +\n            child.rect.element.marginTop * 0.5\n        );\n    };\n    var getItemWidth = function getItemWidth(child) {\n        return (\n            child.rect.element.width +\n            child.rect.element.marginLeft * 0.5 +\n            child.rect.element.marginRight * 0.5\n        );\n    };\n\n    var dragItem = function dragItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var id = action.id,\n            dragState = action.dragState;\n\n        // reference to item\n        var item = root.query('GET_ITEM', { id: id });\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        var numItems = root.childViews.length;\n        var oldIndex = dragState.getItemIndex(item);\n\n        // if no view found, exit\n        if (!view) return;\n\n        var dragPosition = {\n            x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n            y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y,\n        };\n\n        // get drag area dimensions\n        var dragHeight = getItemHeight(view);\n        var dragWidth = getItemWidth(view);\n\n        // get rows and columns (There will always be at least one row and one column if a file is present)\n        var cols = Math.floor(root.rect.outer.width / dragWidth);\n        if (cols > numItems) cols = numItems;\n\n        // rows are used to find when we have left the preview area bounding box\n        var rows = Math.floor(numItems / cols + 1);\n\n        dropAreaDimensions.setHeight = dragHeight * rows;\n        dropAreaDimensions.setWidth = dragWidth * cols;\n\n        // get new index of dragged item\n        var location = {\n            y: Math.floor(dragPosition.y / dragHeight),\n            x: Math.floor(dragPosition.x / dragWidth),\n            getGridIndex: function getGridIndex() {\n                if (\n                    dragPosition.y > dropAreaDimensions.getHeight ||\n                    dragPosition.y < 0 ||\n                    dragPosition.x > dropAreaDimensions.getWidth ||\n                    dragPosition.x < 0\n                )\n                    return oldIndex;\n                return this.y * cols + this.x;\n            },\n            getColIndex: function getColIndex() {\n                var items = root.query('GET_ACTIVE_ITEMS');\n                var visibleChildren = root.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = items.map(function(item) {\n                    return visibleChildren.find(function(childView) {\n                        return childView.id === item.id;\n                    });\n                });\n\n                var currentIndex = children.findIndex(function(child) {\n                    return child === view;\n                });\n                var dragHeight = getItemHeight(view);\n                var l = children.length;\n                var idx = l;\n                var childHeight = 0;\n                var childBottom = 0;\n                var childTop = 0;\n                for (var i = 0; i < l; i++) {\n                    childHeight = getItemHeight(children[i]);\n                    childTop = childBottom;\n                    childBottom = childTop + childHeight;\n                    if (dragPosition.y < childBottom) {\n                        if (currentIndex > i) {\n                            if (dragPosition.y < childTop + dragHeight) {\n                                idx = i;\n                                break;\n                            }\n                            continue;\n                        }\n                        idx = i;\n                        break;\n                    }\n                }\n                return idx;\n            },\n        };\n\n        // get new index\n        var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n        root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n        // if the index of the item changed, dispatch reorder action\n        var currentIndex = dragState.getIndex();\n\n        if (currentIndex === undefined || currentIndex !== index) {\n            dragState.setIndex(index);\n\n            if (currentIndex === undefined) return;\n\n            root.dispatch('DID_REORDER_ITEMS', {\n                items: root.query('GET_ACTIVE_ITEMS'),\n                origin: oldIndex,\n                target: index,\n            });\n        }\n    };\n\n    /**\n     * Setup action routes\n     */\n    var route$2 = createRoute({\n        DID_ADD_ITEM: addItemView,\n        DID_REMOVE_ITEM: removeItemView,\n        DID_DRAG_ITEM: dragItem,\n    });\n\n    /**\n     * Write to view\n     * @param root\n     * @param actions\n     * @param props\n     */\n    var write$5 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions,\n            shouldOptimize = _ref5.shouldOptimize;\n        // route actions\n        route$2({ root: root, props: props, actions: actions });\n        var dragCoordinates = props.dragCoordinates;\n\n        // available space on horizontal axis\n        var horizontalSpace = root.rect.element.width;\n\n        // only draw children that have dimensions\n        var visibleChildren = root.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n\n        // sort based on current active items\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // get index\n        var dragIndex = dragCoordinates\n            ? getItemIndexByPosition(root, children, dragCoordinates)\n            : null;\n\n        // add index is used to reserve the dropped/added item index till the actual item is rendered\n        var addIndex = root.ref.addIndex || null;\n\n        // add index no longer needed till possibly next draw\n        root.ref.addIndex = null;\n\n        var dragIndexOffset = 0;\n        var removeIndexOffset = 0;\n        var addIndexOffset = 0;\n\n        if (children.length === 0) return;\n\n        var childRect = children[0].rect.element;\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            var offsetY = 0;\n            var dragOffset = 0;\n\n            children.forEach(function(child, index) {\n                if (dragIndex) {\n                    var dist = index - dragIndex;\n                    if (dist === -2) {\n                        dragOffset = -itemVerticalMargin * 0.25;\n                    } else if (dist === -1) {\n                        dragOffset = -itemVerticalMargin * 0.75;\n                    } else if (dist === 0) {\n                        dragOffset = itemVerticalMargin * 0.75;\n                    } else if (dist === 1) {\n                        dragOffset = itemVerticalMargin * 0.25;\n                    } else {\n                        dragOffset = 0;\n                    }\n                }\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                if (!child.markedForRemoval) {\n                    moveItem(child, 0, offsetY + dragOffset);\n                }\n\n                var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n                var visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n                offsetY += visualHeight;\n            });\n        }\n        // grid\n        else {\n            var prevX = 0;\n            var prevY = 0;\n\n            children.forEach(function(child, index) {\n                if (index === dragIndex) {\n                    dragIndexOffset = 1;\n                }\n\n                if (index === addIndex) {\n                    addIndexOffset += 1;\n                }\n\n                if (child.markedForRemoval && child.opacity < 0.5) {\n                    removeIndexOffset -= 1;\n                }\n\n                var visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n                var indexX = visualIndex % itemsPerRow;\n                var indexY = Math.floor(visualIndex / itemsPerRow);\n\n                var offsetX = indexX * itemWidth;\n                var offsetY = indexY * itemHeight;\n\n                var vectorX = Math.sign(offsetX - prevX);\n                var vectorY = Math.sign(offsetY - prevY);\n\n                prevX = offsetX;\n                prevY = offsetY;\n\n                if (child.markedForRemoval) return;\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                moveItem(child, offsetX, offsetY, vectorX, vectorY);\n            });\n        }\n    };\n\n    /**\n     * Filters actions that are meant specifically for a certain child of the list\n     * @param child\n     * @param actions\n     */\n    var filterSetItemActions = function filterSetItemActions(child, actions) {\n        return actions.filter(function(action) {\n            // if action has an id, filter out actions that don't have this child id\n            if (action.data && action.data.id) {\n                return child.id === action.data.id;\n            }\n\n            // allow all other actions\n            return true;\n        });\n    };\n\n    var list = createView({\n        create: create$8,\n        write: write$5,\n        tag: 'ul',\n        name: 'list',\n        didWriteView: function didWriteView(_ref6) {\n            var root = _ref6.root;\n            root.childViews\n                .filter(function(view) {\n                    return view.markedForRemoval && view.opacity === 0 && view.resting;\n                })\n                .forEach(function(view) {\n                    view._destroy();\n                    root.removeChildView(view);\n                });\n        },\n        filterFrameActionsForChild: filterSetItemActions,\n        mixins: {\n            apis: ['dragCoordinates'],\n        },\n    });\n\n    var create$9 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.ref.list = root.appendChildView(root.createChildView(list));\n        props.dragCoordinates = null;\n        props.overflowing = false;\n    };\n\n    var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props,\n            action = _ref2.action;\n        if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n        props.dragCoordinates = {\n            left: action.position.scopeLeft - root.ref.list.rect.element.left,\n            top:\n                action.position.scopeTop -\n                (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop),\n        };\n    };\n\n    var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n        var props = _ref3.props;\n        props.dragCoordinates = null;\n    };\n\n    var route$3 = createRoute({\n        DID_DRAG: storeDragCoordinates,\n        DID_END_DRAG: clearDragCoordinates,\n    });\n\n    var write$6 = function write(_ref4) {\n        var root = _ref4.root,\n            props = _ref4.props,\n            actions = _ref4.actions;\n\n        // route actions\n        route$3({ root: root, props: props, actions: actions });\n\n        // current drag position\n        root.ref.list.dragCoordinates = props.dragCoordinates;\n\n        // if currently overflowing but no longer received overflow\n        if (props.overflowing && !props.overflow) {\n            props.overflowing = false;\n\n            // reset overflow state\n            root.element.dataset.state = '';\n            root.height = null;\n        }\n\n        // if is not overflowing currently but does receive overflow value\n        if (props.overflow) {\n            var newHeight = Math.round(props.overflow);\n            if (newHeight !== root.height) {\n                props.overflowing = true;\n                root.element.dataset.state = 'overflow';\n                root.height = newHeight;\n            }\n        }\n    };\n\n    var listScroller = createView({\n        create: create$9,\n        write: write$6,\n        name: 'list-scroller',\n        mixins: {\n            apis: ['overflow', 'dragCoordinates'],\n            styles: ['height', 'translateY'],\n            animations: {\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var attrToggle = function attrToggle(element, name, state) {\n        var enabledValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n        if (state) {\n            attr(element, name, enabledValue);\n        } else {\n            element.removeAttribute(name);\n        }\n    };\n\n    var resetFileInput = function resetFileInput(input) {\n        // no value, no need to reset\n        if (!input || input.value === '') {\n            return;\n        }\n\n        try {\n            // for modern browsers\n            input.value = '';\n        } catch (err) {}\n\n        // for IE10\n        if (input.value) {\n            // quickly append input to temp form and reset form\n            var form = createElement$1('form');\n            var parentNode = input.parentNode;\n            var ref = input.nextSibling;\n            form.appendChild(input);\n            form.reset();\n\n            // re-inject input where it originally was\n            if (ref) {\n                parentNode.insertBefore(input, ref);\n            } else {\n                parentNode.appendChild(input);\n            }\n        }\n    };\n\n    var create$a = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // set id so can be referenced from outside labels\n        root.element.id = 'filepond--browser-' + props.id;\n\n        // set name of element (is removed when a value is set)\n        attr(root.element, 'name', root.query('GET_NAME'));\n\n        // we have to link this element to the status element\n        attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n        // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n        attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n        // set configurable props\n        setAcceptedFileTypes({\n            root: root,\n            action: { value: root.query('GET_ACCEPTED_FILE_TYPES') },\n        });\n        toggleAllowMultiple({ root: root, action: { value: root.query('GET_ALLOW_MULTIPLE') } });\n        toggleDirectoryFilter({\n            root: root,\n            action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') },\n        });\n        toggleDisabled({ root: root });\n        toggleRequired({ root: root, action: { value: root.query('GET_REQUIRED') } });\n        setCaptureMethod({ root: root, action: { value: root.query('GET_CAPTURE_METHOD') } });\n\n        // handle changes to the input field\n        root.ref.handleChange = function(e) {\n            if (!root.element.value) {\n                return;\n            }\n\n            // extract files and move value of webkitRelativePath path to _relativePath\n            var files = Array.from(root.element.files).map(function(file) {\n                file._relativePath = file.webkitRelativePath;\n                return file;\n            });\n\n            // we add a little delay so the OS file select window can move out of the way before we add our file\n            setTimeout(function() {\n                // load files\n                props.onload(files);\n\n                // reset input, it's just for exposing a method to drop files, should not retain any state\n                resetFileInput(root.element);\n            }, 250);\n        };\n\n        root.element.addEventListener('change', root.ref.handleChange);\n    };\n\n    var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n        attrToggle(\n            root.element,\n            'accept',\n            !!action.value,\n            action.value ? action.value.join(',') : ''\n        );\n    };\n\n    var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        attrToggle(root.element, 'multiple', action.value);\n    };\n\n    var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        attrToggle(root.element, 'webkitdirectory', action.value);\n    };\n\n    var toggleDisabled = function toggleDisabled(_ref5) {\n        var root = _ref5.root;\n        var isDisabled = root.query('GET_DISABLED');\n        var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n        var disableField = isDisabled || !doesAllowBrowse;\n        attrToggle(root.element, 'disabled', disableField);\n    };\n\n    var toggleRequired = function toggleRequired(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        // want to remove required, always possible\n        if (!action.value) {\n            attrToggle(root.element, 'required', false);\n        }\n        // if want to make required, only possible when zero items\n        else if (root.query('GET_TOTAL_ITEMS') === 0) {\n            attrToggle(root.element, 'required', true);\n        }\n    };\n\n    var setCaptureMethod = function setCaptureMethod(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        attrToggle(\n            root.element,\n            'capture',\n            !!action.value,\n            action.value === true ? '' : action.value\n        );\n    };\n\n    var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n        var root = _ref8.root;\n        var element = root.element;\n        // always remove the required attribute when more than zero items\n        if (root.query('GET_TOTAL_ITEMS') > 0) {\n            attrToggle(element, 'required', false);\n            attrToggle(element, 'name', false);\n        } else {\n            // add name attribute\n            attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n            // remove any validation messages\n            var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n            if (shouldCheckValidity) {\n                element.setCustomValidity('');\n            }\n\n            // we only add required if the field has been deemed required\n            if (root.query('GET_REQUIRED')) {\n                attrToggle(element, 'required', true);\n            }\n        }\n    };\n\n    var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n        var root = _ref9.root;\n        var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n        if (!shouldCheckValidity) return;\n        root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n    };\n\n    var browser = createView({\n        tag: 'input',\n        name: 'browser',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        attributes: {\n            type: 'file',\n        },\n\n        create: create$a,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            root.element.removeEventListener('change', root.ref.handleChange);\n        },\n        write: createRoute({\n            DID_LOAD_ITEM: updateRequiredStatus,\n            DID_REMOVE_ITEM: updateRequiredStatus,\n            DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n            DID_SET_DISABLED: toggleDisabled,\n            DID_SET_ALLOW_BROWSE: toggleDisabled,\n            DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n            DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n            DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n            DID_SET_CAPTURE_METHOD: setCaptureMethod,\n            DID_SET_REQUIRED: toggleRequired,\n        }),\n    });\n\n    var Key = {\n        ENTER: 13,\n        SPACE: 32,\n    };\n\n    var create$b = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // create the label and link it to the file browser\n        var label = createElement$1('label');\n        attr(label, 'for', 'filepond--browser-' + props.id);\n\n        // use for labeling file input (aria-labelledby on file input)\n        attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n        // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n        attr(label, 'aria-hidden', 'true');\n\n        // handle keys\n        root.ref.handleKeyDown = function(e) {\n            var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n            if (!isActivationKey) return;\n            // stops from triggering the element a second time\n            e.preventDefault();\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        root.ref.handleClick = function(e) {\n            var isLabelClick = e.target === label || label.contains(e.target);\n\n            // don't want to click twice\n            if (isLabelClick) return;\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        // attach events\n        label.addEventListener('keydown', root.ref.handleKeyDown);\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // update\n        updateLabelValue(label, props.caption);\n\n        // add!\n        root.appendChild(label);\n        root.ref.label = label;\n    };\n\n    var updateLabelValue = function updateLabelValue(label, value) {\n        label.innerHTML = value;\n        var clickable = label.querySelector('.filepond--label-action');\n        if (clickable) {\n            attr(clickable, 'tabindex', '0');\n        }\n        return value;\n    };\n\n    var dropLabel = createView({\n        name: 'drop-label',\n        ignoreRect: true,\n        create: create$b,\n        destroy: function destroy(_ref2) {\n            var root = _ref2.root;\n            root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n            root.element.removeEventListener('click', root.ref.handleClick);\n        },\n        write: createRoute({\n            DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n                var root = _ref3.root,\n                    action = _ref3.action;\n                updateLabelValue(root.ref.label, action.value);\n            },\n        }),\n\n        mixins: {\n            styles: ['opacity', 'translateX', 'translateY'],\n            animations: {\n                opacity: { type: 'tween', duration: 150 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var blob = createView({\n        name: 'drip-blob',\n        ignoreRect: true,\n        mixins: {\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    var addBlob = function addBlob(_ref) {\n        var root = _ref.root;\n        var centerX = root.rect.element.width * 0.5;\n        var centerY = root.rect.element.height * 0.5;\n\n        root.ref.blob = root.appendChildView(\n            root.createChildView(blob, {\n                opacity: 0,\n                scaleX: 2.5,\n                scaleY: 2.5,\n                translateX: centerX,\n                translateY: centerY,\n            })\n        );\n    };\n\n    var moveBlob = function moveBlob(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.ref.blob) {\n            addBlob({ root: root });\n            return;\n        }\n\n        root.ref.blob.translateX = action.position.scopeLeft;\n        root.ref.blob.translateY = action.position.scopeTop;\n        root.ref.blob.scaleX = 1;\n        root.ref.blob.scaleY = 1;\n        root.ref.blob.opacity = 1;\n    };\n\n    var hideBlob = function hideBlob(_ref3) {\n        var root = _ref3.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.opacity = 0;\n    };\n\n    var explodeBlob = function explodeBlob(_ref4) {\n        var root = _ref4.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.scaleX = 2.5;\n        root.ref.blob.scaleY = 2.5;\n        root.ref.blob.opacity = 0;\n    };\n\n    var write$7 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions;\n        route$4({ root: root, props: props, actions: actions });\n        var blob = root.ref.blob;\n\n        if (actions.length === 0 && blob && blob.opacity === 0) {\n            root.removeChildView(blob);\n            root.ref.blob = null;\n        }\n    };\n\n    var route$4 = createRoute({\n        DID_DRAG: moveBlob,\n        DID_DROP: explodeBlob,\n        DID_END_DRAG: hideBlob,\n    });\n\n    var drip = createView({\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'drip',\n        write: write$7,\n    });\n\n    var setInputFiles = function setInputFiles(element, files) {\n        try {\n            // Create a DataTransfer instance and add a newly created file\n            var dataTransfer = new DataTransfer();\n            files.forEach(function(file) {\n                if (file instanceof File) {\n                    dataTransfer.items.add(file);\n                } else {\n                    dataTransfer.items.add(\n                        new File([file], file.name, {\n                            type: file.type,\n                        })\n                    );\n                }\n            });\n\n            // Assign the DataTransfer files list to the file input\n            element.files = dataTransfer.files;\n        } catch (err) {\n            return false;\n        }\n        return true;\n    };\n\n    var create$c = function create(_ref) {\n        var root = _ref.root;\n        return (root.ref.fields = {});\n    };\n\n    var getField = function getField(root, id) {\n        return root.ref.fields[id];\n    };\n\n    var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n        root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n            if (!root.ref.fields[item.id]) return;\n            root.element.appendChild(root.ref.fields[item.id]);\n        });\n    };\n\n    var didReorderItems = function didReorderItems(_ref2) {\n        var root = _ref2.root;\n        return syncFieldPositionsWithItems(root);\n    };\n\n    var didAddItem = function didAddItem(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var fileItem = root.query('GET_ITEM', action.id);\n        var isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n        var shouldUseFileInput = !isLocalFile && root.query('SHOULD_UPDATE_FILE_INPUT');\n        var dataContainer = createElement$1('input');\n        dataContainer.type = shouldUseFileInput ? 'file' : 'hidden';\n        dataContainer.name = root.query('GET_NAME');\n        dataContainer.disabled = root.query('GET_DISABLED');\n        root.ref.fields[action.id] = dataContainer;\n        syncFieldPositionsWithItems(root);\n    };\n\n    var didLoadItem$1 = function didLoadItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n\n        // store server ref in hidden input\n        if (action.serverFileReference !== null) field.value = action.serverFileReference;\n\n        // store file item in file input\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n\n        var fileItem = root.query('GET_ITEM', action.id);\n        setInputFiles(field, [fileItem.file]);\n    };\n\n    var didPrepareOutput = function didPrepareOutput(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        // this timeout pushes the handler after 'load'\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n        setTimeout(function() {\n            var field = getField(root, action.id);\n            if (!field) return;\n            setInputFiles(field, [action.file]);\n        }, 0);\n    };\n\n    var didSetDisabled = function didSetDisabled(_ref6) {\n        var root = _ref6.root;\n        root.element.disabled = root.query('GET_DISABLED');\n    };\n\n    var didRemoveItem = function didRemoveItem(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (field.parentNode) field.parentNode.removeChild(field);\n        delete root.ref.fields[action.id];\n    };\n\n    // only runs for server files (so doesn't deal with file input)\n    var didDefineValue = function didDefineValue(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (action.value === null) {\n            // clear field value\n            field.removeAttribute('value');\n        } else {\n            // set field value\n            field.value = action.value;\n        }\n        syncFieldPositionsWithItems(root);\n    };\n\n    var write$8 = createRoute({\n        DID_SET_DISABLED: didSetDisabled,\n        DID_ADD_ITEM: didAddItem,\n        DID_LOAD_ITEM: didLoadItem$1,\n        DID_REMOVE_ITEM: didRemoveItem,\n        DID_DEFINE_VALUE: didDefineValue,\n        DID_PREPARE_OUTPUT: didPrepareOutput,\n        DID_REORDER_ITEMS: didReorderItems,\n        DID_SORT_ITEMS: didReorderItems,\n    });\n\n    var data = createView({\n        tag: 'fieldset',\n        name: 'data',\n        create: create$c,\n        write: write$8,\n        ignoreRect: true,\n    });\n\n    var getRootNode = function getRootNode(element) {\n        return 'getRootNode' in element ? element.getRootNode() : document;\n    };\n\n    var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n    var text$1 = ['css', 'csv', 'html', 'txt'];\n    var map = {\n        zip: 'zip|compressed',\n        epub: 'application/epub+zip',\n    };\n\n    var guesstimateMimeType = function guesstimateMimeType() {\n        var extension = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        extension = extension.toLowerCase();\n        if (images.includes(extension)) {\n            return (\n                'image/' +\n                (extension === 'jpg' ? 'jpeg' : extension === 'svg' ? 'svg+xml' : extension)\n            );\n        }\n        if (text$1.includes(extension)) {\n            return 'text/' + extension;\n        }\n\n        return map[extension] || '';\n    };\n\n    var requestDataTransferItems = function requestDataTransferItems(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n            var links = getLinks(dataTransfer);\n            if (links.length && !hasFiles(dataTransfer)) {\n                return resolve(links);\n            }\n            // try to get files from the transfer\n            getFiles(dataTransfer).then(resolve);\n        });\n    };\n\n    /**\n     * Test if datatransfer has files\n     */\n    var hasFiles = function hasFiles(dataTransfer) {\n        if (dataTransfer.files) return dataTransfer.files.length > 0;\n        return false;\n    };\n\n    /**\n     * Extracts files from a DataTransfer object\n     */\n    var getFiles = function getFiles(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // get the transfer items as promises\n            var promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])\n                // only keep file system items (files and directories)\n                .filter(function(item) {\n                    return isFileSystemItem(item);\n                })\n\n                // map each item to promise\n                .map(function(item) {\n                    return getFilesFromItem(item);\n                });\n\n            // if is empty, see if we can extract some info from the files property as a fallback\n            if (!promisedFiles.length) {\n                // TODO: test for directories (should not be allowed)\n                // Use FileReader, problem is that the files property gets lost in the process\n                resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n                return;\n            }\n\n            // done!\n            Promise.all(promisedFiles)\n                .then(function(returnedFileGroups) {\n                    // flatten groups\n                    var files = [];\n                    returnedFileGroups.forEach(function(group) {\n                        files.push.apply(files, group);\n                    });\n\n                    // done (filter out empty files)!\n                    resolve(\n                        files\n                            .filter(function(file) {\n                                return file;\n                            })\n                            .map(function(file) {\n                                if (!file._relativePath)\n                                    file._relativePath = file.webkitRelativePath;\n                                return file;\n                            })\n                    );\n                })\n                .catch(console.error);\n        });\n    };\n\n    var isFileSystemItem = function isFileSystemItem(item) {\n        if (isEntry(item)) {\n            var entry = getAsEntry(item);\n            if (entry) {\n                return entry.isFile || entry.isDirectory;\n            }\n        }\n        return item.kind === 'file';\n    };\n\n    var getFilesFromItem = function getFilesFromItem(item) {\n        return new Promise(function(resolve, reject) {\n            if (isDirectoryEntry(item)) {\n                getFilesInDirectory(getAsEntry(item))\n                    .then(resolve)\n                    .catch(reject);\n                return;\n            }\n\n            resolve([item.getAsFile()]);\n        });\n    };\n\n    var getFilesInDirectory = function getFilesInDirectory(entry) {\n        return new Promise(function(resolve, reject) {\n            var files = [];\n\n            // the total entries to read\n            var dirCounter = 0;\n            var fileCounter = 0;\n\n            var resolveIfDone = function resolveIfDone() {\n                if (fileCounter === 0 && dirCounter === 0) {\n                    resolve(files);\n                }\n            };\n\n            // the recursive function\n            var readEntries = function readEntries(dirEntry) {\n                dirCounter++;\n\n                var directoryReader = dirEntry.createReader();\n\n                // directories are returned in batches, we need to process all batches before we're done\n                var readBatch = function readBatch() {\n                    directoryReader.readEntries(function(entries) {\n                        if (entries.length === 0) {\n                            dirCounter--;\n                            resolveIfDone();\n                            return;\n                        }\n\n                        entries.forEach(function(entry) {\n                            // recursively read more directories\n                            if (entry.isDirectory) {\n                                readEntries(entry);\n                            } else {\n                                // read as file\n                                fileCounter++;\n\n                                entry.file(function(file) {\n                                    var correctedFile = correctMissingFileType(file);\n                                    if (entry.fullPath)\n                                        correctedFile._relativePath = entry.fullPath;\n                                    files.push(correctedFile);\n                                    fileCounter--;\n                                    resolveIfDone();\n                                });\n                            }\n                        });\n\n                        // try to get next batch of files\n                        readBatch();\n                    }, reject);\n                };\n\n                // read first batch of files\n                readBatch();\n            };\n\n            // go!\n            readEntries(entry);\n        });\n    };\n\n    var correctMissingFileType = function correctMissingFileType(file) {\n        if (file.type.length) return file;\n        var date = file.lastModifiedDate;\n        var name = file.name;\n        var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n        if (!type.length) return file;\n        file = file.slice(0, file.size, type);\n        file.name = name;\n        file.lastModifiedDate = date;\n        return file;\n    };\n\n    var isDirectoryEntry = function isDirectoryEntry(item) {\n        return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n    };\n\n    var isEntry = function isEntry(item) {\n        return 'webkitGetAsEntry' in item;\n    };\n\n    var getAsEntry = function getAsEntry(item) {\n        return item.webkitGetAsEntry();\n    };\n\n    /**\n     * Extracts links from a DataTransfer object\n     */\n    var getLinks = function getLinks(dataTransfer) {\n        var links = [];\n        try {\n            // look in meta data property\n            links = getLinksFromTransferMetaData(dataTransfer);\n            if (links.length) {\n                return links;\n            }\n            links = getLinksFromTransferURLData(dataTransfer);\n        } catch (e) {\n            // nope nope nope (probably IE trouble)\n        }\n        return links;\n    };\n\n    var getLinksFromTransferURLData = function getLinksFromTransferURLData(dataTransfer) {\n        var data = dataTransfer.getData('url');\n        if (typeof data === 'string' && data.length) {\n            return [data];\n        }\n        return [];\n    };\n\n    var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(dataTransfer) {\n        var data = dataTransfer.getData('text/html');\n        if (typeof data === 'string' && data.length) {\n            var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n            if (matches) {\n                return [matches[1]];\n            }\n        }\n        return [];\n    };\n\n    var dragNDropObservers = [];\n\n    var eventPosition = function eventPosition(e) {\n        return {\n            pageLeft: e.pageX,\n            pageTop: e.pageY,\n            scopeLeft: e.offsetX || e.layerX,\n            scopeTop: e.offsetY || e.layerY,\n        };\n    };\n\n    var createDragNDropClient = function createDragNDropClient(\n        element,\n        scopeToObserve,\n        filterElement\n    ) {\n        var observer = getDragNDropObserver(scopeToObserve);\n\n        var client = {\n            element: element,\n            filterElement: filterElement,\n            state: null,\n            ondrop: function ondrop() {},\n            onenter: function onenter() {},\n            ondrag: function ondrag() {},\n            onexit: function onexit() {},\n            onload: function onload() {},\n            allowdrop: function allowdrop() {},\n        };\n\n        client.destroy = observer.addListener(client);\n\n        return client;\n    };\n\n    var getDragNDropObserver = function getDragNDropObserver(element) {\n        // see if already exists, if so, return\n        var observer = dragNDropObservers.find(function(item) {\n            return item.element === element;\n        });\n        if (observer) {\n            return observer;\n        }\n\n        // create new observer, does not yet exist for this element\n        var newObserver = createDragNDropObserver(element);\n        dragNDropObservers.push(newObserver);\n        return newObserver;\n    };\n\n    var createDragNDropObserver = function createDragNDropObserver(element) {\n        var clients = [];\n\n        var routes = {\n            dragenter: dragenter,\n            dragover: dragover,\n            dragleave: dragleave,\n            drop: drop,\n        };\n\n        var handlers = {};\n\n        forin(routes, function(event, createHandler) {\n            handlers[event] = createHandler(element, clients);\n            element.addEventListener(event, handlers[event], false);\n        });\n\n        var observer = {\n            element: element,\n            addListener: function addListener(client) {\n                // add as client\n                clients.push(client);\n\n                // return removeListener function\n                return function() {\n                    // remove client\n                    clients.splice(clients.indexOf(client), 1);\n\n                    // if no more clients, clean up observer\n                    if (clients.length === 0) {\n                        dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n                        forin(routes, function(event) {\n                            element.removeEventListener(event, handlers[event], false);\n                        });\n                    }\n                };\n            },\n        };\n\n        return observer;\n    };\n\n    var elementFromPoint = function elementFromPoint(root, point) {\n        if (!('elementFromPoint' in root)) {\n            root = document;\n        }\n        return root.elementFromPoint(point.x, point.y);\n    };\n\n    var isEventTarget = function isEventTarget(e, target) {\n        // get root\n        var root = getRootNode(target);\n\n        // get element at position\n        // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n        var elementAtPosition = elementFromPoint(root, {\n            x: e.pageX - window.pageXOffset,\n            y: e.pageY - window.pageYOffset,\n        });\n\n        // test if target is the element or if one of its children is\n        return elementAtPosition === target || target.contains(elementAtPosition);\n    };\n\n    var initialTarget = null;\n\n    var setDropEffect = function setDropEffect(dataTransfer, effect) {\n        // is in try catch as IE11 will throw error if not\n        try {\n            dataTransfer.dropEffect = effect;\n        } catch (e) {}\n    };\n\n    var dragenter = function dragenter(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            initialTarget = e.target;\n\n            clients.forEach(function(client) {\n                var element = client.element,\n                    onenter = client.onenter;\n\n                if (isEventTarget(e, element)) {\n                    client.state = 'enter';\n\n                    // fire enter event\n                    onenter(eventPosition(e));\n                }\n            });\n        };\n    };\n\n    var dragover = function dragover(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                var overDropTarget = false;\n\n                clients.some(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        onenter = client.onenter,\n                        onexit = client.onexit,\n                        ondrag = client.ondrag,\n                        allowdrop = client.allowdrop;\n\n                    // by default we can drop\n                    setDropEffect(dataTransfer, 'copy');\n\n                    // allow transfer of these items\n                    var allowsTransfer = allowdrop(items);\n\n                    // only used when can be dropped on page\n                    if (!allowsTransfer) {\n                        setDropEffect(dataTransfer, 'none');\n                        return;\n                    }\n\n                    // targetting this client\n                    if (isEventTarget(e, element)) {\n                        overDropTarget = true;\n\n                        // had no previous state, means we are entering this client\n                        if (client.state === null) {\n                            client.state = 'enter';\n                            onenter(eventPosition(e));\n                            return;\n                        }\n\n                        // now over element (no matter if it allows the drop or not)\n                        client.state = 'over';\n\n                        // needs to allow transfer\n                        if (filterElement && !allowsTransfer) {\n                            setDropEffect(dataTransfer, 'none');\n                            return;\n                        }\n\n                        // dragging\n                        ondrag(eventPosition(e));\n                    } else {\n                        // should be over an element to drop\n                        if (filterElement && !overDropTarget) {\n                            setDropEffect(dataTransfer, 'none');\n                        }\n\n                        // might have just left this client?\n                        if (client.state) {\n                            client.state = null;\n                            onexit(eventPosition(e));\n                        }\n                    }\n                });\n            });\n        };\n    };\n\n    var drop = function drop(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                clients.forEach(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        ondrop = client.ondrop,\n                        onexit = client.onexit,\n                        allowdrop = client.allowdrop;\n\n                    client.state = null;\n\n                    // if we're filtering on element we need to be over the element to drop\n                    if (filterElement && !isEventTarget(e, element)) return;\n\n                    // no transfer for this client\n                    if (!allowdrop(items)) return onexit(eventPosition(e));\n\n                    // we can drop these items on this client\n                    ondrop(eventPosition(e), items);\n                });\n            });\n        };\n    };\n\n    var dragleave = function dragleave(root, clients) {\n        return function(e) {\n            if (initialTarget !== e.target) {\n                return;\n            }\n\n            clients.forEach(function(client) {\n                var onexit = client.onexit;\n\n                client.state = null;\n\n                onexit(eventPosition(e));\n            });\n        };\n    };\n\n    var createHopper = function createHopper(scope, validateItems, options) {\n        // is now hopper scope\n        scope.classList.add('filepond--hopper');\n\n        // shortcuts\n        var catchesDropsOnPage = options.catchesDropsOnPage,\n            requiresDropOnElement = options.requiresDropOnElement,\n            _options$filterItems = options.filterItems,\n            filterItems =\n                _options$filterItems === void 0\n                    ? function(items) {\n                          return items;\n                      }\n                    : _options$filterItems;\n\n        // create a dnd client\n        var client = createDragNDropClient(\n            scope,\n            catchesDropsOnPage ? document.documentElement : scope,\n            requiresDropOnElement\n        );\n\n        // current client state\n        var lastState = '';\n        var currentState = '';\n\n        // determines if a file may be dropped\n        client.allowdrop = function(items) {\n            // TODO: if we can, throw error to indicate the items cannot by dropped\n\n            return validateItems(filterItems(items));\n        };\n\n        client.ondrop = function(position, items) {\n            var filteredItems = filterItems(items);\n\n            if (!validateItems(filteredItems)) {\n                api.ondragend(position);\n                return;\n            }\n\n            currentState = 'drag-drop';\n\n            api.onload(filteredItems, position);\n        };\n\n        client.ondrag = function(position) {\n            api.ondrag(position);\n        };\n\n        client.onenter = function(position) {\n            currentState = 'drag-over';\n\n            api.ondragstart(position);\n        };\n\n        client.onexit = function(position) {\n            currentState = 'drag-exit';\n\n            api.ondragend(position);\n        };\n\n        var api = {\n            updateHopperState: function updateHopperState() {\n                if (lastState !== currentState) {\n                    scope.dataset.hopperState = currentState;\n                    lastState = currentState;\n                }\n            },\n            onload: function onload() {},\n            ondragstart: function ondragstart() {},\n            ondrag: function ondrag() {},\n            ondragend: function ondragend() {},\n            destroy: function destroy() {\n                // destroy client\n                client.destroy();\n            },\n        };\n\n        return api;\n    };\n\n    var listening = false;\n    var listeners$1 = [];\n\n    var handlePaste = function handlePaste(e) {\n        // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n        var activeEl = document.activeElement;\n        if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {\n            // test textarea or input is contained in filepond root\n            var inScope = false;\n            var element = activeEl;\n            while (element !== document.body) {\n                if (element.classList.contains('filepond--root')) {\n                    inScope = true;\n                    break;\n                }\n                element = element.parentNode;\n            }\n\n            if (!inScope) return;\n        }\n\n        requestDataTransferItems(e.clipboardData).then(function(files) {\n            // no files received\n            if (!files.length) {\n                return;\n            }\n\n            // notify listeners of received files\n            listeners$1.forEach(function(listener) {\n                return listener(files);\n            });\n        });\n    };\n\n    var listen = function listen(cb) {\n        // can't add twice\n        if (listeners$1.includes(cb)) {\n            return;\n        }\n\n        // add initial listener\n        listeners$1.push(cb);\n\n        // setup paste listener for entire page\n        if (listening) {\n            return;\n        }\n\n        listening = true;\n        document.addEventListener('paste', handlePaste);\n    };\n\n    var unlisten = function unlisten(listener) {\n        arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n        // clean up\n        if (listeners$1.length === 0) {\n            document.removeEventListener('paste', handlePaste);\n            listening = false;\n        }\n    };\n\n    var createPaster = function createPaster() {\n        var cb = function cb(files) {\n            api.onload(files);\n        };\n\n        var api = {\n            destroy: function destroy() {\n                unlisten(cb);\n            },\n            onload: function onload() {},\n        };\n\n        listen(cb);\n\n        return api;\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$d = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.id = 'filepond--assistant-' + props.id;\n        attr(root.element, 'role', 'status');\n        attr(root.element, 'aria-live', 'polite');\n        attr(root.element, 'aria-relevant', 'additions');\n    };\n\n    var addFilesNotificationTimeout = null;\n    var notificationClearTimeout = null;\n\n    var filenames = [];\n\n    var assist = function assist(root, message) {\n        root.element.textContent = message;\n    };\n\n    var clear$1 = function clear(root) {\n        root.element.textContent = '';\n    };\n\n    var listModified = function listModified(root, filename, label) {\n        var total = root.query('GET_TOTAL_ITEMS');\n        assist(\n            root,\n            label +\n                ' ' +\n                filename +\n                ', ' +\n                total +\n                ' ' +\n                (total === 1\n                    ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n                    : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n        );\n\n        // clear group after set amount of time so the status is not read twice\n        clearTimeout(notificationClearTimeout);\n        notificationClearTimeout = setTimeout(function() {\n            clear$1(root);\n        }, 1500);\n    };\n\n    var isUsingFilePond = function isUsingFilePond(root) {\n        return root.element.parentNode.contains(document.activeElement);\n    };\n\n    var itemAdded = function itemAdded(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        root.element.textContent = '';\n        var item = root.query('GET_ITEM', action.id);\n        filenames.push(item.filename);\n\n        clearTimeout(addFilesNotificationTimeout);\n        addFilesNotificationTimeout = setTimeout(function() {\n            listModified(root, filenames.join(', '), root.query('GET_LABEL_FILE_ADDED'));\n\n            filenames.length = 0;\n        }, 750);\n    };\n\n    var itemRemoved = function itemRemoved(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        var item = action.item;\n        listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n    };\n\n    var itemProcessed = function itemProcessed(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemError = function itemError(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n    };\n\n    var assistant = createView({\n        create: create$d,\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: itemAdded,\n            DID_REMOVE_ITEM: itemRemoved,\n            DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n            DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n            DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n            DID_THROW_ITEM_REMOVE_ERROR: itemError,\n            DID_THROW_ITEM_LOAD_ERROR: itemError,\n            DID_THROW_ITEM_INVALID: itemError,\n            DID_THROW_ITEM_PROCESSING_ERROR: itemError,\n        }),\n\n        tag: 'span',\n        name: 'assistant',\n    });\n\n    var toCamels = function toCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n            return sub.charAt(1).toUpperCase();\n        });\n    };\n\n    var debounce = function debounce(func) {\n        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n        var immidiateOnly =\n            arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var last = Date.now();\n        var timeout = null;\n\n        return function() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            clearTimeout(timeout);\n\n            var dist = Date.now() - last;\n\n            var fn = function fn() {\n                last = Date.now();\n                func.apply(void 0, args);\n            };\n\n            if (dist < interval) {\n                // we need to delay by the difference between interval and dist\n                // for example: if distance is 10 ms and interval is 16 ms,\n                // we need to wait an additional 6ms before calling the function)\n                if (!immidiateOnly) {\n                    timeout = setTimeout(fn, interval - dist);\n                }\n            } else {\n                // go!\n                fn();\n            }\n        };\n    };\n\n    var MAX_FILES_LIMIT = 1000000;\n\n    var prevent = function prevent(e) {\n        return e.preventDefault();\n    };\n\n    var create$e = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // Add id\n        var id = root.query('GET_ID');\n        if (id) {\n            root.element.id = id;\n        }\n\n        // Add className\n        var className = root.query('GET_CLASS_NAME');\n        if (className) {\n            className\n                .split(' ')\n                .filter(function(name) {\n                    return name.length;\n                })\n                .forEach(function(name) {\n                    root.element.classList.add(name);\n                });\n        }\n\n        // Field label\n        root.ref.label = root.appendChildView(\n            root.createChildView(\n                dropLabel,\n                Object.assign({}, props, {\n                    translateY: null,\n                    caption: root.query('GET_LABEL_IDLE'),\n                })\n            )\n        );\n\n        // List of items\n        root.ref.list = root.appendChildView(\n            root.createChildView(listScroller, { translateY: null })\n        );\n\n        // Background panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'panel-root' }));\n\n        // Assistant notifies assistive tech when content changes\n        root.ref.assistant = root.appendChildView(\n            root.createChildView(assistant, Object.assign({}, props))\n        );\n\n        // Data\n        root.ref.data = root.appendChildView(root.createChildView(data, Object.assign({}, props)));\n\n        // Measure (tests if fixed height was set)\n        // DOCTYPE needs to be set for this to work\n        root.ref.measure = createElement$1('div');\n        root.ref.measure.style.height = '100%';\n        root.element.appendChild(root.ref.measure);\n\n        // information on the root height or fixed height status\n        root.ref.bounds = null;\n\n        // apply initial style properties\n        root.query('GET_STYLES')\n            .filter(function(style) {\n                return !isEmpty(style.value);\n            })\n            .map(function(_ref2) {\n                var name = _ref2.name,\n                    value = _ref2.value;\n                root.element.dataset[name] = value;\n            });\n\n        // determine if width changed\n        root.ref.widthPrevious = null;\n        root.ref.widthUpdated = debounce(function() {\n            root.ref.updateHistory = [];\n            root.dispatch('DID_RESIZE_ROOT');\n        }, 250);\n\n        // history of updates\n        root.ref.previousAspectRatio = null;\n        root.ref.updateHistory = [];\n\n        // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n        var canHover = window.matchMedia('(pointer: fine) and (hover: hover)').matches;\n        var hasPointerEvents = 'PointerEvent' in window;\n        if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n            root.element.addEventListener('touchmove', prevent, { passive: false });\n            root.element.addEventListener('gesturestart', prevent);\n        }\n\n        // add credits\n        var credits = root.query('GET_CREDITS');\n        var hasCredits = credits.length === 2;\n        if (hasCredits) {\n            var frag = document.createElement('a');\n            frag.className = 'filepond--credits';\n            frag.setAttribute('aria-hidden', 'true');\n            frag.href = credits[0];\n            frag.tabindex = -1;\n            frag.target = '_blank';\n            frag.rel = 'noopener noreferrer';\n            frag.textContent = credits[1];\n            root.element.appendChild(frag);\n            root.ref.credits = frag;\n        }\n    };\n\n    var write$9 = function write(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props,\n            actions = _ref3.actions;\n        // route actions\n        route$5({ root: root, props: props, actions: actions });\n\n        // apply style properties\n        actions\n            .filter(function(action) {\n                return /^DID_SET_STYLE_/.test(action.type);\n            })\n            .filter(function(action) {\n                return !isEmpty(action.data.value);\n            })\n            .map(function(_ref4) {\n                var type = _ref4.type,\n                    data = _ref4.data;\n                var name = toCamels(type.substr(8).toLowerCase(), '_');\n                root.element.dataset[name] = data.value;\n                root.invalidateLayout();\n            });\n\n        if (root.rect.element.hidden) return;\n\n        if (root.rect.element.width !== root.ref.widthPrevious) {\n            root.ref.widthPrevious = root.rect.element.width;\n            root.ref.widthUpdated();\n        }\n\n        // get box bounds, we do this only once\n        var bounds = root.ref.bounds;\n        if (!bounds) {\n            bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n            // destroy measure element\n            root.element.removeChild(root.ref.measure);\n            root.ref.measure = null;\n        }\n\n        // get quick references to various high level parts of the upload tool\n        var _root$ref = root.ref,\n            hopper = _root$ref.hopper,\n            label = _root$ref.label,\n            list = _root$ref.list,\n            panel = _root$ref.panel;\n\n        // sets correct state to hopper scope\n        if (hopper) {\n            hopper.updateHopperState();\n        }\n\n        // bool to indicate if we're full or not\n        var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = isMultiItem ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT : 1;\n        var atMaxCapacity = totalItems === maxItems;\n\n        // action used to add item\n        var addAction = actions.find(function(action) {\n            return action.type === 'DID_ADD_ITEM';\n        });\n\n        // if reached max capacity and we've just reached it\n        if (atMaxCapacity && addAction) {\n            // get interaction type\n            var interactionMethod = addAction.data.interactionMethod;\n\n            // hide label\n            label.opacity = 0;\n\n            if (isMultiItem) {\n                label.translateY = -40;\n            } else {\n                if (interactionMethod === InteractionMethod.API) {\n                    label.translateX = 40;\n                } else if (interactionMethod === InteractionMethod.BROWSE) {\n                    label.translateY = 40;\n                } else {\n                    label.translateY = 30;\n                }\n            }\n        } else if (!atMaxCapacity) {\n            label.opacity = 1;\n            label.translateX = 0;\n            label.translateY = 0;\n        }\n\n        var listItemMargin = calculateListItemMargin(root);\n\n        var listHeight = calculateListHeight(root);\n\n        var labelHeight = label.rect.element.height;\n        var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n        var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n        var listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n        var visualHeight =\n            currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n        var boundsHeight =\n            currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n        // link list to label bottom position\n        list.translateY =\n            Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n\n        if (aspectRatio) {\n            // fixed aspect ratio\n\n            // calculate height based on width\n            var width = root.rect.element.width;\n            var height = width * aspectRatio;\n\n            // clear history if aspect ratio has changed\n            if (aspectRatio !== root.ref.previousAspectRatio) {\n                root.ref.previousAspectRatio = aspectRatio;\n                root.ref.updateHistory = [];\n            }\n\n            // remember this width\n            var history = root.ref.updateHistory;\n            history.push(width);\n\n            var MAX_BOUNCES = 2;\n            if (history.length > MAX_BOUNCES * 2) {\n                var l = history.length;\n                var bottom = l - 10;\n                var bounces = 0;\n                for (var i = l; i >= bottom; i--) {\n                    if (history[i] === history[i - 2]) {\n                        bounces++;\n                    }\n\n                    if (bounces >= MAX_BOUNCES) {\n                        // dont adjust height\n                        return;\n                    }\n                }\n            }\n\n            // fix height of panel so it adheres to aspect ratio\n            panel.scalable = false;\n            panel.height = height;\n\n            // available height for list\n            var listAvailableHeight =\n                // the height of the panel minus the label height\n                height -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            if (listHeight.visual > listAvailableHeight) {\n                list.overflow = listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = height;\n        } else if (bounds.fixedHeight) {\n            // fixed height\n\n            // fix height of panel\n            panel.scalable = false;\n\n            // available height for list\n            var _listAvailableHeight =\n                // the height of the panel minus the label height\n                bounds.fixedHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height\n            if (listHeight.visual > _listAvailableHeight) {\n                list.overflow = _listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // no need to set container bounds as these are handles by CSS fixed height\n        } else if (bounds.cappedHeight) {\n            // max-height\n\n            // not a fixed height panel\n            var isCappedHeight = visualHeight >= bounds.cappedHeight;\n            var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n            panel.scalable = true;\n            panel.height = isCappedHeight\n                ? panelHeight\n                : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n            // available height for list\n            var _listAvailableHeight2 =\n                // the height of the panel minus the label height\n                panelHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height (if is overflowing)\n            if (visualHeight > bounds.cappedHeight && listHeight.visual > _listAvailableHeight2) {\n                list.overflow = _listAvailableHeight2;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.min(\n                bounds.cappedHeight,\n                boundsHeight - listItemMargin.top - listItemMargin.bottom\n            );\n        } else {\n            // flexible height\n\n            // not a fixed height panel\n            var itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n            panel.scalable = true;\n            panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n        }\n\n        // move credits to bottom\n        if (root.ref.credits && panel.heightCurrent)\n            root.ref.credits.style.transform = 'translateY(' + panel.heightCurrent + 'px)';\n    };\n\n    var calculateListItemMargin = function calculateListItemMargin(root) {\n        var item = root.ref.list.childViews[0].childViews[0];\n        return item\n            ? {\n                  top: item.rect.element.marginTop,\n                  bottom: item.rect.element.marginBottom,\n              }\n            : {\n                  top: 0,\n                  bottom: 0,\n              };\n    };\n\n    var calculateListHeight = function calculateListHeight(root) {\n        var visual = 0;\n        var bounds = 0;\n\n        // get file list reference\n        var scrollList = root.ref.list;\n        var itemList = scrollList.childViews[0];\n        var visibleChildren = itemList.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // no children, done!\n        if (children.length === 0) return { visual: visual, bounds: bounds };\n\n        var horizontalSpace = itemList.rect.element.width;\n        var dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n\n        var childRect = children[0].rect.element;\n\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n\n        var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n        var removedItem = children.find(function(child) {\n            return child.markedForRemoval && child.opacity < 0.45;\n        })\n            ? -1\n            : 0;\n        var verticalItemCount = children.length + newItem + removedItem;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            children.forEach(function(item) {\n                var height = item.rect.element.height + itemVerticalMargin;\n                bounds += height;\n                visual += height * item.opacity;\n            });\n        }\n        // grid\n        else {\n            bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n            visual = bounds;\n        }\n\n        return { visual: visual, bounds: bounds };\n    };\n\n    var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(root) {\n        var height = root.ref.measureHeight || null;\n        var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n        var fixedHeight = height === 0 ? null : height;\n\n        return {\n            cappedHeight: cappedHeight,\n            fixedHeight: fixedHeight,\n        };\n    };\n\n    var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n        var allowReplace = root.query('GET_ALLOW_REPLACE');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = root.query('GET_MAX_FILES');\n\n        // total amount of items being dragged\n        var totalBrowseItems = items.length;\n\n        // if does not allow multiple items and dragging more than one item\n        if (!allowMultiple && totalBrowseItems > 1) {\n            return true;\n        }\n\n        // limit max items to one if not allowed to drop multiple items\n        maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;\n\n        // no more room?\n        var hasMaxItems = isInt(maxItems);\n        if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n            root.dispatch('DID_THROW_MAX_FILES', {\n                source: items,\n                error: createResponse('warning', 0, 'Max files'),\n            });\n\n            return true;\n        }\n\n        return false;\n    };\n\n    var getDragIndex = function getDragIndex(list, children, position) {\n        var itemList = list.childViews[0];\n        return getItemIndexByPosition(itemList, children, {\n            left: position.scopeLeft - itemList.rect.element.left,\n            top:\n                position.scopeTop -\n                (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop),\n        });\n    };\n\n    /**\n     * Enable or disable file drop functionality\n     */\n    var toggleDrop = function toggleDrop(root) {\n        var isAllowed = root.query('GET_ALLOW_DROP');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.hopper) {\n            var hopper = createHopper(\n                root.element,\n                function(items) {\n                    // allow quick validation of dropped items\n                    var beforeDropFile =\n                        root.query('GET_BEFORE_DROP_FILE') ||\n                        function() {\n                            return true;\n                        };\n\n                    // all items should be validated by all filters as valid\n                    var dropValidation = root.query('GET_DROP_VALIDATION');\n                    return dropValidation\n                        ? items.every(function(item) {\n                              return (\n                                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                                      query: root.query,\n                                  }).every(function(result) {\n                                      return result === true;\n                                  }) && beforeDropFile(item)\n                              );\n                          })\n                        : true;\n                },\n                {\n                    filterItems: function filterItems(items) {\n                        var ignoredFiles = root.query('GET_IGNORED_FILES');\n                        return items.filter(function(item) {\n                            if (isFile(item)) {\n                                return !ignoredFiles.includes(item.name.toLowerCase());\n                            }\n                            return true;\n                        });\n                    },\n                    catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n                    requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT'),\n                }\n            );\n\n            hopper.onload = function(items, position) {\n                // get item children elements and sort based on list sort\n                var list = root.ref.list.childViews[0];\n                var visibleChildren = list.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = root\n                    .query('GET_ACTIVE_ITEMS')\n                    .map(function(item) {\n                        return visibleChildren.find(function(child) {\n                            return child.id === item.id;\n                        });\n                    })\n                    .filter(function(item) {\n                        return item;\n                    });\n\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // go\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: getDragIndex(root.ref.list, children, position),\n                        interactionMethod: InteractionMethod.DROP,\n                    });\n                });\n\n                root.dispatch('DID_DROP', { position: position });\n\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            hopper.ondragstart = function(position) {\n                root.dispatch('DID_START_DRAG', { position: position });\n            };\n\n            hopper.ondrag = debounce(function(position) {\n                root.dispatch('DID_DRAG', { position: position });\n            });\n\n            hopper.ondragend = function(position) {\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            root.ref.hopper = hopper;\n\n            root.ref.drip = root.appendChildView(root.createChildView(drip));\n        } else if (!enabled && root.ref.hopper) {\n            root.ref.hopper.destroy();\n            root.ref.hopper = null;\n            root.removeChildView(root.ref.drip);\n        }\n    };\n\n    /**\n     * Enable or disable browse functionality\n     */\n    var toggleBrowse = function toggleBrowse(root, props) {\n        var isAllowed = root.query('GET_ALLOW_BROWSE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.browser) {\n            root.ref.browser = root.appendChildView(\n                root.createChildView(\n                    browser,\n                    Object.assign({}, props, {\n                        onload: function onload(items) {\n                            applyFilterChain('ADD_ITEMS', items, {\n                                dispatch: root.dispatch,\n                            }).then(function(queue) {\n                                // these files don't fit so stop here\n                                if (exceedsMaxFiles(root, queue)) return false;\n\n                                // add items!\n                                root.dispatch('ADD_ITEMS', {\n                                    items: queue,\n                                    index: -1,\n                                    interactionMethod: InteractionMethod.BROWSE,\n                                });\n                            });\n                        },\n                    })\n                ),\n\n                0\n            );\n        } else if (!enabled && root.ref.browser) {\n            root.removeChildView(root.ref.browser);\n            root.ref.browser = null;\n        }\n    };\n\n    /**\n     * Enable or disable paste functionality\n     */\n    var togglePaste = function togglePaste(root) {\n        var isAllowed = root.query('GET_ALLOW_PASTE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.paster) {\n            root.ref.paster = createPaster();\n            root.ref.paster.onload = function(items) {\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // add items!\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: -1,\n                        interactionMethod: InteractionMethod.PASTE,\n                    });\n                });\n            };\n        } else if (!enabled && root.ref.paster) {\n            root.ref.paster.destroy();\n            root.ref.paster = null;\n        }\n    };\n\n    /**\n     * Route actions\n     */\n    var route$5 = createRoute({\n        DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n            var root = _ref5.root,\n                props = _ref5.props;\n            toggleBrowse(root, props);\n        },\n        DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n            var root = _ref6.root;\n            toggleDrop(root);\n        },\n        DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n            var root = _ref7.root;\n            togglePaste(root);\n        },\n        DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n            var root = _ref8.root,\n                props = _ref8.props;\n            toggleDrop(root);\n            togglePaste(root);\n            toggleBrowse(root, props);\n            var isDisabled = root.query('GET_DISABLED');\n            if (isDisabled) {\n                root.element.dataset.disabled = 'disabled';\n            } else {\n                // delete root.element.dataset.disabled; <= this does not work on iOS 10\n                root.element.removeAttribute('data-disabled');\n            }\n        },\n    });\n\n    var root = createView({\n        name: 'root',\n        read: function read(_ref9) {\n            var root = _ref9.root;\n            if (root.ref.measure) {\n                root.ref.measureHeight = root.ref.measure.offsetHeight;\n            }\n        },\n        create: create$e,\n        write: write$9,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            if (root.ref.paster) {\n                root.ref.paster.destroy();\n            }\n            if (root.ref.hopper) {\n                root.ref.hopper.destroy();\n            }\n            root.element.removeEventListener('touchmove', prevent);\n            root.element.removeEventListener('gesturestart', prevent);\n        },\n        mixins: {\n            styles: ['height'],\n        },\n    });\n\n    // creates the app\n    var createApp = function createApp() {\n        var initialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // let element\n        var originalElement = null;\n\n        // get default options\n        var defaultOptions = getOptions();\n\n        // create the data store, this will contain all our app info\n        var store = createStore(\n            // initial state (should be serializable)\n            createInitialState(defaultOptions),\n\n            // queries\n            [queries, createOptionQueries(defaultOptions)],\n\n            // action handlers\n            [actions, createOptionActions(defaultOptions)]\n        );\n\n        // set initial options\n        store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n        // kick thread if visibility changes\n        var visibilityHandler = function visibilityHandler() {\n            if (document.hidden) return;\n            store.dispatch('KICK');\n        };\n        document.addEventListener('visibilitychange', visibilityHandler);\n\n        // re-render on window resize start and finish\n        var resizeDoneTimer = null;\n        var isResizing = false;\n        var isResizingHorizontally = false;\n        var initialWindowWidth = null;\n        var currentWindowWidth = null;\n        var resizeHandler = function resizeHandler() {\n            if (!isResizing) {\n                isResizing = true;\n            }\n            clearTimeout(resizeDoneTimer);\n            resizeDoneTimer = setTimeout(function() {\n                isResizing = false;\n                initialWindowWidth = null;\n                currentWindowWidth = null;\n                if (isResizingHorizontally) {\n                    isResizingHorizontally = false;\n                    store.dispatch('DID_STOP_RESIZE');\n                }\n            }, 500);\n        };\n        window.addEventListener('resize', resizeHandler);\n\n        // render initial view\n        var view = root(store, { id: getUniqueId() });\n\n        //\n        // PRIVATE API -------------------------------------------------------------------------------------\n        //\n        var isResting = false;\n        var isHidden = false;\n\n        var readWriteApi = {\n            // necessary for update loop\n\n            /**\n             * Reads from dom (never call manually)\n             * @private\n             */\n            _read: function _read() {\n                // test if we're resizing horizontally\n                // TODO: see if we can optimize this by measuring root rect\n                if (isResizing) {\n                    currentWindowWidth = window.innerWidth;\n                    if (!initialWindowWidth) {\n                        initialWindowWidth = currentWindowWidth;\n                    }\n\n                    if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                        store.dispatch('DID_START_RESIZE');\n                        isResizingHorizontally = true;\n                    }\n                }\n\n                if (isHidden && isResting) {\n                    // test if is no longer hidden\n                    isResting = view.element.offsetParent === null;\n                }\n\n                // if resting, no need to read as numbers will still all be correct\n                if (isResting) return;\n\n                // read view data\n                view._read();\n\n                // if is hidden we need to know so we exit rest mode when revealed\n                isHidden = view.rect.element.hidden;\n            },\n\n            /**\n             * Writes to dom (never call manually)\n             * @private\n             */\n            _write: function _write(ts) {\n                // get all actions from store\n                var actions = store\n                    .processActionQueue()\n\n                    // filter out set actions (these will automatically trigger DID_SET)\n                    .filter(function(action) {\n                        return !/^SET_/.test(action.type);\n                    });\n\n                // if was idling and no actions stop here\n                if (isResting && !actions.length) return;\n\n                // some actions might trigger events\n                routeActionsToEvents(actions);\n\n                // update the view\n                isResting = view._write(ts, actions, isResizingHorizontally);\n\n                // will clean up all archived items\n                removeReleasedItems(store.query('GET_ITEMS'));\n\n                // now idling\n                if (isResting) {\n                    store.processDispatchQueue();\n                }\n            },\n        };\n\n        //\n        // EXPOSE EVENTS -------------------------------------------------------------------------------------\n        //\n        var createEvent = function createEvent(name) {\n            return function(data) {\n                // create default event\n                var event = {\n                    type: name,\n                };\n\n                // no data to add\n                if (!data) {\n                    return event;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('error')) {\n                    event.error = data.error ? Object.assign({}, data.error) : null;\n                }\n\n                if (data.status) {\n                    event.status = Object.assign({}, data.status);\n                }\n\n                if (data.file) {\n                    event.output = data.file;\n                }\n\n                // only source is available, else add item if possible\n                if (data.source) {\n                    event.file = data.source;\n                } else if (data.item || data.id) {\n                    var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n                    event.file = item ? createItemAPI(item) : null;\n                }\n\n                // map all items in a possible items array\n                if (data.items) {\n                    event.items = data.items.map(createItemAPI);\n                }\n\n                // if this is a progress event add the progress amount\n                if (/progress/.test(name)) {\n                    event.progress = data.progress;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n                    event.origin = data.origin;\n                    event.target = data.target;\n                }\n\n                return event;\n            };\n        };\n\n        var eventRoutes = {\n            DID_DESTROY: createEvent('destroy'),\n\n            DID_INIT: createEvent('init'),\n\n            DID_THROW_MAX_FILES: createEvent('warning'),\n\n            DID_INIT_ITEM: createEvent('initfile'),\n            DID_START_ITEM_LOAD: createEvent('addfilestart'),\n            DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n            DID_LOAD_ITEM: createEvent('addfile'),\n\n            DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_REMOVE_ERROR: [createEvent('error'), createEvent('removefile')],\n\n            DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n            DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n            DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n            DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n            DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n            DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n            DID_THROW_ITEM_PROCESSING_ERROR: [createEvent('error'), createEvent('processfile')],\n\n            DID_REMOVE_ITEM: createEvent('removefile'),\n\n            DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n            DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n            DID_REORDER_ITEMS: createEvent('reorderfiles'),\n        };\n\n        var exposeEvent = function exposeEvent(event) {\n            // create event object to be dispatched\n            var detail = Object.assign({ pond: exports }, event);\n            delete detail.type;\n            view.element.dispatchEvent(\n                new CustomEvent('FilePond:' + event.type, {\n                    // event info\n                    detail: detail,\n\n                    // event behaviour\n                    bubbles: true,\n                    cancelable: true,\n                    composed: true, // triggers listeners outside of shadow root\n                })\n            );\n\n            // event object to params used for `on()` event handlers and callbacks `oninit()`\n            var params = [];\n\n            // if is possible error event, make it the first param\n            if (event.hasOwnProperty('error')) {\n                params.push(event.error);\n            }\n\n            // file is always section\n            if (event.hasOwnProperty('file')) {\n                params.push(event.file);\n            }\n\n            // append other props\n            var filtered = ['type', 'error', 'file'];\n            Object.keys(event)\n                .filter(function(key) {\n                    return !filtered.includes(key);\n                })\n                .forEach(function(key) {\n                    return params.push(event[key]);\n                });\n\n            // on(type, () => { })\n            exports.fire.apply(exports, [event.type].concat(params));\n\n            // oninit = () => {}\n            var handler = store.query('GET_ON' + event.type.toUpperCase());\n            if (handler) {\n                handler.apply(void 0, params);\n            }\n        };\n\n        var routeActionsToEvents = function routeActionsToEvents(actions) {\n            if (!actions.length) return;\n            actions\n                .filter(function(action) {\n                    return eventRoutes[action.type];\n                })\n                .forEach(function(action) {\n                    var routes = eventRoutes[action.type];\n                    (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n                        // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                        if (action.type === 'DID_INIT_ITEM') {\n                            exposeEvent(route(action.data));\n                        } else {\n                            setTimeout(function() {\n                                exposeEvent(route(action.data));\n                            }, 0);\n                        }\n                    });\n                });\n        };\n\n        //\n        // PUBLIC API -------------------------------------------------------------------------------------\n        //\n        var setOptions = function setOptions(options) {\n            return store.dispatch('SET_OPTIONS', { options: options });\n        };\n\n        var getFile = function getFile(query) {\n            return store.query('GET_ACTIVE_ITEM', query);\n        };\n\n        var prepareFile = function prepareFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PREPARE', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var addFile = function addFile(source) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new Promise(function(resolve, reject) {\n                addFiles([{ source: source, options: options }], { index: options.index })\n                    .then(function(items) {\n                        return resolve(items && items[0]);\n                    })\n                    .catch(reject);\n            });\n        };\n\n        var isFilePondFile = function isFilePondFile(obj) {\n            return obj.file && obj.id;\n        };\n\n        var removeFile = function removeFile(query, options) {\n            // if only passed options\n            if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n                options = query;\n                query = undefined;\n            }\n\n            // request item removal\n            store.dispatch('REMOVE_ITEM', Object.assign({}, options, { query: query }));\n\n            // see if item has been removed\n            return store.query('GET_ACTIVE_ITEM', query) === null;\n        };\n\n        var addFiles = function addFiles() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            return new Promise(function(resolve, reject) {\n                var sources = [];\n                var options = {};\n\n                // user passed a sources array\n                if (isArray(args[0])) {\n                    sources.push.apply(sources, args[0]);\n                    Object.assign(options, args[1] || {});\n                } else {\n                    // user passed sources as arguments, last one might be options object\n                    var lastArgument = args[args.length - 1];\n                    if (typeof lastArgument === 'object' && !(lastArgument instanceof Blob)) {\n                        Object.assign(options, args.pop());\n                    }\n\n                    // add rest to sources\n                    sources.push.apply(sources, args);\n                }\n\n                store.dispatch('ADD_ITEMS', {\n                    items: sources,\n                    index: options.index,\n                    interactionMethod: InteractionMethod.API,\n                    success: resolve,\n                    failure: reject,\n                });\n            });\n        };\n\n        var getFiles = function getFiles() {\n            return store.query('GET_ACTIVE_ITEMS');\n        };\n\n        var processFile = function processFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PROCESSING', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var prepareFiles = function prepareFiles() {\n            for (\n                var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n                _key2 < _len2;\n                _key2++\n            ) {\n                args[_key2] = arguments[_key2];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            var items = queries.length ? queries : getFiles();\n            return Promise.all(items.map(prepareFile));\n        };\n\n        var processFiles = function processFiles() {\n            for (\n                var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n                _key3 < _len3;\n                _key3++\n            ) {\n                args[_key3] = arguments[_key3];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            if (!queries.length) {\n                var files = getFiles().filter(function(item) {\n                    return (\n                        !(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) &&\n                        item.status !== ItemStatus.PROCESSING &&\n                        item.status !== ItemStatus.PROCESSING_COMPLETE &&\n                        item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n                    );\n                });\n\n                return Promise.all(files.map(processFile));\n            }\n            return Promise.all(queries.map(processFile));\n        };\n\n        var removeFiles = function removeFiles() {\n            for (\n                var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n                _key4 < _len4;\n                _key4++\n            ) {\n                args[_key4] = arguments[_key4];\n            }\n\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n\n            var options;\n            if (typeof queries[queries.length - 1] === 'object') {\n                options = queries.pop();\n            } else if (Array.isArray(args[0])) {\n                options = args[1];\n            }\n\n            var files = getFiles();\n\n            if (!queries.length)\n                return Promise.all(\n                    files.map(function(file) {\n                        return removeFile(file, options);\n                    })\n                );\n\n            // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n            var mappedQueries = queries\n                .map(function(query) {\n                    return isNumber(query) ? (files[query] ? files[query].id : null) : query;\n                })\n                .filter(function(query) {\n                    return query;\n                });\n\n            return mappedQueries.map(function(q) {\n                return removeFile(q, options);\n            });\n        };\n\n        var exports = Object.assign(\n            {},\n\n            on(),\n            {},\n\n            readWriteApi,\n            {},\n\n            createOptionAPI(store, defaultOptions),\n            {\n                /**\n                 * Override options defined in options object\n                 * @param options\n                 */\n                setOptions: setOptions,\n\n                /**\n                 * Load the given file\n                 * @param source - the source of the file (either a File, base64 data uri or url)\n                 * @param options - object, { index: 0 }\n                 */\n                addFile: addFile,\n\n                /**\n                 * Load the given files\n                 * @param sources - the sources of the files to load\n                 * @param options - object, { index: 0 }\n                 */\n                addFiles: addFiles,\n\n                /**\n                 * Returns the file objects matching the given query\n                 * @param query { string, number, null }\n                 */\n                getFile: getFile,\n\n                /**\n                 * Upload file with given name\n                 * @param query { string, number, null  }\n                 */\n                processFile: processFile,\n\n                /**\n                 * Request prepare output for file with given name\n                 * @param query { string, number, null  }\n                 */\n                prepareFile: prepareFile,\n\n                /**\n                 * Removes a file by its name\n                 * @param query { string, number, null  }\n                 */\n                removeFile: removeFile,\n\n                /**\n                 * Moves a file to a new location in the files list\n                 */\n                moveFile: function moveFile(query, index) {\n                    return store.dispatch('MOVE_ITEM', { query: query, index: index });\n                },\n\n                /**\n                 * Returns all files (wrapped in public api)\n                 */\n                getFiles: getFiles,\n\n                /**\n                 * Starts uploading all files\n                 */\n                processFiles: processFiles,\n\n                /**\n                 * Clears all files from the files list\n                 */\n                removeFiles: removeFiles,\n\n                /**\n                 * Starts preparing output of all files\n                 */\n                prepareFiles: prepareFiles,\n\n                /**\n                 * Sort list of files\n                 */\n                sort: function sort(compare) {\n                    return store.dispatch('SORT', { compare: compare });\n                },\n\n                /**\n                 * Browse the file system for a file\n                 */\n                browse: function browse() {\n                    // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n                    var input = view.element.querySelector('input[type=file]');\n                    if (input) {\n                        input.click();\n                    }\n                },\n\n                /**\n                 * Destroys the app\n                 */\n                destroy: function destroy() {\n                    // request destruction\n                    exports.fire('destroy', view.element);\n\n                    // stop active processes (file uploads, fetches, stuff like that)\n                    // loop over items and depending on states call abort for ongoing processes\n                    store.dispatch('ABORT_ALL');\n\n                    // destroy view\n                    view._destroy();\n\n                    // stop listening to resize\n                    window.removeEventListener('resize', resizeHandler);\n\n                    // stop listening to the visiblitychange event\n                    document.removeEventListener('visibilitychange', visibilityHandler);\n\n                    // dispatch destroy\n                    store.dispatch('DID_DESTROY');\n                },\n\n                /**\n                 * Inserts the plugin before the target element\n                 */\n                insertBefore: function insertBefore$1(element) {\n                    return insertBefore(view.element, element);\n                },\n\n                /**\n                 * Inserts the plugin after the target element\n                 */\n                insertAfter: function insertAfter$1(element) {\n                    return insertAfter(view.element, element);\n                },\n\n                /**\n                 * Appends the plugin to the target element\n                 */\n                appendTo: function appendTo(element) {\n                    return element.appendChild(view.element);\n                },\n\n                /**\n                 * Replaces an element with the app\n                 */\n                replaceElement: function replaceElement(element) {\n                    // insert the app before the element\n                    insertBefore(view.element, element);\n\n                    // remove the original element\n                    element.parentNode.removeChild(element);\n\n                    // remember original element\n                    originalElement = element;\n                },\n\n                /**\n                 * Restores the original element\n                 */\n                restoreElement: function restoreElement() {\n                    if (!originalElement) {\n                        return; // no element to restore\n                    }\n\n                    // restore original element\n                    insertAfter(originalElement, view.element);\n\n                    // remove our element\n                    view.element.parentNode.removeChild(view.element);\n\n                    // remove reference\n                    originalElement = null;\n                },\n\n                /**\n                 * Returns true if the app root is attached to given element\n                 * @param element\n                 */\n                isAttachedTo: function isAttachedTo(element) {\n                    return view.element === element || originalElement === element;\n                },\n\n                /**\n                 * Returns the root element\n                 */\n                element: {\n                    get: function get() {\n                        return view.element;\n                    },\n                },\n\n                /**\n                 * Returns the current pond status\n                 */\n                status: {\n                    get: function get() {\n                        return store.query('GET_STATUS');\n                    },\n                },\n            }\n        );\n\n        // Done!\n        store.dispatch('DID_INIT');\n\n        // create actual api object\n        return createObject(exports);\n    };\n\n    var createAppObject = function createAppObject() {\n        var customOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // default options\n        var defaultOptions = {};\n        forin(getOptions(), function(key, value) {\n            defaultOptions[key] = value[0];\n        });\n\n        // set app options\n        var app = createApp(\n            Object.assign(\n                {},\n\n                defaultOptions,\n                {},\n\n                customOptions\n            )\n        );\n\n        // return the plugin instance\n        return app;\n    };\n\n    var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n        return string.charAt(0).toLowerCase() + string.slice(1);\n    };\n\n    var attributeNameToPropertyName = function attributeNameToPropertyName(attributeName) {\n        return toCamels(attributeName.replace(/^data-/, ''));\n    };\n\n    var mapObject = function mapObject(object, propertyMap) {\n        // remove unwanted\n        forin(propertyMap, function(selector, mapping) {\n            forin(object, function(property, value) {\n                // create regexp shortcut\n                var selectorRegExp = new RegExp(selector);\n\n                // tests if\n                var matches = selectorRegExp.test(property);\n\n                // no match, skip\n                if (!matches) {\n                    return;\n                }\n\n                // if there's a mapping, the original property is always removed\n                delete object[property];\n\n                // should only remove, we done!\n                if (mapping === false) {\n                    return;\n                }\n\n                // move value to new property\n                if (isString(mapping)) {\n                    object[mapping] = value;\n                    return;\n                }\n\n                // move to group\n                var group = mapping.group;\n                if (isObject(mapping) && !object[group]) {\n                    object[group] = {};\n                }\n\n                object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ''))] = value;\n            });\n\n            // do submapping\n            if (mapping.mapping) {\n                mapObject(object[mapping.group], mapping.mapping);\n            }\n        });\n    };\n\n    var getAttributesAsObject = function getAttributesAsObject(node) {\n        var attributeMapping =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        // turn attributes into object\n        var attributes = [];\n        forin(node.attributes, function(index) {\n            attributes.push(node.attributes[index]);\n        });\n\n        var output = attributes\n            .filter(function(attribute) {\n                return attribute.name;\n            })\n            .reduce(function(obj, attribute) {\n                var value = attr(node, attribute.name);\n\n                obj[attributeNameToPropertyName(attribute.name)] =\n                    value === attribute.name ? true : value;\n                return obj;\n            }, {});\n\n        // do mapping of object properties\n        mapObject(output, attributeMapping);\n\n        return output;\n    };\n\n    var createAppAtElement = function createAppAtElement(element) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // how attributes of the input element are mapped to the options for the plugin\n        var attributeMapping = {\n            // translate to other name\n            '^class$': 'className',\n            '^multiple$': 'allowMultiple',\n            '^capture$': 'captureMethod',\n            '^webkitdirectory$': 'allowDirectoriesOnly',\n\n            // group under single property\n            '^server': {\n                group: 'server',\n                mapping: {\n                    '^process': {\n                        group: 'process',\n                    },\n\n                    '^revert': {\n                        group: 'revert',\n                    },\n\n                    '^fetch': {\n                        group: 'fetch',\n                    },\n\n                    '^restore': {\n                        group: 'restore',\n                    },\n\n                    '^load': {\n                        group: 'load',\n                    },\n                },\n            },\n\n            // don't include in object\n            '^type$': false,\n            '^files$': false,\n        };\n\n        // add additional option translators\n        applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n        // create final options object by setting options object and then overriding options supplied on element\n        var mergedOptions = Object.assign({}, options);\n\n        var attributeOptions = getAttributesAsObject(\n            element.nodeName === 'FIELDSET' ? element.querySelector('input[type=file]') : element,\n            attributeMapping\n        );\n\n        // merge with options object\n        Object.keys(attributeOptions).forEach(function(key) {\n            if (isObject(attributeOptions[key])) {\n                if (!isObject(mergedOptions[key])) {\n                    mergedOptions[key] = {};\n                }\n                Object.assign(mergedOptions[key], attributeOptions[key]);\n            } else {\n                mergedOptions[key] = attributeOptions[key];\n            }\n        });\n\n        // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n        // these will then be automatically set to the initial files\n        mergedOptions.files = (options.files || []).concat(\n            Array.from(element.querySelectorAll('input:not([type=file])')).map(function(input) {\n                return {\n                    source: input.value,\n                    options: {\n                        type: input.dataset.type,\n                    },\n                };\n            })\n        );\n\n        // build plugin\n        var app = createAppObject(mergedOptions);\n\n        // add already selected files\n        if (element.files) {\n            Array.from(element.files).forEach(function(file) {\n                app.addFile(file);\n            });\n        }\n\n        // replace the target element\n        app.replaceElement(element);\n\n        // expose\n        return app;\n    };\n\n    // if an element is passed, we create the instance at that element, if not, we just create an up object\n    var createApp$1 = function createApp() {\n        return isNode(arguments.length <= 0 ? undefined : arguments[0])\n            ? createAppAtElement.apply(void 0, arguments)\n            : createAppObject.apply(void 0, arguments);\n    };\n\n    var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n    var createAppAPI = function createAppAPI(app) {\n        var api = {};\n\n        copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n        return api;\n    };\n\n    /**\n     * Replaces placeholders in given string with replacements\n     * @param string - \"Foo {bar}\"\"\n     * @param replacements - { \"bar\": 10 }\n     */\n    var replaceInString = function replaceInString(string, replacements) {\n        return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n            return replacements[group];\n        });\n    };\n\n    var createWorker = function createWorker(fn) {\n        var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n            type: 'application/javascript',\n        });\n\n        var workerURL = URL.createObjectURL(workerBlob);\n        var worker = new Worker(workerURL);\n\n        return {\n            transfer: function transfer(message, cb) {},\n            post: function post(message, cb, transferList) {\n                var id = getUniqueId();\n\n                worker.onmessage = function(e) {\n                    if (e.data.id === id) {\n                        cb(e.data.message);\n                    }\n                };\n\n                worker.postMessage(\n                    {\n                        id: id,\n                        message: message,\n                    },\n\n                    transferList\n                );\n            },\n            terminate: function terminate() {\n                worker.terminate();\n                URL.revokeObjectURL(workerURL);\n            },\n        };\n    };\n\n    var loadImage = function loadImage(url) {\n        return new Promise(function(resolve, reject) {\n            var img = new Image();\n            img.onload = function() {\n                resolve(img);\n            };\n            img.onerror = function(e) {\n                reject(e);\n            };\n            img.src = url;\n        });\n    };\n\n    var renameFile = function renameFile(file, name) {\n        var renamedFile = file.slice(0, file.size, file.type);\n        renamedFile.lastModifiedDate = file.lastModifiedDate;\n        renamedFile.name = name;\n        return renamedFile;\n    };\n\n    var copyFile = function copyFile(file) {\n        return renameFile(file, file.name);\n    };\n\n    // already registered plugins (can't register twice)\n    var registeredPlugins = [];\n\n    // pass utils to plugin\n    var createAppPlugin = function createAppPlugin(plugin) {\n        // already registered\n        if (registeredPlugins.includes(plugin)) {\n            return;\n        }\n\n        // remember this plugin\n        registeredPlugins.push(plugin);\n\n        // setup!\n        var pluginOutline = plugin({\n            addFilter: addFilter,\n            utils: {\n                Type: Type,\n                forin: forin,\n                isString: isString,\n                isFile: isFile,\n                toNaturalFileSize: toNaturalFileSize,\n                replaceInString: replaceInString,\n                getExtensionFromFilename: getExtensionFromFilename,\n                getFilenameWithoutExtension: getFilenameWithoutExtension,\n                guesstimateMimeType: guesstimateMimeType,\n                getFileFromBlob: getFileFromBlob,\n                getFilenameFromURL: getFilenameFromURL,\n                createRoute: createRoute,\n                createWorker: createWorker,\n                createView: createView,\n                createItemAPI: createItemAPI,\n                loadImage: loadImage,\n                copyFile: copyFile,\n                renameFile: renameFile,\n                createBlob: createBlob,\n                applyFilterChain: applyFilterChain,\n                text: text,\n                getNumericAspectRatioFromString: getNumericAspectRatioFromString,\n            },\n\n            views: {\n                fileActionButton: fileActionButton,\n            },\n        });\n\n        // add plugin options to default options\n        extendDefaultOptions(pluginOutline.options);\n    };\n\n    // feature detection used by supported() method\n    var isOperaMini = function isOperaMini() {\n        return Object.prototype.toString.call(window.operamini) === '[object OperaMini]';\n    };\n    var hasPromises = function hasPromises() {\n        return 'Promise' in window;\n    };\n    var hasBlobSlice = function hasBlobSlice() {\n        return 'slice' in Blob.prototype;\n    };\n    var hasCreateObjectURL = function hasCreateObjectURL() {\n        return 'URL' in window && 'createObjectURL' in window.URL;\n    };\n    var hasVisibility = function hasVisibility() {\n        return 'visibilityState' in document;\n    };\n    var hasTiming = function hasTiming() {\n        return 'performance' in window;\n    }; // iOS 8.x\n    var hasCSSSupports = function hasCSSSupports() {\n        return 'supports' in (window.CSS || {});\n    }; // use to detect Safari 9+\n    var isIE11 = function isIE11() {\n        return /MSIE|Trident/.test(window.navigator.userAgent);\n    };\n\n    var supported = (function() {\n        // Runs immediately and then remembers result for subsequent calls\n        var isSupported =\n            // Has to be a browser\n            isBrowser() &&\n            // Can't run on Opera Mini due to lack of everything\n            !isOperaMini() &&\n            // Require these APIs to feature detect a modern browser\n            hasVisibility() &&\n            hasPromises() &&\n            hasBlobSlice() &&\n            hasCreateObjectURL() &&\n            hasTiming() &&\n            // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n            (hasCSSSupports() || isIE11());\n\n        return function() {\n            return isSupported;\n        };\n    })();\n\n    /**\n     * Plugin internal state (over all instances)\n     */\n    var state = {\n        // active app instances, used to redraw the apps and to find the later\n        apps: [],\n    };\n\n    // plugin name\n    var name = 'filepond';\n\n    /**\n     * Public Plugin methods\n     */\n    var fn = function fn() {};\n    exports.Status = {};\n    exports.FileStatus = {};\n    exports.FileOrigin = {};\n    exports.OptionTypes = {};\n    exports.create = fn;\n    exports.destroy = fn;\n    exports.parse = fn;\n    exports.find = fn;\n    exports.registerPlugin = fn;\n    exports.getOptions = fn;\n    exports.setOptions = fn;\n\n    // if not supported, no API\n    if (supported()) {\n        // start painter and fire load event\n        createPainter(\n            function() {\n                state.apps.forEach(function(app) {\n                    return app._read();\n                });\n            },\n            function(ts) {\n                state.apps.forEach(function(app) {\n                    return app._write(ts);\n                });\n            }\n        );\n\n        // fire loaded event so we know when FilePond is available\n        var dispatch = function dispatch() {\n            // let others know we have area ready\n            document.dispatchEvent(\n                new CustomEvent('FilePond:loaded', {\n                    detail: {\n                        supported: supported,\n                        create: exports.create,\n                        destroy: exports.destroy,\n                        parse: exports.parse,\n                        find: exports.find,\n                        registerPlugin: exports.registerPlugin,\n                        setOptions: exports.setOptions,\n                    },\n                })\n            );\n\n            // clean up event\n            document.removeEventListener('DOMContentLoaded', dispatch);\n        };\n\n        if (document.readyState !== 'loading') {\n            // move to back of execution queue, FilePond should have been exported by then\n            setTimeout(function() {\n                return dispatch();\n            }, 0);\n        } else {\n            document.addEventListener('DOMContentLoaded', dispatch);\n        }\n\n        // updates the OptionTypes object based on the current options\n        var updateOptionTypes = function updateOptionTypes() {\n            return forin(getOptions(), function(key, value) {\n                exports.OptionTypes[key] = value[1];\n            });\n        };\n\n        exports.Status = Object.assign({}, Status);\n        exports.FileOrigin = Object.assign({}, FileOrigin);\n        exports.FileStatus = Object.assign({}, ItemStatus);\n\n        exports.OptionTypes = {};\n        updateOptionTypes();\n\n        // create method, creates apps and adds them to the app array\n        exports.create = function create() {\n            var app = createApp$1.apply(void 0, arguments);\n            app.on('destroy', exports.destroy);\n            state.apps.push(app);\n            return createAppAPI(app);\n        };\n\n        // destroys apps and removes them from the app array\n        exports.destroy = function destroy(hook) {\n            // returns true if the app was destroyed successfully\n            var indexToRemove = state.apps.findIndex(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (indexToRemove >= 0) {\n                // remove from apps\n                var app = state.apps.splice(indexToRemove, 1)[0];\n\n                // restore original dom element\n                app.restoreElement();\n\n                return true;\n            }\n\n            return false;\n        };\n\n        // parses the given context for plugins (does not include the context element itself)\n        exports.parse = function parse(context) {\n            // get all possible hooks\n            var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n            // filter out already active hooks\n            var newHooks = matchedHooks.filter(function(newHook) {\n                return !state.apps.find(function(app) {\n                    return app.isAttachedTo(newHook);\n                });\n            });\n\n            // create new instance for each hook\n            return newHooks.map(function(hook) {\n                return exports.create(hook);\n            });\n        };\n\n        // returns an app based on the given element hook\n        exports.find = function find(hook) {\n            var app = state.apps.find(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (!app) {\n                return null;\n            }\n            return createAppAPI(app);\n        };\n\n        // adds a plugin extension\n        exports.registerPlugin = function registerPlugin() {\n            for (\n                var _len = arguments.length, plugins = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                plugins[_key] = arguments[_key];\n            }\n\n            // register plugins\n            plugins.forEach(createAppPlugin);\n\n            // update OptionTypes, each plugin might have extended the default options\n            updateOptionTypes();\n        };\n\n        exports.getOptions = function getOptions$1() {\n            var opts = {};\n            forin(getOptions(), function(key, value) {\n                opts[key] = value[0];\n            });\n            return opts;\n        };\n\n        exports.setOptions = function setOptions$1(opts) {\n            if (isObject(opts)) {\n                // update existing plugins\n                state.apps.forEach(function(app) {\n                    app.setOptions(opts);\n                });\n\n                // override defaults\n                setOptions(opts);\n            }\n\n            // return new options\n            return exports.getOptions();\n        };\n    }\n\n    exports.supported = supported;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRTtBQUNBLFVBQVUsQ0FFNEQ7QUFDdEUsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RCxTQUFTOztBQUVUO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakIscURBQXFEO0FBQ3JELHlEQUF5RDtBQUN6RCxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakIscURBQXFEO0FBQ3JELHlEQUF5RDtBQUN6RCxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCLGVBQWUscUJBQXFCO0FBQzdELHlCQUF5QixlQUFlLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYiwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQywyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhOztBQUVuQztBQUNBLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQsa0NBQWtDO0FBQzlGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLHFGQUFxRixRQUFRO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHlCQUF5QjtBQUNqRSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELHdCQUF3QiwyQkFBMkI7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLElBQUk7QUFDNUQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hELHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGFBQWE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSx1QkFBdUI7O0FBRXZCLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsaUNBQWlDLHVCQUF1QjtBQUN4RCw0QkFBNEIsa0JBQWtCO0FBQzlDLDRCQUE0QixrQkFBa0I7QUFDOUMsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvQ0FBb0M7QUFDL0UsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtEQUFrRCw0QkFBNEI7QUFDOUU7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsb0JBQW9CO0FBQzdGLHFDQUFxQztBQUNyQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFdBQVc7QUFDN0UseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLGtDQUFrQywwQkFBMEI7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGdEQUFnRCxHQUFHOztBQUVuRDtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSx3REFBd0Qsa0NBQWtDOztBQUUxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQsaUJBQWlCOztBQUVqQjtBQUNBLHNEQUFzRCxRQUFRO0FBQzlELGlCQUFpQjs7QUFFakI7QUFDQSx1REFBdUQsUUFBUTtBQUMvRCxpQkFBaUI7O0FBRWpCO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RixpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7O0FBRXpCO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLDhCQUE4QixnREFBZ0Q7QUFDOUUsaUJBQWlCOztBQUVqQjtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pELGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsd0JBQXdCO0FBQzNGLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG9CQUFvQjtBQUNqRztBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0NBQWtDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsaUJBQWlCOztBQUVqQjtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFLGlCQUFpQjs7QUFFakI7QUFDQSxtRUFBbUUsNEJBQTRCO0FBQy9GLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckIsbURBQW1ELG9DQUFvQztBQUN2RixpQkFBaUI7O0FBRWpCO0FBQ0EsNERBQTRELFFBQVE7QUFDcEUsaUJBQWlCOztBQUVqQjtBQUNBLDZEQUE2RCxRQUFRO0FBQ3JFLG1EQUFtRCxxQkFBcUI7QUFDeEUsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUc7QUFDbkQsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDBEQUEwRCxhQUFhOztBQUV2RSwyQ0FBMkMsaURBQWlEO0FBQzVGLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQStDO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3RjtBQUNBLGlFQUFpRSx5QkFBeUI7O0FBRTFGO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxzREFBc0QsYUFBYTtBQUNuRSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0QsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxpQ0FBaUM7O0FBRW5GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWE7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQSxxQkFBcUI7QUFDckIsd0NBQXdDO0FBQ3hDLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGNBQWM7QUFDMUYsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHdEQUF3RCxVQUFVLFlBQVk7QUFDOUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHNCQUFzQixrQkFBa0I7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHdEQUF3RCxVQUFVLFlBQVk7QUFDOUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDLCtCQUErQixZQUFZO0FBQzNDLDRCQUE0QixZQUFZO0FBQ3hDLDZCQUE2QixZQUFZO0FBQ3pDLHFDQUFxQyxZQUFZO0FBQ2pELHFDQUFxQyxZQUFZO0FBQ2pELHNDQUFzQyxZQUFZO0FBQ2xELGlDQUFpQyw4Q0FBOEM7QUFDL0Usb0NBQW9DLGlEQUFpRDtBQUNyRix1Q0FBdUMsd0NBQXdDO0FBQy9FLGdCQUFnQiwwQ0FBMEM7QUFDMUQsa0JBQWtCLDBDQUEwQztBQUM1RDs7QUFFQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLDZCQUE2QixZQUFZO0FBQ3pDLGdCQUFnQixxQ0FBcUM7QUFDckQsa0JBQWtCLHFDQUFxQztBQUN2RDs7QUFFQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pELG9DQUFvQyxZQUFZO0FBQ2hELGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QyxvQkFBb0IscUNBQXFDO0FBQ3pELHNCQUFzQixpREFBaUQ7QUFDdkUsU0FBUzs7QUFFVDtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DLHFDQUFxQyxZQUFZO0FBQ2pELHNCQUFzQixZQUFZO0FBQ2xDLFNBQVM7O0FBRVQ7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxnQ0FBZ0MsWUFBWTtBQUM1QyxvQkFBb0IscUNBQXFDO0FBQ3pELHNCQUFzQixZQUFZO0FBQ2xDLFNBQVM7O0FBRVQ7QUFDQSx3Q0FBd0MsK0NBQStDO0FBQ3ZGLG9CQUFvQixxQ0FBcUM7QUFDekQsc0JBQXNCLFlBQVk7QUFDbEMsU0FBUzs7QUFFVDtBQUNBLHdDQUF3QywrQ0FBK0M7QUFDdkYsZ0NBQWdDLFlBQVk7QUFDNUMsb0JBQW9CLHFDQUFxQztBQUN6RCxzQkFBc0IsaURBQWlEO0FBQ3ZFLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLG9CQUFvQixxQ0FBcUM7QUFDekQsc0JBQXNCLHFDQUFxQztBQUMzRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsb0JBQW9CLFlBQVk7QUFDaEMsc0JBQXNCLFlBQVk7QUFDbEMsU0FBUzs7QUFFVDtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLHlDQUF5QyxZQUFZO0FBQ3JELHNCQUFzQixZQUFZO0FBQ2xDLG9CQUFvQixxQ0FBcUM7QUFDekQsU0FBUzs7QUFFVDtBQUNBLDBDQUEwQyxZQUFZO0FBQ3RELHNCQUFzQixZQUFZO0FBQ2xDLG9CQUFvQixZQUFZO0FBQ2hDLFNBQVM7O0FBRVQ7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QyxpQ0FBaUMsWUFBWTtBQUM3QyxvQkFBb0IscUNBQXFDO0FBQ3pELHNCQUFzQixZQUFZO0FBQ2xDLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RCxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RCxhQUFhOztBQUViO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxRQUFROztBQUV0RjtBQUNBLGtGQUFrRixRQUFROztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVLFlBQVk7QUFDOUUsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLGNBQWM7O0FBRXhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx3REFBd0QsVUFBVSxZQUFZO0FBQzlFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEOztBQUVBO0FBQ0EsNEVBQTRFLG9CQUFvQjs7QUFFaEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxvQ0FBb0M7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxvQ0FBb0M7QUFDckY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxvQ0FBb0M7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsMkJBQTJCOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0Q0FBNEM7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBOEM7QUFDcEUsU0FBUztBQUNULDhCQUE4QixzQkFBc0IsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWlEO0FBQ3ZFLFNBQVM7QUFDVCx5QkFBeUIsWUFBWTtBQUNyQyx5QkFBeUIsc0JBQXNCLHFDQUFxQztBQUNwRiwyQkFBMkIsc0JBQXNCLDJDQUEyQzs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7O0FBRUE7QUFDQSw0RUFBNEUsb0JBQW9COztBQUVoRztBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0Esd0ZBQXdGOztBQUV4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0Qzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQix1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQiw0Q0FBNEMsb0JBQW9COztBQUVoRSxnREFBZ0Qsb0JBQW9CO0FBQ3BFOztBQUVBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTs7QUFFQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEUsYUFBYTs7QUFFYjtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7O0FBRUE7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5QkFBeUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHlCQUF5Qjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsbUJBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0MsS0FBSyxzQkFBc0I7QUFDekY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELGFBQWEsY0FBYzs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0EsY0FBYzs7QUFFZDtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRCQUE0QjtBQUNyRixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsOENBQThDO0FBQzlDLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELGFBQWE7QUFDaEUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC9kaXN0L2ZpbGVwb25kLmpzP2MwNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZCA0LjI5LjFcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGZhY3RvcnkoZXhwb3J0cylcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpXG4gICAgICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksIGZhY3RvcnkoKGdsb2JhbC5GaWxlUG9uZCA9IHt9KSkpO1xufSkodGhpcywgZnVuY3Rpb24oZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpc05vZGUgPSBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTdG9yZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB2YXIgcXVlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICAgIHZhciBhY3Rpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdmFyIHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcblxuICAgICAgICAvLyBjb250YWlucyBhbGwgYWN0aW9ucyBmb3IgbmV4dCBmcmFtZSwgaXMgY2xlYXIgd2hlbiBhY3Rpb25zIGFyZSByZXF1ZXN0ZWRcbiAgICAgICAgdmFyIGFjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHZhciBkaXNwYXRjaFF1ZXVlID0gW107XG5cbiAgICAgICAgLy8gcmV0dXJucyBhIGR1cGxpY2F0ZSBvZiB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmV0dXJucyBhIGR1cGxpY2F0ZSBvZiB0aGUgYWN0aW9ucyBhcnJheSBhbmQgY2xlYXJzIHRoZSBhY3Rpb25zIGFycmF5XG4gICAgICAgIHZhciBwcm9jZXNzQWN0aW9uUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzQWN0aW9uUXVldWUoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoYWN0aW9uUXVldWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByb2Nlc3NlcyBhY3Rpb25zIHRoYXQgbWlnaHQgYmxvY2sgdGhlIG1haW4gVUkgdGhyZWFkXG4gICAgICAgIHZhciBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGRpc3BhdGNoUXVldWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAvLyBub3cgZGlzcGF0Y2ggdGhlc2UgYWN0aW9uc1xuICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHlwZSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGRzIGEgbmV3IGFjdGlvbiwgY2FsbHMgaXRzIGhhbmRsZXIgYW5kXG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUsIGRhdGEsIGlzQmxvY2tpbmcpIHtcbiAgICAgICAgICAgIC8vIGlzIGJsb2NraW5nIGFjdGlvbiAoc2hvdWxkIG5ldmVyIGJsb2NrIGlmIGRvY3VtZW50IGlzIGhpZGRlbilcbiAgICAgICAgICAgIGlmIChpc0Jsb2NraW5nICYmICFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbkhhbmRsZXJzW3R5cGVdKGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgYWRkIGFjdGlvblxuICAgICAgICAgICAgYWN0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc3RyKSB7XG4gICAgICAgICAgICB2YXIgX3F1ZXJ5SGFuZGxlcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBxdWVyeUhhbmRsZXNbc3RyXVxuICAgICAgICAgICAgICAgID8gKF9xdWVyeUhhbmRsZXMgPSBxdWVyeUhhbmRsZXMpW3N0cl0uYXBwbHkoX3F1ZXJ5SGFuZGxlcywgYXJncylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICAgICAgICAgIHByb2Nlc3NBY3Rpb25RdWV1ZTogcHJvY2Vzc0FjdGlvblF1ZXVlLFxuICAgICAgICAgICAgcHJvY2Vzc0Rpc3BhdGNoUXVldWU6IHByb2Nlc3NEaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBxdWVyeUhhbmRsZXMgPSB7fTtcbiAgICAgICAgcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICBxdWVyeUhhbmRsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeShzdGF0ZSksIHt9LCBxdWVyeUhhbmRsZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYWN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24oZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSksIHt9LCBhY3Rpb25IYW5kbGVycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgZm9yaW4gPSBmdW5jdGlvbiBmb3JpbihvYmosIGNiKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yaW4oZGVmaW5pdGlvbiwgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIGRlZmluaXRpb25bcHJvcGVydHldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihub2RlLCBuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIHZhciBzdmdFbGVtZW50cyA9IFsnc3ZnJywgJ3BhdGgnXTsgLy8gb25seSBzdmcgZWxlbWVudHMgdXNlZFxuXG4gICAgdmFyIGlzU1ZHRWxlbWVudCA9IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudCh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnRzLmluY2x1ZGVzKHRhZyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBpc1NWR0VsZW1lbnQodGFnKVxuICAgICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZylcbiAgICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgICAgICAgICBhdHRyKGVsZW1lbnQsICdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcmluKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFyZW50LmNoaWxkcmVuW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kQ2hpbGRWaWV3ID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGRWaWV3KHBhcmVudCwgY2hpbGRWaWV3cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmlldywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoaW5kZXgsIDAsIHZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGRWaWV3KHBhcmVudCwgY2hpbGRWaWV3cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gY2hpbGQgdmlld3NcbiAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHZpZXcuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSVNfQlJPV1NFUiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH0pKCk7XG4gICAgdmFyIGlzQnJvd3NlciA9IGZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuIElTX0JST1dTRVI7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0RWxlbWVudCA9IGlzQnJvd3NlcigpID8gY3JlYXRlRWxlbWVudCgnc3ZnJykgOiB7fTtcbiAgICB2YXIgZ2V0Q2hpbGRDb3VudCA9XG4gICAgICAgICdjaGlsZHJlbicgaW4gdGVzdEVsZW1lbnRcbiAgICAgICAgICAgID8gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfTtcblxuICAgIHZhciBnZXRWaWV3UmVjdCA9IGZ1bmN0aW9uIGdldFZpZXdSZWN0KGVsZW1lbnRSZWN0LCBjaGlsZFZpZXdzLCBvZmZzZXQsIHNjYWxlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gb2Zmc2V0WzBdIHx8IGVsZW1lbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciB0b3AgPSBvZmZzZXRbMV0gfHwgZWxlbWVudFJlY3QudG9wO1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQgKiAoc2NhbGVbMV0gfHwgMSk7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB7XG4gICAgICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICAgICAgZWxlbWVudDogT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudFJlY3QpLFxuXG4gICAgICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuLCBkb2VzIG5vdCBpbmNsdWRlIGFueSBtYXJnaW5zXG4gICAgICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnRSZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZWxlbWVudFJlY3QuYm90dG9tLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiBpbmNsdWRpbmcgb3duIG1hcmdpbiBhbmQgY2hpbGQgbWFyZ2luc1xuICAgICAgICAgICAgLy8gbWFyZ2lucyB3aWxsIGJlIGFkZGVkIGFmdGVyIHdlJ3ZlIHJlY2FsY3VsYXRlZCB0aGUgc2l6ZVxuICAgICAgICAgICAgb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZXhwYW5kIHJlY3QgdG8gZml0IGFsbCBjaGlsZCByZWN0YW5nbGVzXG4gICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFjaGlsZFZpZXcuaXNSZWN0SWdub3JlZCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlldy5yZWN0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkVmlld1JlY3QpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3QuaW5uZXIpKTtcbiAgICAgICAgICAgICAgICBleHBhbmRSZWN0KHJlY3Qub3V0ZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3Qub3V0ZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QuaW5uZXIpO1xuXG4gICAgICAgIC8vIGFwcGVuZCBhZGRpdGlvbmFsIG1hcmdpbiAodG9wIGFuZCBsZWZ0IG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluIHRvcCBhbmQgbGVmdCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgICAgICByZWN0Lm91dGVyLnJpZ2h0ICs9IHJlY3QuZWxlbWVudC5tYXJnaW5SaWdodDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgb3V0ZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGFuZFJlY3QgPSBmdW5jdGlvbiBleHBhbmRSZWN0KHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgICAgIGNoaWxkLnRvcCArPSBwYXJlbnQudG9wO1xuICAgICAgICBjaGlsZC5yaWdodCArPSBwYXJlbnQubGVmdDtcbiAgICAgICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgICAgIGNoaWxkLmxlZnQgKz0gcGFyZW50LmxlZnQ7XG5cbiAgICAgICAgaWYgKGNoaWxkLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pIHtcbiAgICAgICAgICAgIHBhcmVudC5ib3R0b20gPSBjaGlsZC5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQucmlnaHQgPiBwYXJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IGNoaWxkLnJpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVSZWN0U2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QpIHtcbiAgICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICB9O1xuXG4gICAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgcG9zaXRpb24gaXMgYXQgZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0gdmVsb2NpdHlcbiAgICAgKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgdGhlcmVZZXQgPSBmdW5jdGlvbiB0aGVyZVlldChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBlcnJvck1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4wMDE7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhwb3NpdGlvbiAtIGRlc3RpbmF0aW9uKSA8IGVycm9yTWFyZ2luICYmIE1hdGguYWJzKHZlbG9jaXR5KSA8IGVycm9yTWFyZ2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcHJpbmcgYW5pbWF0aW9uXG4gICAgICovXG4gICAgdmFyIHNwcmluZyA9XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBmdW5jdGlvbiBzcHJpbmcoKSAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZiRzdGlmZm5lc3MgPSBfcmVmLnN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3MgPSBfcmVmJHN0aWZmbmVzcyA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgX3JlZiRkYW1waW5nID0gX3JlZi5kYW1waW5nLFxuICAgICAgICAgICAgICAgIGRhbXBpbmcgPSBfcmVmJGRhbXBpbmcgPT09IHZvaWQgMCA/IDAuNzUgOiBfcmVmJGRhbXBpbmcsXG4gICAgICAgICAgICAgICAgX3JlZiRtYXNzID0gX3JlZi5tYXNzLFxuICAgICAgICAgICAgICAgIG1hc3MgPSBfcmVmJG1hc3MgPT09IHZvaWQgMCA/IDEwIDogX3JlZiRtYXNzO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHZhciByZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZXMgc3ByaW5nIHN0YXRlXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiByZXN0LCBkb24ndCBhbmltYXRlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWQgYXQgbGVhc3QgYSB0YXJnZXQgb3IgcG9zaXRpb24gdG8gZG8gc3ByaW5neSB0aGluZ3NcbiAgICAgICAgICAgICAgICBpZiAoIShpc051bWJlcih0YXJnZXQpICYmIGlzTnVtYmVyKHBvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBzcHJpbmcgZm9yY2VcbiAgICAgICAgICAgICAgICB2YXIgZiA9IC0ocG9zaXRpb24gLSB0YXJnZXQpICogc3RpZmZuZXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKz0gZiAvIG1hc3M7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gYnkgYWRkaW5nIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgICAgICAgICAvLyBzbG93IGRvd24gYmFzZWQgb24gYW1vdW50IG9mIGRhbXBpbmdcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSAqPSBkYW1waW5nO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0aGVyZVlldChwb3NpdGlvbiwgdGFyZ2V0LCB2ZWxvY2l0eSkgfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbmV3IHRhcmdldCB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBzZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgaGFzIG5vIHBvc2l0aW9uLCBzZXQgdGFyZ2V0IGFuZCBwb3NpdGlvbiB0byB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbmV4dCB0YXJnZXQgdmFsdWUgd2lsbCBub3QgYmUgYW5pbWF0ZWQgdG9cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxldCBzdGFydCBtb3ZpbmcgdG8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGF0IHRhcmdldFxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyByZXN0aW5nIGFzIHRhcmdldCBpcyBjdXJyZW50IHBvc2l0aW9uLCBzdG9wIG1vdmluZ1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHNldDogc2V0VGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGVhc2VMaW5lYXIgPSBmdW5jdGlvbiBlYXNlTGluZWFyKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgZWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICAgIH07XG5cbiAgICB2YXIgdHdlZW4gPVxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgICAgICBmdW5jdGlvbiB0d2VlbigpIC8vIG1ldGhvZCBkZWZpbml0aW9uXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IF9yZWYkZHVyYXRpb24gPT09IHZvaWQgMCA/IDUwMCA6IF9yZWYkZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgX3JlZiRlYXNpbmcgPSBfcmVmLmVhc2luZyxcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZWFzZUluT3V0UXVhZCA6IF9yZWYkZWFzaW5nLFxuICAgICAgICAgICAgICAgIF9yZWYkZGVsYXkgPSBfcmVmLmRlbGF5LFxuICAgICAgICAgICAgICAgIGRlbGF5ID0gX3JlZiRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkZGVsYXk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIHZhciByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHMgLSBzdGFydCA8IGRlbGF5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gZHVyYXRpb24gfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHAgPSByZXZlcnNlID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSB0IC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZSgodCA+PSAwID8gZWFzaW5nKHJldmVyc2UgPyAxIC0gcCA6IHApIDogMCkgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgdmFyIGFwaSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnNlID8gMCA6IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdHdlZW4gdG8gYSBzbWFsbGVyIHZhbHVlIGFuZCBoYXZlIGEgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHR3ZWVuaW5nIHRvIGEgc21hbGxlciB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZ28hXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGFuaW1hdG9yID0ge1xuICAgICAgICBzcHJpbmc6IHNwcmluZyxcbiAgICAgICAgdHdlZW46IHR3ZWVuLFxuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IC41LCBkYW1waW5nOiAuNzUsIG1hc3M6IDEwIH07XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgdHlwZTogJ3NwcmluZycsIC4uLiB9LCAuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICB7IHRyYW5zbGF0aW9uOiB7IHg6IHsgdHlwZTogJ3NwcmluZycsIC4uLiB9IH0gfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdmFyIGNyZWF0ZUFuaW1hdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5pbWF0b3IoZGVmaW5pdGlvbiwgY2F0ZWdvcnksIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgc2luZ2xlIGRlZmluaXRpb25cbiAgICAgICAgLy8gd2UgY2hlY2sgaWYgdHJhbnNmb3JtIGlzIHNldCwgaWYgc28sIHdlIGNoZWNrIGlmIHByb3BlcnR5IGlzIHNldFxuICAgICAgICB2YXIgZGVmID1cbiAgICAgICAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV1cbiAgICAgICAgICAgICAgICA6IGRlZmluaXRpb25bY2F0ZWdvcnldIHx8IGRlZmluaXRpb247XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZGVmID09PSAnc3RyaW5nJyA/IGRlZiA6IGRlZi50eXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZikgOiB7fTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0b3JbdHlwZV0gPyBhbmltYXRvclt0eXBlXShwcm9wcykgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYWRkR2V0U2V0ID0gZnVuY3Rpb24gYWRkR2V0U2V0KGtleXMsIG9iaiwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJvcHNba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrZXkua2V5O1xuICAgICAgICAgICAgICAgICAgICBnZXR0ZXIgPSBrZXkuZ2V0dGVyIHx8IGdldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyID0ga2V5LnNldHRlciB8fCBzZXR0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9bbmFtZV0gJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZCB0byBzdGF0ZSxcbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAgIC8vIHNldHVwIGFuaW1hdG9yc1xuXG4gICAgdmFyIGFuaW1hdGlvbnMgPSBmdW5jdGlvbiBhbmltYXRpb25zKF9yZWYpIHtcbiAgICAgICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgICAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICAgICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIGxpc3Qgb2YgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAgICAgLy8gc2V0dXAgYW5pbWF0b3JzXG4gICAgICAgIGZvcmluKG1peGluQ29uZmlnLCBmdW5jdGlvbihwcm9wZXJ0eSwgYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBjcmVhdGVBbmltYXRvcihhbmltYXRpb24pO1xuICAgICAgICAgICAgaWYgKCFhbmltYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgYW5pbWF0b3IgdXBkYXRlcywgdXBkYXRlIHRoZSB2aWV3IHN0YXRlIHZhbHVlXG4gICAgICAgICAgICBhbmltYXRvci5vbnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc2V0IGFuaW1hdG9yIHRhcmdldFxuICAgICAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIHNldHRlcjogZnVuY3Rpb24gc2V0dGVyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgYXQgdGFyZ2V0LCB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9wc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgICAgICBhZGRHZXRTZXQoW3Byb3BdLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGxpc3QgZm9yIGVhc3kgdXBkYXRpbmcgZnJvbSB0aGUgX3dyaXRlIG1ldGhvZFxuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIGludGVybmFsIHdyaXRlIGFwaVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgICAgIHZhciByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLnJlc3RpbmcpIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHt9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiBhZGRFdmVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIG1peGluXG4gICAgdmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3U3RhdGUgPSBfcmVmLnZpZXdTdGF0ZSxcbiAgICAgICAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgICAgICB2YXIgYWRkID0gYWRkRXZlbnQodmlldy5lbGVtZW50KTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IHJlbW92ZUV2ZW50KHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgdmlld0V4dGVybmFsQVBJLm9uID0gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhZGQodHlwZSwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZpZXdFeHRlcm5hbEFQSS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgICAgICAgICBldmVudHMuZmluZEluZGV4KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbjtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZW1vdmUodHlwZSwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGJ1c3lcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShldmVudC50eXBlLCBldmVudC5mbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbiAgICB2YXIgYXBpcyA9IGZ1bmN0aW9uIGFwaXMoX3JlZikge1xuICAgICAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICAgICAgYWRkR2V0U2V0KG1peGluQ29uZmlnLCB2aWV3RXh0ZXJuYWxBUEksIHZpZXdQcm9wcyk7XG4gICAgfTtcblxuICAgIHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIGFkZCB0byBzdGF0ZSxcbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlIGJhc2VkIG9uIHByb3BzIGluIHZpZXdQcm9wc1xuICAgIC8vIGFwcGx5IGFzIHRyYW5zZm9ybXMgZWFjaCBmcmFtZVxuXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZVg6IDEsXG4gICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgdHJhbnNsYXRlWTogMCxcbiAgICAgICAgcm90YXRlWDogMCxcbiAgICAgICAgcm90YXRlWTogMCxcbiAgICAgICAgcm90YXRlWjogMCxcbiAgICAgICAgb3JpZ2luWDogMCxcbiAgICAgICAgb3JpZ2luWTogMCxcbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3ID0gX3JlZi52aWV3O1xuICAgICAgICAvLyBpbml0aWFsIHByb3BzXG4gICAgICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgcHJvcHNcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wcyA9IHt9O1xuXG4gICAgICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICAgICAgYWRkR2V0U2V0KG1peGluQ29uZmlnLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIG92ZXJyaWRlIHJlY3Qgb24gaW50ZXJuYWwgYW5kIGV4dGVybmFsIHJlY3QgZ2V0dGVyIHNvIGl0IHRha2VzIGluIGFjY291bnQgdHJhbnNmb3Jtc1xuICAgICAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmlld1Byb3BzWydzY2FsZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3NjYWxlWSddIHx8IDBdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0UmVjdCA9IGZ1bmN0aW9uIGdldFJlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5yZWN0XG4gICAgICAgICAgICAgICAgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2aWV3SW50ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG4gICAgICAgIHZpZXdFeHRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcblxuICAgICAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgICAgIG1peGluQ29uZmlnLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2aWV3UHJvcHNba2V5XSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzW2tleV0gOiBpbml0aWFsUHJvcHNba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIGFwaVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge1xuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyBlbGVtZW50IHRvIGNvcnJlY3QgcG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZXModmlldy5lbGVtZW50LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgbmV3IHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRQcm9wcywgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgYnVzeVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3BzSGF2ZUNoYW5nZWQgPSBmdW5jdGlvbiBwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgICAgLy8gZGlmZmVyZW50IGFtb3VudCBvZiBrZXlzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjdXJyZW50UHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobmV3UHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXRzIGFuYWx5emUgdGhlIGluZGl2aWR1YWwgcHJvcHNcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKG5ld1Byb3BzW3Byb3BdICE9PSBjdXJyZW50UHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGx5U3R5bGVzID0gZnVuY3Rpb24gYXBwbHlTdHlsZXMoZWxlbWVudCwgX3JlZjIpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBfcmVmMi5vcGFjaXR5LFxuICAgICAgICAgICAgcGVyc3BlY3RpdmUgPSBfcmVmMi5wZXJzcGVjdGl2ZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBfcmVmMi50cmFuc2xhdGVYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IF9yZWYyLnRyYW5zbGF0ZVksXG4gICAgICAgICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgICAgICByb3RhdGVYID0gX3JlZjIucm90YXRlWCxcbiAgICAgICAgICAgIHJvdGF0ZVkgPSBfcmVmMi5yb3RhdGVZLFxuICAgICAgICAgICAgcm90YXRlWiA9IF9yZWYyLnJvdGF0ZVosXG4gICAgICAgICAgICBvcmlnaW5YID0gX3JlZjIub3JpZ2luWCxcbiAgICAgICAgICAgIG9yaWdpblkgPSBfcmVmMi5vcmlnaW5ZLFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9ICcnO1xuICAgICAgICB2YXIgc3R5bGVzID0gJyc7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRyYW5zZm9ybSBvcmlnaW5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAndHJhbnNmb3JtLW9yaWdpbjogJyArIChvcmlnaW5YIHx8IDApICsgJ3B4ICcgKyAob3JpZ2luWSB8fCAwKSArICdweDsnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIG9yZGVyIGlzIHJlbGV2YW50XG4gICAgICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgICAgIGlmIChpc0RlZmluZWQocGVyc3BlY3RpdmUpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdwZXJzcGVjdGl2ZSgnICsgcGVyc3BlY3RpdmUgKyAncHgpICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0cmFuc2xhdGVYKSB8fCBpc0RlZmluZWQodHJhbnNsYXRlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgICAgICAgICAndHJhbnNsYXRlM2QoJyArICh0cmFuc2xhdGVYIHx8IDApICsgJ3B4LCAnICsgKHRyYW5zbGF0ZVkgfHwgMCkgKyAncHgsIDApICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBzY2FsZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgICAgICAgICAnc2NhbGUzZCgnICtcbiAgICAgICAgICAgICAgICAoaXNEZWZpbmVkKHNjYWxlWCkgPyBzY2FsZVggOiAxKSArXG4gICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgKGlzRGVmaW5lZChzY2FsZVkpID8gc2NhbGVZIDogMSkgK1xuICAgICAgICAgICAgICAgICcsIDEpICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiByb3RhdGVcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyb3RhdGVaKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPSAncm90YXRlWignICsgcm90YXRlWiArICdyYWQpICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVYKCcgKyByb3RhdGVYICsgJ3JhZCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocm90YXRlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz0gJ3JvdGF0ZVkoJyArIHJvdGF0ZVkgKyAncmFkKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRyYW5zZm9ybXNcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ3RyYW5zZm9ybTonICsgdHJhbnNmb3JtcyArICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBvcGFjaXR5XG4gICAgICAgIGlmIChpc0RlZmluZWQob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAnb3BhY2l0eTonICsgb3BhY2l0eSArICc7JztcblxuICAgICAgICAgICAgLy8gaWYgd2UgcmVhY2ggemVybywgd2UgbWFrZSB0aGUgZWxlbWVudCBpbmFjY2Vzc2libGVcbiAgICAgICAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9ICd2aXNpYmlsaXR5OmhpZGRlbjsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBiZWxvdyAxMDAlIG9wYWNpdHkgdGhpcyBlbGVtZW50IGNhbid0IGJlIGNsaWNrZWRcbiAgICAgICAgICAgIGlmIChvcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSAncG9pbnRlci1ldmVudHM6bm9uZTsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGhlaWdodFxuICAgICAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB3aWR0aFxuICAgICAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICd3aWR0aDonICsgd2lkdGggKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlc1xuICAgICAgICB2YXIgZWxlbWVudEN1cnJlbnRTdHlsZSA9IGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSB8fCAnJztcblxuICAgICAgICAvLyBpZiBuZXcgc3R5bGVzIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQgc3R5bGVzLCBsZXRzIHVwZGF0ZSFcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8IHN0eWxlcyAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVzO1xuICAgICAgICAgICAgLy8gc3RvcmUgY3VycmVudCBzdHlsZXMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSB0byBuZXcgc3R5bGVzIGxhdGVyIG9uXG4gICAgICAgICAgICAvLyBfbm90XyBnZXR0aW5nIHRoZSBzdHlsZSB2YWx1ZSBpcyBmYXN0ZXJcbiAgICAgICAgICAgIGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgTWl4aW5zID0ge1xuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgICAgIGFwaXM6IGFwaXMsXG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVSZWN0ID0gZnVuY3Rpb24gdXBkYXRlUmVjdCgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgICAgaWYgKCFlbGVtZW50LmxheW91dENhbGN1bGF0ZWQpIHtcbiAgICAgICAgICAgIHJlY3QucGFkZGluZ1RvcCA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5Ub3AgPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5SaWdodCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luQm90dG9tID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luTGVmdCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSB8fCAwO1xuICAgICAgICAgICAgZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3QubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICByZWN0LnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcblxuICAgICAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aDtcbiAgICAgICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHJlY3Quc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgcmVjdC5oaWRkZW4gPSBlbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVZpZXcgPVxuICAgICAgICAvLyBkZWZhdWx0IHZpZXcgZGVmaW5pdGlvblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWYkdGFnID0gX3JlZi50YWcsXG4gICAgICAgICAgICAgICAgdGFnID0gX3JlZiR0YWcgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR0YWcsXG4gICAgICAgICAgICAgICAgX3JlZiRuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBfcmVmJG5hbWUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJG5hbWUsXG4gICAgICAgICAgICAgICAgX3JlZiRhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmJGF0dHJpYnV0ZXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIF9yZWYkcmVhZCA9IF9yZWYucmVhZCxcbiAgICAgICAgICAgICAgICByZWFkID0gX3JlZiRyZWFkID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRyZWFkLFxuICAgICAgICAgICAgICAgIF9yZWYkd3JpdGUgPSBfcmVmLndyaXRlLFxuICAgICAgICAgICAgICAgIHdyaXRlID0gX3JlZiR3cml0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkd3JpdGUsXG4gICAgICAgICAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGUgPSBfcmVmJGNyZWF0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkY3JlYXRlLFxuICAgICAgICAgICAgICAgIF9yZWYkZGVzdHJveSA9IF9yZWYuZGVzdHJveSxcbiAgICAgICAgICAgICAgICBkZXN0cm95ID0gX3JlZiRkZXN0cm95ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICAgICAgICAgIF9yZWYkZmlsdGVyRnJhbWVBY3RpbyA9IF9yZWYuZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQsXG4gICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQgPVxuICAgICAgICAgICAgICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbihjaGlsZCwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3JlZiRmaWx0ZXJGcmFtZUFjdGlvLFxuICAgICAgICAgICAgICAgIF9yZWYkZGlkQ3JlYXRlVmlldyA9IF9yZWYuZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBkaWRDcmVhdGVWaWV3ID0gX3JlZiRkaWRDcmVhdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRDcmVhdGVWaWV3LFxuICAgICAgICAgICAgICAgIF9yZWYkZGlkV3JpdGVWaWV3ID0gX3JlZi5kaWRXcml0ZVZpZXcsXG4gICAgICAgICAgICAgICAgZGlkV3JpdGVWaWV3ID0gX3JlZiRkaWRXcml0ZVZpZXcgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGRpZFdyaXRlVmlldyxcbiAgICAgICAgICAgICAgICBfcmVmJGlnbm9yZVJlY3QgPSBfcmVmLmlnbm9yZVJlY3QsXG4gICAgICAgICAgICAgICAgaWdub3JlUmVjdCA9IF9yZWYkaWdub3JlUmVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3QsXG4gICAgICAgICAgICAgICAgX3JlZiRpZ25vcmVSZWN0VXBkYXRlID0gX3JlZi5pZ25vcmVSZWN0VXBkYXRlLFxuICAgICAgICAgICAgICAgIGlnbm9yZVJlY3RVcGRhdGUgPSBfcmVmJGlnbm9yZVJlY3RVcGRhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWN0VXBkYXRlLFxuICAgICAgICAgICAgICAgIF9yZWYkbWl4aW5zID0gX3JlZi5taXhpbnMsXG4gICAgICAgICAgICAgICAgbWl4aW5zID0gX3JlZiRtaXhpbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtaXhpbnM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgLy8gZWFjaCB2aWV3IHJlcXVpcmVzIHJlZmVyZW5jZSB0byBzdG9yZVxuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCAnZmlsZXBvbmQtLScgKyBuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0eWxlIHJlZmVyZW5jZSBzaG91bGQgYWxzbyBub3QgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHVwZGF0ZVJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlc3Qgc3RhdGVcbiAgICAgICAgICAgICAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBwcmV0dHkgc2VsZiBleHBsYW5hdG9yeVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkZWQgbWl4aW5zXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZU1peGlucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhdGUgdXNlZCBmb3IgZWFjaCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiB3cml0ZXJzIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoaXMgdmlld1xuICAgICAgICAgICAgICAgIHZhciB3cml0ZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICB3cml0ZSwgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHJlYWQsIC8vIGRlZmF1bHQgcmVhZGVyXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXN0cm95ZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICBkZXN0cm95LCAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29yZSB2aWV3IG1ldGhvZHNcbiAgICAgICAgICAgICAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGdldENoaWxkVmlld3MgPSBmdW5jdGlvbiBnZXRDaGlsZFZpZXdzKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3cy5jb25jYXQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRSZWZlcmVuY2UgPSBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2aWV3LCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBfcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgY2hpbGQgdmlld3NcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuX3JlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9ICEoaWdub3JlUmVjdFVwZGF0ZSAmJiByZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMsIHJlY3Q6IHJlY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlcihhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV3JpdGUgZGF0YSB0byBET01cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBfd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUodHMsIGZyYW1lQWN0aW9ucywgc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdGluZyA9IGZyYW1lQWN0aW9ucy5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGVyc1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyUmVzdGluZyA9IHdyaXRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplOiBzaG91bGRPcHRpbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyUmVzdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbWl4aW5zIGlzIHN0aWxsIGJ1c3kgYWZ0ZXIgd3JpdGUgb3BlcmF0aW9uLCB3ZSBhcmUgbm90IHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaXhpblJlc3RpbmcgPSBtaXhpbi53cml0ZSh0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW5SZXN0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBjaGlsZCB2aWV3cyB0aGF0IGFyZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBjaGlsZCB2aWV3IGlzIG5vdCByZXN0aW5nLCB3ZSBhcmUgbm90IHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN0aW5nID0gY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQoY2hpbGQsIGZyYW1lQWN0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgbmV3IGVsZW1lbnRzIHRvIERPTSBhbmQgdXBkYXRlIHRob3NlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHJlYWQgKG5lZWQgdG8ga25vdyB0aGUgc2l6ZSBvZiB0aGVzZSBlbGVtZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY2FsbCB3cml0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl93cml0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGFkZGVkIHNvbXRoaW5nIHRvIHRoZSBkb20sIG5vIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcmVzdGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSByZXN0aW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpZFdyaXRlVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBwYXJlbnQga25vdyBpZiB3ZSBhcmUgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKGZ1bmN0aW9uKG1peGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWl4aW4uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVycy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVyKHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzaGFyZWRBUElcbiAgICAgICAgICAgICAgICB2YXIgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0Q2hpbGRWaWV3cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gcHJpdmF0ZSBBUEkgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbEFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgdG8gY3VzdG9tIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgICAgIGlzOiBmdW5jdGlvbiBpcyhuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBuZWVkbGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2hpbGRWaWV3OiBjcmVhdGVDaGlsZFZpZXcoc3RvcmUpLFxuICAgICAgICAgICAgICAgICAgICBsaW5rVmlldzogZnVuY3Rpb24gbGlua1ZpZXcodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVubGlua1ZpZXc6IGZ1bmN0aW9uIHVubGlua1ZpZXcodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoY2hpbGRWaWV3cy5pbmRleE9mKHZpZXcpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkVmlldzogcmVtb3ZlQ2hpbGRWaWV3KGVsZW1lbnQsIGNoaWxkVmlld3MpLFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcldyaXRlcjogZnVuY3Rpb24gcmVnaXN0ZXJXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVycy5wdXNoKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJveWVyKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlTGF5b3V0OiBmdW5jdGlvbiBpbnZhbGlkYXRlTGF5b3V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzIHRvIGRhdGEgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHN0b3JlLmRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBwdWJsaWMgdmlldyBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHZhciBleHRlcm5hbEFQSURlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1Jlc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGlzUmVjdElnbm9yZWQ6IGZ1bmN0aW9uIGlzUmVjdElnbm9yZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlUmVjdDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWQ6IF9yZWFkLFxuICAgICAgICAgICAgICAgICAgICBfd3JpdGU6IF93cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3k6IF9kZXN0cm95LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBtaXhpbiBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHZhciBtaXhpbkFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBtaXhpbiBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWl4aW5zKVxuICAgICAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHN0eWxlcyB0byB0aGUgYmFjayBvZiB0aGUgbWl4aW4gbGlzdCAoc28gYWRqdXN0bWVudHMgb2Ygb3RoZXIgbWl4aW5zIGFyZSBhcHBsaWVkIHRvIHRoZSBwcm9wcyBjb3JyZWN0bHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWl4aW5BUEkgPSBNaXhpbnNba2V5XSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1N0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEk6IGV4dGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjcmVhdGVPYmplY3QobWl4aW5BUElEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW5BUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMucHVzaChtaXhpbkFQSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc3RydWN0IHByaXZhdGUgYXBpXG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHZpZXdcbiAgICAgICAgICAgICAgICBjcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGNyZWF0ZWQgY2hpbGQgdmlld3MgdG8gcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBnZXRDaGlsZENvdW50KGVsZW1lbnQpOyAvLyBuZWVkIHRvIGtub3cgdGhlIGN1cnJlbnQgY2hpbGQgY291bnQgc28gYXBwZW5kaW5nIGhhcHBlbnMgaW4gY29ycmVjdCBvcmRlclxuICAgICAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgY2hpbGRDb3VudCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGwgZGlkIGNyZWF0ZVxuICAgICAgICAgICAgICAgIGRpZENyZWF0ZVZpZXcoaW50ZXJuYWxBUEkpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4dGVybmFsQVBJRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhaW50ZXIgPSBmdW5jdGlvbiBjcmVhdGVQYWludGVyKHJlYWQsIHdyaXRlKSB7XG4gICAgICAgIHZhciBmcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDYwO1xuXG4gICAgICAgIHZhciBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgICAgICAvLyBzZXQgZ2xvYmFsIHBhaW50ZXJcbiAgICAgICAgaWYgKHdpbmRvd1tuYW1lXSkge1xuICAgICAgICAgICAgd2luZG93W25hbWVdLnJlYWRlcnMucHVzaChyZWFkKTtcbiAgICAgICAgICAgIHdpbmRvd1tuYW1lXS53cml0ZXJzLnB1c2god3JpdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93W25hbWVdID0ge1xuICAgICAgICAgICAgcmVhZGVyczogW3JlYWRdLFxuICAgICAgICAgICAgd3JpdGVyczogW3dyaXRlXSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFpbnRlciA9IHdpbmRvd1tuYW1lXTtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICAgIHZhciBpZCA9IG51bGw7XG4gICAgICAgIHZhciByZXF1ZXN0VGljayA9IG51bGw7XG4gICAgICAgIHZhciBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgICAgICB2YXIgc2V0VGltZXJUeXBlID0gZnVuY3Rpb24gc2V0VGltZXJUeXBlKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpY2sgPSBmdW5jdGlvbiBjYW5jZWxUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICAgICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgICAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2sodHMpIHtcbiAgICAgICAgICAgIC8vIHF1ZXVlIG5leHQgdGlja1xuICAgICAgICAgICAgaWQgPSByZXF1ZXN0VGljayh0aWNrKTtcblxuICAgICAgICAgICAgLy8gbGltaXQgZnBzXG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHRzIC0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGRlbHRhIDw9IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxpZ24gbmV4dCBmcmFtZVxuICAgICAgICAgICAgbGFzdCA9IHRzIC0gKGRlbHRhICUgaW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlld1xuICAgICAgICAgICAgcGFpbnRlci5yZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhaW50ZXIud3JpdGVycy5mb3JFYWNoKGZ1bmN0aW9uKHdyaXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlKHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldFRpbWVyVHlwZSgpO1xuICAgICAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUocm91dGVzLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgICAgICAgIF9yZWYkYWN0aW9ucyA9IF9yZWYuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gX3JlZiRhY3Rpb25zID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkYWN0aW9ucyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfcmVmLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZSA9IF9yZWYuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlc1thY3Rpb24udHlwZV0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplOiBzaG91bGRPcHRpbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRyaW0gPSBmdW5jdGlvbiB0cmltKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcsJztcbiAgICAgICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgLnNwbGl0KHNwbGl0dGVyKVxuICAgICAgICAgICAgLm1hcCh0cmltKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNCb29sZWFuID0gZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9O1xuXG4gICAgdmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUgPT09ICd0cnVlJztcbiAgICB9O1xuXG4gICAgdmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfTtcblxuICAgIHZhciB0b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IHRvU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bYS16XSsvZ2ksICcnKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG5cbiAgICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9OdW1iZXIodmFsdWUpLCAxMCk7XG4gICAgfTtcblxuICAgIHZhciB0b0Zsb2F0ID0gZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuICAgIH07XG5cbiAgICB2YXIgaXNJbnQgPSBmdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciB0b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAgICAgLy8gaXMgaW4gYnl0ZXNcbiAgICAgICAgaWYgKGlzSW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXMgbmF0dXJhbCBmaWxlIHNpemVcbiAgICAgICAgdmFyIG5hdHVyYWxGaWxlU2l6ZSA9IHRvU3RyaW5nKHZhbHVlKS50cmltKCk7XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgICAgIGlmICgvTUIkL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgICAgICBuYXR1cmFsRmlsZVNpemUgPSBuYXR1cmFsRmlsZVNpemUucmVwbGFjZSgvTUIkaS8sICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKSAqIGJhc2UgKiBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsdWUgaW4ga2lsb2J5dGVzXG4gICAgICAgIGlmICgvS0IvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9LQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xuICAgIH07XG5cbiAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuXG4gICAgdmFyIHRvRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHN0cmluZykge1xuICAgICAgICB2YXIgcmVmID0gc2VsZjtcbiAgICAgICAgdmFyIGxldmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgICAgICB3aGlsZSAoKGxldmVsID0gbGV2ZWxzLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICByZWYgPSByZWZbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgcHJvY2VzczogJ1BPU1QnLFxuICAgICAgICBwYXRjaDogJ1BBVENIJyxcbiAgICAgICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICAgICAgZmV0Y2g6ICdHRVQnLFxuICAgICAgICByZXN0b3JlOiAnR0VUJyxcbiAgICAgICAgbG9hZDogJ0dFVCcsXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTZXJ2ZXJBUEkgPSBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJBUEkob3V0bGluZSkge1xuICAgICAgICB2YXIgYXBpID0ge307XG5cbiAgICAgICAgYXBpLnVybCA9IGlzU3RyaW5nKG91dGxpbmUpID8gb3V0bGluZSA6IG91dGxpbmUudXJsIHx8ICcnO1xuICAgICAgICBhcGkudGltZW91dCA9IG91dGxpbmUudGltZW91dCA/IHBhcnNlSW50KG91dGxpbmUudGltZW91dCwgMTApIDogMDtcbiAgICAgICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgICAgICBmb3JpbihtZXRob2RzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGFwaVtrZXldID0gY3JlYXRlQWN0aW9uKGtleSwgb3V0bGluZVtrZXldLCBtZXRob2RzW2tleV0sIGFwaS50aW1lb3V0LCBhcGkuaGVhZGVycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBwcm9jZXNzIGlmIG5vIHVybCBvciBwcm9jZXNzIG9uIG91dGxpbmVcbiAgICAgICAgYXBpLnByb2Nlc3MgPSBvdXRsaW5lLnByb2Nlc3MgfHwgaXNTdHJpbmcob3V0bGluZSkgfHwgb3V0bGluZS51cmwgPyBhcGkucHJvY2VzcyA6IG51bGw7XG5cbiAgICAgICAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yIHJlbW92ZVxuICAgICAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgICAgICAvLyByZW1vdmUgZ2VuZXJpYyBoZWFkZXJzIGZyb20gYXBpIG9iamVjdFxuICAgICAgICBkZWxldGUgYXBpLmhlYWRlcnM7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihuYW1lLCBvdXRsaW5lLCBtZXRob2QsIHRpbWVvdXQsIGhlYWRlcnMpIHtcbiAgICAgICAgLy8gaXMgZXhwbGljaXRlbHkgc2V0IHRvIG51bGwgc28gZGlzYWJsZVxuICAgICAgICBpZiAob3V0bGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBjdXN0b20gZnVuY3Rpb24sIGRvbmUhIERldiBoYW5kbGVzIGV2ZXJ5dGhpbmcuXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhY3Rpb24gb2JqZWN0XG4gICAgICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICAgICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gJz8nICsgbmFtZSArICc9JyA6ICcnLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICAgICAgICBvbmRhdGE6IG51bGwsXG4gICAgICAgICAgICBvbmVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgICAgICBpZiAoaXNTdHJpbmcob3V0bGluZSkpIHtcbiAgICAgICAgICAgIGFjdGlvbi51cmwgPSBvdXRsaW5lO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJ3cml0ZVxuICAgICAgICBPYmplY3QuYXNzaWduKGFjdGlvbiwgb3V0bGluZSk7XG5cbiAgICAgICAgLy8gc2VlIGlmIHNob3VsZCByZWZvcm1hdCBoZWFkZXJzO1xuICAgICAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBhY3Rpb24uaGVhZGVycy5zcGxpdCgvOiguKykvKTtcbiAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRzWzFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGJvb2wgd2l0aENyZWRlbnRpYWxzXG4gICAgICAgIGFjdGlvbi53aXRoQ3JlZGVudGlhbHMgPSB0b0Jvb2xlYW4oYWN0aW9uLndpdGhDcmVkZW50aWFscyk7XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIHRvU2VydmVyQVBJID0gZnVuY3Rpb24gdG9TZXJ2ZXJBUEkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlckFQSSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGlzQVBJID0gZnVuY3Rpb24gaXNBUEkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNTdHJpbmcodmFsdWUudXJsKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUucHJvY2VzcykgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLnJldmVydCkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLnJlc3RvcmUpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZS5mZXRjaClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXlswLTldKyA/KD86R0J8TUJ8S0IpJC9naS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdieXRlcyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBUEkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FwaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgcmVwbGFjZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIHJlcGxhY2VTaW5nbGVRdW90ZXMoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC97XFxzKicvZywgJ3tcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJ1xccyp9L2csICdcIn0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLydcXHMqOi9nLCAnXCI6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC86XFxzKicvZywgJzpcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvLFxccyonL2csICcsXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLydcXHMqLC9nLCAnXCIsJyk7XG4gICAgfTtcblxuICAgIHZhciBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgICAgIGFycmF5OiB0b0FycmF5LFxuICAgICAgICBib29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgICAgIGludDogZnVuY3Rpb24gaW50KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiB0b0Zsb2F0LFxuICAgICAgICBmbG9hdDogdG9GbG9hdCxcbiAgICAgICAgYnl0ZXM6IHRvQnl0ZXMsXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb246IGZ1bmN0aW9uIF9mdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvRnVuY3Rpb25SZWZlcmVuY2UodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBjb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8odmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRWYWx1ZUJ5VHlwZSA9IGZ1bmN0aW9uIGdldFZhbHVlQnlUeXBlKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSkge1xuICAgICAgICAvLyBjYW4gYWx3YXlzIGFzc2lnbiBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgICAgICB2YXIgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShuZXdWYWx1ZSk7XG5cbiAgICAgICAgLy8gaXMgdmFsaWQgdHlwZT9cbiAgICAgICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAgICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgICAgICAgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShjb252ZXJ0ZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICAgICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVHJ5aW5nIHRvIGFzc2lnbiB2YWx1ZSB3aXRoIGluY29ycmVjdCB0eXBlIHRvIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiArXG4gICAgICAgICAgICAgICAgICAgICdcIiwgYWxsb3dlZCB0eXBlOiBcIicgK1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzaWduIG5ldyB2YWx1ZVxuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVPcHRpb24oZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkRlZmluaXRpb24gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gY3JlYXRlT3B0aW9uKG9wdGlvbkRlZmluaXRpb25bMF0sIG9wdGlvbkRlZmluaXRpb25bMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChvYmopO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFN0YXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIG1vZGVsXG4gICAgICAgICAgICBpdGVtczogW10sXG5cbiAgICAgICAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3IgY2FsbGluZyB1cGRhdGUgaXRlbXNcbiAgICAgICAgICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICAgICAgICAgIGl0ZW1VcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgICAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGZyb21DYW1lbHMgPSBmdW5jdGlvbiBmcm9tQ2FtZWxzKHN0cmluZykge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLSc7XG4gICAgICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgICAgIC5zcGxpdCgvKD89W0EtWl0pLylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvbkFQSSA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdTRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9uQWN0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkFjdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgb2JqWydTRVRfJyArIG5hbWVdID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zW2tleV0gPSBhY3Rpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIG5vcGUsIGZhaWxlZFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU0VUXycgKyBuYW1lLCB7IHZhbHVlOiBzdGF0ZS5vcHRpb25zW2tleV0gfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvblF1ZXJpZXMgPSBmdW5jdGlvbiBjcmVhdGVPcHRpb25RdWVyaWVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBvYmpbJ0dFVF8nICsgZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKV0gPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSW50ZXJhY3Rpb25NZXRob2QgPSB7XG4gICAgICAgIEFQSTogMSxcbiAgICAgICAgRFJPUDogMixcbiAgICAgICAgQlJPV1NFOiAzLFxuICAgICAgICBQQVNURTogNCxcbiAgICAgICAgTk9ORTogNSxcbiAgICB9O1xuXG4gICAgdmFyIGdldFVuaXF1ZUlkID0gZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAgICAgICAuc3Vic3RyKDIsIDkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gICAgfVxuXG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICAgIGZ1bmN0aW9uIF9qc3godHlwZSwgcHJvcHMsIGtleSwgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgICAgICAgICAgICAgMHhlYWM3O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgICAgIGlmICghcHJvcHMgJiYgY2hpbGRyZW5MZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB2b2lkIDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBrZXk6IGtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsga2V5LFxuICAgICAgICAgICAgcmVmOiBudWxsLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgX293bmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY0l0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBtZXRob2Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgICAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gJ3JldHVybicgOiAnbm9ybWFsJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgICAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgICB9O1xuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gICAgfTtcblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3JldHVybicsIGFyZyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoaW5uZXIsIGF3YWl0V3JhcCkge1xuICAgICAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAod2FpdGluZykge1xuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXIudGhyb3cgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3JldHVybicsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAnbmV4dCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBvYmplY3RTeW1ib2xzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICBfZXh0ZW5kcyA9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KVxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICAgICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgICAgICAgID8gb2JqXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG9iaixcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25ld0Fycm93Q2hlY2soaW5uZXJUaGlzLCBib3VuZFRoaXMpIHtcbiAgICAgICAgaWYgKGlubmVyVGhpcyAhPT0gYm91bmRUaGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgYW4gYXJyb3cgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3REZXN0cnVjdHVyaW5nRW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGRlc3RydWN0dXJlIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgICAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjYWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlc2M7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICAgICAgICB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcblxuICAgICAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGVtcG9yYWxSZWYodmFsLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgaXMgcmVhZC1vbmx5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzTmFtZVREWkVycm9yKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBcIicgKyBuYW1lICsgJ1wiIGNhbm5vdCBiZSByZWZlcmVuY2VkIGluIGNvbXB1dGVkIHByb3BlcnR5IGtleXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIF90ZW1wb3JhbFVuZGVmaW5lZCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgICAgICAgcmV0dXJuIGFycjI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgICAgICB2YXIgX2FyciA9IFtdO1xuICAgICAgICB2YXIgX24gPSB0cnVlO1xuICAgICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgICAgICBfZSA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10gIT0gbnVsbCkgX2lbJ3JldHVybiddKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHtcbiAgICAgICAgdmFyIF9hcnIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7ICkge1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaXQubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgICAgICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cbiAgICAgICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoaGludCA9PT0gJ3N0cmluZycgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICAgICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsICdzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArXG4gICAgICAgICAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgICAgICAgICAnVG8gdXNlIHByb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaW4gc3BlYyBtb2RlIHdpdGggZGVjb3JhdG9ycywgd2FpdCBmb3IgJyArXG4gICAgICAgICAgICAgICAgJ3RoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgZGVjb3JhdG9ycyBpbiBzdGFnZSAyLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVzYyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IGRlY29yYXRvcnNcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGRlc2MsIGRlY29yYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgIH0sIGRlc2MpO1xuXG4gICAgICAgIGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgZGVzYyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG5cbiAgICB2YXIgaWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VCYXNlKHJlY2VpdmVyLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlY2VpdmVyLCBwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHVzZSBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkRGVzdHJ1Y3R1cmVTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgaWYgKCEoJ19fZGVzdHJPYmonIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5fX2Rlc3RyT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXQgdmFsdWUodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlRmllbGRTcGVjR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNTZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7XG4gICAgICAgIHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpO1xuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBpID0gbWl4aW5zW2ldKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7XG4gICAgICAgICAgICBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgfSwgc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgICAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgICAgICAgIGRlY29yYXRvcnNcbiAgICAgICAgKTtcbiAgICAgICAgYXBpLmluaXRpYWxpemVDbGFzc0VsZW1lbnRzKHIuRiwgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXREZWNvcmF0b3JzQXBpKCkge1xuICAgICAgICBfZ2V0RGVjb3JhdG9yc0FwaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbJ21ldGhvZCddLCBbJ2ZpZWxkJ11dLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uKE8sIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSAnb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQua2luZCA9PT0ga2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09ICdzdGF0aWMnID8gRiA6IHByb3RvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmaW5lQ2xhc3NFbGVtZW50OiBmdW5jdGlvbihyZWNlaXZlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3duOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaGVycyA9IGZpbmlzaGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50LmtleSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKGVsZW1lbnRPYmplY3QpIHx8IGVsZW1lbnRPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFeHRyYXMgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZXh0cmFzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhcy5wdXNoLmFwcGx5KGV4dHJhcywgbmV3RXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYXM6IGV4dHJhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c0FuZEZpbmlzaGVyID0gdGhpcy50b0NsYXNzRGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9ialxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnRzW2pdLmtleSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24oZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9BcnJheShlbGVtZW50T2JqZWN0cykubWFwKGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZXh0cmFzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyAmJiBraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIGVpdGhlciBcIm1ldGhvZFwiIG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSAnc3RhdGljJyAmJiBwbGFjZW1lbnQgIT09ICdwcm90b3R5cGUnICYmIHBsYWNlbWVudCAhPT0gJ293bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFwicHJvdG90eXBlXCIgb3IgXCJvd25cIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIC5wbGFjZW1lbnQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2VsZW1lbnRzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2luaXRpYWxpemVyJywgJ0EgbWV0aG9kIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KGVsZW1lbnRPYmplY3QsICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlcixcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFzOiBleHRyYXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcob2JqLmtpbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGNyZWF0ZWQgYSBjbGFzcyBkZXNjcmlwdG9yIHdpdGggLmtpbmQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2tleScsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdkZXNjcmlwdG9yJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdpbml0aWFsaXplcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuQ2xhc3NGaW5pc2hlcnM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmaW5pc2hlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhbGxvd1Byb3BlcnR5OiBmdW5jdGlvbihvYmosIG5hbWUsIG9iamVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmplY3RUeXBlICsgXCIgY2FuJ3QgaGF2ZSBhIC5cIiArIG5hbWUgKyAnIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikge1xuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgaWYgKGRlZi5raW5kID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGdldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIHNldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBraW5kOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdmaWVsZCcgOiAnbWV0aG9kJyxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcGxhY2VtZW50OiBkZWYuc3RhdGljID8gJ3N0YXRpYycgOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdvd24nIDogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgICAgICBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikge1xuICAgICAgICBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29hbGVzY2VDbGFzc0VsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmXG4gICAgICAgICAgICAgICAgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJiAob3RoZXIgPSBuZXdFbGVtZW50cy5maW5kKGlzU2FtZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBtZXRob2RzICgnICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIHNhbWUgcHJvcGVydHkgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5rZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRlY29yYXRvcnMgJiYgZWxlbWVudC5kZWNvcmF0b3JzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNEYXRhRGVzY3JpcHRvcihkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQgJiYgIShkZXNjLnZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVzYy53cml0YWJsZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQocmVjZWl2ZXIsIHByaXZhdGVTZXQsIGZuKSB7XG4gICAgICAgIGlmICghcHJpdmF0ZVNldC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3dyYXBSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgICBfd3JhcFJlZ0V4cCA9IGZ1bmN0aW9uKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIGdyb3Vwcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9SZWdFeHAgPSBfd3JhcE5hdGl2ZVN1cGVyKFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbiAgICAgICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9SZWdFeHAuY2FsbCh0aGlzLCByZSk7XG5cbiAgICAgICAgICAgIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQuZ3JvdXBzID0gYnVpbGRHcm91cHMocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gX2dyb3Vwcy5nZXQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbi5yZXBsYWNlKC9cXCQ8KFtePl0rKT4vZywgZnVuY3Rpb24oXywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckJyArIGdyb3Vwc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbGRHcm91cHMoYXJncywgX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcbiAgICAgICAgICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZykucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgbmFtZSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlSZW1vdmUgPSBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihjYiwgc3luYykge1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQsIGNiKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZShcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50ICYmIChsaXN0ZW5lci5jYiA9PT0gY2IgfHwgIWNiKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9maXJlID0gZnVuY3Rpb24gZmlyZShldmVudCwgYXJncywgc3luYykge1xuICAgICAgICAgICAgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2I7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc3luYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJlU3luYzogZnVuY3Rpb24gZmlyZVN5bmMoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZmlyZShldmVudCwgYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gZmlyZShldmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2tleTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MisrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maXJlKGV2ZW50LCBhcmdzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBjYjogY2IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PbmNlOiBmdW5jdGlvbiBvbk9uY2UoZXZlbnQsIF9jYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYjogZnVuY3Rpb24gY2IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYoZXZlbnQsIF9jYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZjogb2ZmLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgICAgIHNyYyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBleGNsdWRlZFxuICAgICkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFleGNsdWRlZC5pbmNsdWRlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrZXkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgUFJJVkFURSA9IFtcbiAgICAgICAgJ2ZpcmUnLFxuICAgICAgICAncHJvY2VzcycsXG4gICAgICAgICdyZXZlcnQnLFxuICAgICAgICAnbG9hZCcsXG4gICAgICAgICdvbicsXG4gICAgICAgICdvZmYnLFxuICAgICAgICAnb25PbmNlJyxcbiAgICAgICAgJ3JldHJ5TG9hZCcsXG4gICAgICAgICdleHRlbmQnLFxuICAgICAgICAnYXJjaGl2ZScsXG4gICAgICAgICdhcmNoaXZlZCcsXG4gICAgICAgICdyZWxlYXNlJyxcbiAgICAgICAgJ3JlbGVhc2VkJyxcbiAgICAgICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAgICAgJ2ZyZWV6ZScsXG4gICAgXTtcblxuICAgIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcbiAgICAgICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChpdGVtLCBhcGksIFBSSVZBVEUpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVsZWFzZWRJdGVtcyA9IGZ1bmN0aW9uIHJlbW92ZVJlbGVhc2VkSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShpdGVtcywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgICAgIElOSVQ6IDEsXG4gICAgICAgIElETEU6IDIsXG4gICAgICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgICAgICBQUk9DRVNTSU5HOiAzLFxuICAgICAgICBQUk9DRVNTSU5HX0NPTVBMRVRFOiA1LFxuICAgICAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgICAgICBQUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogMTAsXG4gICAgICAgIExPQURJTkc6IDcsXG4gICAgICAgIExPQURfRVJST1I6IDgsXG4gICAgfTtcblxuICAgIHZhciBGaWxlT3JpZ2luID0ge1xuICAgICAgICBJTlBVVDogMSxcbiAgICAgICAgTElNQk86IDIsXG4gICAgICAgIExPQ0FMOiAzLFxuICAgIH07XG5cbiAgICB2YXIgZ2V0Tm9uTnVtZXJpYyA9IGZ1bmN0aW9uIGdldE5vbk51bWVyaWMoc3RyKSB7XG4gICAgICAgIHJldHVybiAvW14wLTldKy8uZXhlYyhzdHIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBnZXROb25OdW1lcmljKCgxLjEpLnRvTG9jYWxlU3RyaW5nKCkpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkge1xuICAgICAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgdGhlIG5vcm1hbCB0b1N0cmluZyBvdXRwdXQgYW5kIGlmIHRoZXkncmUgdGhlIHNhbWUgcmV0dXJuIGEgY29tbWEgd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBpcyBhIGRvdFxuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IGdldERlY2ltYWxTZXBhcmF0b3IoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciA9ICgxMDAwLjApLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yICE9PSB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Tm9uTnVtZXJpYyh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaW1hbFNlcGFyYXRvciA9PT0gJy4nID8gJywnIDogJy4nO1xuICAgIH07XG5cbiAgICB2YXIgVHlwZSA9IHtcbiAgICAgICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgICAgICBJTlQ6ICdpbnQnLFxuICAgICAgICBOVU1CRVI6ICdudW1iZXInLFxuICAgICAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgICAgICBBUlJBWTogJ2FycmF5JyxcbiAgICAgICAgT0JKRUNUOiAnb2JqZWN0JyxcbiAgICAgICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgICAgIFNFUlZFUl9BUEk6ICdzZXJ2ZXJhcGknLFxuICAgICAgICBSRUdFWDogJ3JlZ2V4JyxcbiAgICB9O1xuXG4gICAgLy8gYWxsIHJlZ2lzdGVyZWQgZmlsdGVyc1xuICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gICAgdmFyIGFwcGx5RmlsdGVyQ2hhaW4gPSBmdW5jdGlvbiBhcHBseUZpbHRlckNoYWluKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmNiO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIG5vd1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciB0byBraWNrIHRoaW5ncyBvZlxuICAgICAgICAgICAgdmFyIGluaXRpYWxGaWx0ZXIgPSBtYXRjaGluZ0ZpbHRlcnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gY2hhaW4gZmlsdGVyc1xuICAgICAgICAgICAgbWF0Y2hpbmdGaWx0ZXJzXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHByb21pc2VzIHBhc3NpbmcgdmFsdWUgdG8gbmV4dCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCh2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBpbml0aWFsIGZpbHRlciwgd2lsbCByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxGaWx0ZXIodmFsdWUsIHV0aWxzKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5rZXkgPT09IGtleTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5jYih2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBsaXN0XG4gICAgdmFyIGFkZEZpbHRlciA9IGZ1bmN0aW9uIGFkZEZpbHRlcihrZXksIGNiKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzLnB1c2goeyBrZXk6IGtleSwgY2I6IGNiIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIGZvcmluKG9wdHMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGtleSBkb2VzIG5vdCBleGlzdCwgc28gdGhpcyBvcHRpb24gY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0T3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVswXSA9IGdldFZhbHVlQnlUeXBlKFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICBpZDogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpbnB1dCBmaWVsZCBuYW1lIHRvIHVzZVxuICAgICAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGZpZWxkXG4gICAgICAgIGRpc2FibGVkOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgICAgIGNsYXNzTmFtZTogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpcyB0aGUgZmllbGQgcmVxdWlyZWRcbiAgICAgICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBBbGxvdyBtZWRpYSBjYXB0dXJlIHdoZW4gdmFsdWUgaXMgc2V0XG4gICAgICAgIGNhcHR1cmVNZXRob2Q6IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAgICAgLy8gLSBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGlwbGUgb24gYXBwbGUgZGV2aWNlc1xuICAgICAgICAvLyAtIElmIHNldCwgYWNjZXB0ZWRGaWxlVHlwZXMgbXVzdCBiZSBtYWRlIHRvIG1hdGNoIHdpdGggbWVkaWEgd2lsZGNhcmQgXCJpbWFnZS8qXCIsIFwiYXVkaW8vKlwiIG9yIFwidmlkZW8vKlwiXG5cbiAgICAgICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgICAgIGFsbG93U3luY0FjY2VwdEF0dHJpYnV0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gRmVhdHVyZSB0b2dnbGVzXG4gICAgICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93QnJvd3NlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgYnJvd3NpbmcgdGhlIGZpbGUgc3lzdGVtXG4gICAgICAgIGFsbG93UGFzdGU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBwYXN0aW5nIGZpbGVzXG4gICAgICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgICAgICBhbGxvd1JlcGxhY2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBhIGZpbGUgb24gb3RoZXIgZmlsZSB0byByZXBsYWNlIGl0IChvbmx5IHdvcmtzIHdoZW4gbXVsdGlwbGUgaXMgc2V0IHRvIGZhbHNlKVxuICAgICAgICBhbGxvd1JldmVydDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHJldmVydCBmaWxlIHVwbG9hZFxuICAgICAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgICAgICBhbGxvd1Byb2Nlc3M6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byBwcm9jZXNzIGEgZmlsZSwgd2hlbiBzZXQgdG8gZmFsc2UsIHRoaXMgcmVtb3ZlcyB0aGUgZmlsZSB1cGxvYWQgYnV0dG9uXG4gICAgICAgIGFsbG93UmVvcmRlcjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyByZW9yZGVyaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAgICAgLy8gVHJ5IHN0b3JlIGZpbGUgaWYgYHNlcnZlcmAgbm90IHNldFxuICAgICAgICBzdG9yZUFzRmlsZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIFJldmVydCBtb2RlXG4gICAgICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgICAgICAvLyBJbnB1dCByZXF1aXJlbWVudHNcbiAgICAgICAgbWF4RmlsZXM6IFtudWxsLCBUeXBlLklOVF0sIC8vIE1heCBudW1iZXIgb2YgZmlsZXNcbiAgICAgICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgICAgIC8vIFdoZXJlIHRvIHB1dCBmaWxlXG4gICAgICAgIGl0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb206IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTZXQgdG8gZmFsc2UgdG8gYWx3YXlzIGFkZCBpdGVtcyB0byBiZWdpbiBvciBlbmQgb2YgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0SW50ZXJ2YWw6IFs3NSwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIERyYWcgJ24gRHJvcCByZWxhdGVkXG4gICAgICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BPbkVsZW1lbnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBEcm9wIG5lZWRzIHRvIGhhcHBlbiBvbiBlbGVtZW50IChzZXQgdG8gZmFsc2UgdG8gYWxzbyBsb2FkIGRyb3BzIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BWYWxpZGF0aW9uOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBvciBkaXNhYmxlIHZhbGlkYXRpbmcgZmlsZXMgb24gZHJvcFxuICAgICAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAgICAgLy8gVXBsb2FkIHJlbGF0ZWRcbiAgICAgICAgaW5zdGFudFVwbG9hZDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIFNob3VsZCB1cGxvYWQgZmlsZXMgaW1tZWRpYXRlbHkgb24gZHJvcFxuICAgICAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG4gICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gaWYgdHJ1ZSB1cGxvYWRzIHRha2UgYXQgbGVhc3QgNzUwIG1zLCB0aGlzIGVuc3VyZXMgdGhlIHVzZXIgc2VlcyB0aGUgdXBsb2FkIHByb2dyZXNzIGdpdmluZyB0cnVzdCB0aGUgdXBsb2FkIGFjdHVhbGx5IGhhcHBlbmVkXG5cbiAgICAgICAgLy8gQ2h1bmtzXG4gICAgICAgIGNodW5rVXBsb2FkczogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgY2h1bmtlZCB1cGxvYWRzXG4gICAgICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICAgICAgY2h1bmtTaXplOiBbNTAwMDAwMCwgVHlwZS5JTlRdLCAvLyBTaXplIG9mIGNodW5rcyAoNU1CIGRlZmF1bHQpXG4gICAgICAgIGNodW5rUmV0cnlEZWxheXM6IFtbNTAwLCAxMDAwLCAzMDAwXSwgVHlwZS5BUlJBWV0sIC8vIEFtb3VudCBvZiB0aW1lcyB0byByZXRyeSB1cGxvYWQgb2YgYSBjaHVuayB3aGVuIGl0IGZhaWxzXG5cbiAgICAgICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgICAgIHNlcnZlcjogW251bGwsIFR5cGUuU0VSVkVSX0FQSV0sXG5cbiAgICAgICAgLy8gRmlsZSBzaXplIGNhbGN1bGF0aW9ucywgY2FuIHNldCB0byAxMDI0LCB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGlzcGxheSwgcHJvcGVydGllcyB1c2UgZmlsZSBzaXplIGJhc2UgMTAwMFxuICAgICAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTGFiZWxzIGFuZCBzdGF0dXMgbWVzc2FnZXNcbiAgICAgICAgbGFiZWxEZWNpbWFsU2VwYXJhdG9yOiBbZ2V0RGVjaW1hbFNlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuICAgICAgICBsYWJlbFRob3VzYW5kc1NlcGFyYXRvcjogW2dldFRob3VzYW5kc1NlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuXG4gICAgICAgIGxhYmVsSWRsZTogW1xuICAgICAgICAgICAgJ0RyYWcgJiBEcm9wIHlvdXIgZmlsZXMgb3IgPHNwYW4gY2xhc3M9XCJmaWxlcG9uZC0tbGFiZWwtYWN0aW9uXCI+QnJvd3NlPC9zcGFuPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVXYWl0aW5nRm9yU2l6ZTogWydXYWl0aW5nIGZvciBzaXplJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplTm90QXZhaWxhYmxlOiBbJ1NpemUgbm90IGF2YWlsYWJsZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUNvdW50UGx1cmFsOiBbJ2ZpbGVzIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUxvYWRpbmc6IFsnTG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgICAgIGxhYmVsRmlsZUxvYWRFcnJvcjogWydFcnJvciBkdXJpbmcgbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUmVtb3ZlZDogWydSZW1vdmVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgICAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVQcm9jZXNzaW5nOiBbJ1VwbG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0NvbXBsZXRlOiBbJ1VwbG9hZCBjb21wbGV0ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yOiBbJ0Vycm9yIGR1cmluZyB1cGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcjogWydFcnJvciBkdXJpbmcgcmV2ZXJ0JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxUYXBUb1JldHJ5OiBbJ3RhcCB0byByZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxUYXBUb1VuZG86IFsndGFwIHRvIHVuZG8nLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkOiBbJ0Fib3J0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbUxvYWQ6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nOiBbJ1VuZG8nLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uUmV0cnlJdGVtUHJvY2Vzc2luZzogWydSZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdpZHRoIGFuZCBoZWlnaHQgcGx1cyB2aWV3cG94IGFyZSBldmVuIG51bWJlcnMgc28gaWNvbnMgYXJlIG5pY2VseSBjZW50ZXJlZFxuICAgICAgICBpY29uUmVtb3ZlOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTEuNTg2IDEzbC0yLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQgMS40MTRMMTMgMTQuNDE0bDIuMjkzIDIuMjkzYTEgMSAwIDAgMCAxLjQxNC0xLjQxNEwxNC40MTQgMTNsMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0LTEuNDE0TDEzIDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0IDEuNDE0TDExLjU4NiAxM3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblByb2Nlc3M6IFtcbiAgICAgICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNCAxMC40MTR2My41ODVhMSAxIDAgMCAxLTIgMHYtMy41ODVsLTEuMjkzIDEuMjkzYTEgMSAwIDAgMS0xLjQxNC0xLjQxNWwzLTNhMSAxIDAgMCAxIDEuNDE0IDBsMyAzYTEgMSAwIDAgMS0xLjQxNCAxLjQxNUwxNCAxMC40MTR6TTkgMThhMSAxIDAgMCAxIDAtMmg4YTEgMSAwIDAgMSAwIDJIOXpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblJldHJ5OiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTAuODEgOS4xODVsLS4wMzguMDJBNC45OTcgNC45OTcgMCAwIDAgOCAxMy42ODNhNSA1IDAgMCAwIDUgNSA1IDUgMCAwIDAgNS01IDEgMSAwIDAgMSAyIDBBNyA3IDAgMSAxIDkuNzIyIDcuNDk2bC0uODQyLS4yMWEuOTk5Ljk5OSAwIDEgMSAuNDg0LTEuOTRsMy4yMy44MDZjLjUzNS4xMzMuODYuNjc1LjczIDEuMjFsLS44MDQgMy4yMzNhLjk5Ny45OTcgMCAwIDEtMS4yMS43My45OTcuOTk3IDAgMCAxLS43My0xLjIxbC4yMy0uOTI4di0uMDAyelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBpY29uVW5kbzogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTkuMTg1IDEwLjgxbC4wMi0uMDM4QTQuOTk3IDQuOTk3IDAgMCAxIDEzLjY4MyA4YTUgNSAwIDAgMSA1IDUgNSA1IDAgMCAxLTUgNSAxIDEgMCAwIDAgMCAyQTcgNyAwIDEgMCA3LjQ5NiA5LjcyMmwtLjIxLS44NDJhLjk5OS45OTkgMCAxIDAtMS45NC40ODRsLjgwNiAzLjIzYy4xMzMuNTM1LjY3NS44NiAxLjIxLjczbDMuMjMzLS44MDNhLjk5Ny45OTcgMCAwIDAgLjczLTEuMjEuOTk3Ljk5NyAwIDAgMC0xLjIxLS43M2wtLjkyOC4yMy0uMDAyLS4wMDF6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25Eb25lOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTguMjkzIDkuMjkzYTEgMSAwIDAgMSAxLjQxNCAxLjQxNGwtNy4wMDIgN2ExIDEgMCAwIDEtMS40MTQgMGwtMy45OTgtNGExIDEgMCAxIDEgMS40MTQtMS40MTRMMTIgMTUuNTg2bDYuMjk0LTYuMjkzelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgICAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb253YXJuaW5nOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uZXJyb3I6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25pbml0ZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmFkZGZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZXN0YXJ0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlYWJvcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZXJldmVydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucmVtb3ZlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9udXBkYXRlZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25yZW9yZGVyZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgICAvLyBob29rc1xuICAgICAgICBiZWZvcmVEcm9wRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBiZWZvcmVBZGRGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgYmVmb3JlUHJlcGFyZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgc3R5bGVQYW5lbExheW91dDogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCAnaW50ZWdyYXRlZCcsICdjb21wYWN0JywgJ2NpcmNsZSdcbiAgICAgICAgc3R5bGVQYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLCAvLyBudWxsIG9yICczOjInIG9yIDFcbiAgICAgICAgc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb246IFsnbGVmdCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBzdHlsZUxvYWRJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVQcm9ncmVzc0luZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBzdHlsZUJ1dHRvblJlbW92ZUl0ZW1BbGlnbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIGN1c3RvbSBpbml0aWFsIGZpbGVzIGFycmF5XG4gICAgICAgIGZpbGVzOiBbW10sIFR5cGUuQVJSQVldLFxuXG4gICAgICAgIC8vIHNob3cgc3VwcG9ydCBieSBkaXNwbGF5aW5nIGNyZWRpdHNcbiAgICAgICAgY3JlZGl0czogW1snaHR0cHM6Ly9wcWluYS5ubC8nLCAnUG93ZXJlZCBieSBQUUlOQSddLCBUeXBlLkFSUkFZXSxcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1CeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUJ5UXVlcnkoaXRlbXMsIHF1ZXJ5KSB7XG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWVyeSBpcyBpbmRleFxuICAgICAgICBpZiAoaXNJbnQocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXNbcXVlcnldIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBxdWVyeSBpcyBpdGVtLCBnZXQgdGhlIGlkXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1lIHF1ZXJ5IGlzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRlbSBieSBpZFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXRlbXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHF1ZXJ5O1xuICAgICAgICAgICAgfSkgfHwgbnVsbFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGZ1bmN0aW9uIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC86Ly50ZXN0KGFzcGVjdFJhdGlvKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1sxXSAvIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFzcGVjdFJhdGlvKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEFjdGl2ZUl0ZW1zID0gZnVuY3Rpb24gZ2V0QWN0aXZlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIWl0ZW0uYXJjaGl2ZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgU3RhdHVzID0ge1xuICAgICAgICBFTVBUWTogMCxcbiAgICAgICAgSURMRTogMSwgLy8gd2FpdGluZ1xuICAgICAgICBFUlJPUjogMiwgLy8gYSBmaWxlIGlzIGluIGVycm9yIHN0YXRlXG4gICAgICAgIEJVU1k6IDMsIC8vIGJ1c3kgcHJvY2Vzc2luZyBvciBsb2FkaW5nXG4gICAgICAgIFJFQURZOiA0LCAvLyBhbGwgZmlsZXMgdXBsb2FkZWRcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IG51bGw7XG4gICAgdmFyIGNhblVwZGF0ZUZpbGVJbnB1dCA9IGZ1bmN0aW9uIGNhblVwZGF0ZUZpbGVJbnB1dCgpIHtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQobmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnVGhpc19Xb3Jrcy50eHQnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgICAgICAgIGVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGVsLmZpbGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciBJVEVNX0VSUk9SID0gW1xuICAgICAgICBJdGVtU3RhdHVzLkxPQURfRVJST1IsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUixcbiAgICBdO1xuXG4gICAgdmFyIElURU1fQlVTWSA9IFtcbiAgICAgICAgSXRlbVN0YXR1cy5MT0FESU5HLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkcsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQsXG4gICAgICAgIEl0ZW1TdGF0dXMuSU5JVCxcbiAgICBdO1xuXG4gICAgdmFyIElURU1fUkVBRFkgPSBbSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFXTtcblxuICAgIHZhciBpc0l0ZW1JbkVycm9yU3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkVycm9yU3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9FUlJPUi5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gICAgfTtcbiAgICB2YXIgaXNJdGVtSW5CdXN5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkJ1c3lTdGF0ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICAgIH07XG4gICAgdmFyIGlzSXRlbUluUmVhZHlTdGF0ZSA9IGZ1bmN0aW9uIGlzSXRlbUluUmVhZHlTdGF0ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBJVEVNX1JFQURZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQXN5bmMgPSBmdW5jdGlvbiBpc0FzeW5jKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlcikgJiZcbiAgICAgICAgICAgIChpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSB8fCBpc0Z1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcXVlcmllcyA9IGZ1bmN0aW9uIHF1ZXJpZXMoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEdFVF9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9TVEFUVVMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgICAgIHZhciBFTVBUWSA9IFN0YXR1cy5FTVBUWSxcbiAgICAgICAgICAgICAgICAgICAgRVJST1IgPSBTdGF0dXMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIEJVU1kgPSBTdGF0dXMuQlVTWSxcbiAgICAgICAgICAgICAgICAgICAgSURMRSA9IFN0YXR1cy5JRExFLFxuICAgICAgICAgICAgICAgICAgICBSRUFEWSA9IFN0YXR1cy5SRUFEWTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluRXJyb3JTdGF0ZSkpIHJldHVybiBFUlJPUjtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluQnVzeVN0YXRlKSkgcmV0dXJuIEJVU1k7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JblJlYWR5U3RhdGUpKSByZXR1cm4gUkVBRFk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gSURMRTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9JVEVNOiBmdW5jdGlvbiBHRVRfSVRFTShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0FDVElWRV9JVEVNOiBmdW5jdGlvbiBHRVRfQUNUSVZFX0lURU0ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLCBxdWVyeSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfQUNUSVZFX0lURU1TOiBmdW5jdGlvbiBHRVRfQUNUSVZFX0lURU1TKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTVM6IGZ1bmN0aW9uIEdFVF9JVEVNUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuaXRlbXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9OQU1FOiBmdW5jdGlvbiBHRVRfSVRFTV9OQU1FKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlbmFtZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9TSVpFOiBmdW5jdGlvbiBHRVRfSVRFTV9TSVpFKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlU2l6ZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfU1RZTEVTOiBmdW5jdGlvbiBHRVRfU1RZTEVTKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9ec3R5bGUvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogb3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0ZS5vcHRpb25zW29wdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2hhcGVDaXJjbGUgPSAvY2lyY2xlLy50ZXN0KHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbExheW91dCk7XG4gICAgICAgICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gaXNTaGFwZUNpcmNsZVxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbEFzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUub3B0aW9ucy5zdHlsZUl0ZW1QYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1TX0JZX1NUQVRVUzogZnVuY3Rpb24gR0VUX0lURU1TX0JZX1NUQVRVUyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnN0YXR1cyA9PT0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX1RPVEFMX0lURU1TOiBmdW5jdGlvbiBHRVRfVE9UQUxfSVRFTVMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQ6IGZ1bmN0aW9uIFNIT1VMRF9VUERBVEVfRklMRV9JTlBVVCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUub3B0aW9ucy5zdG9yZUFzRmlsZSAmJiBjYW5VcGRhdGVGaWxlSW5wdXQoKSAmJiAhaXNBc3luYyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBJU19BU1lOQzogZnVuY3Rpb24gSVNfQVNZTkMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQXN5bmMoc3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGhhc1Jvb21Gb3JJdGVtID0gZnVuY3Rpb24gaGFzUm9vbUZvckl0ZW0oc3RhdGUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBpdGVtcywgdG8gYWRkIG9uZSBpdGVtIGl0IHNob3VsZCBjdXJyZW50bHkgbm90IGNvbnRhaW4gaXRlbXNcbiAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGFsbG93cyBtdWx0aXBsZSBpdGVtcywgd2UgY2hlY2sgaWYgYSBtYXggaXRlbSBjb3VudCBoYXMgYmVlbiBzZXQsIGlmIG5vdCwgdGhlcmUncyBubyBsaW1pdFxuICAgICAgICB2YXIgbWF4RmlsZUNvdW50ID0gc3RhdGUub3B0aW9ucy5tYXhGaWxlcztcbiAgICAgICAgaWYgKG1heEZpbGVDb3VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBjaGVjayBpZiB0aGUgY3VycmVudCBjb3VudCBpcyBzbWFsbGVyIHRoYW4gdGhlIG1heCBjb3VudCwgaWYgc28sIGFub3RoZXIgZmlsZSBjYW4gc3RpbGwgYmUgYWRkZWRcbiAgICAgICAgaWYgKGNvdW50IDwgbWF4RmlsZUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIG1vcmUgcm9vbSBmb3IgYW5vdGhlciBmaWxlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGxpbWl0ID0gZnVuY3Rpb24gbGltaXQodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXgsIHZhbHVlKSwgbWluKTtcbiAgICB9O1xuXG4gICAgdmFyIGFycmF5SW5zZXJ0ID0gZnVuY3Rpb24gYXJyYXlJbnNlcnQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgfTtcblxuICAgIHZhciBpbnNlcnRJdGVtID0gZnVuY3Rpb24gaW5zZXJ0SXRlbShpdGVtcywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaW5kZXggaXMgdW5kZWZpbmVkLCBhcHBlbmRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0IHRoZSBpbmRleCB0byB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMgYXJyYXlcbiAgICAgICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgaXRlbXMubGVuZ3RoKTtcblxuICAgICAgICAvLyBhZGQgaXRlbSB0byBhcnJheVxuICAgICAgICBhcnJheUluc2VydChpdGVtcywgaW5kZXgsIGl0ZW0pO1xuXG4gICAgICAgIC8vIGV4cG9zZVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGlzQmFzZTY0RGF0YVVSSShzdHIpIHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2Etei1dKz1bYS16MC05LV0rKT8pPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHNdKilcXHMqJC9pLnRlc3QoXG4gICAgICAgICAgICBzdHJcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVuYW1lRnJvbVVSTCA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgLnNwbGl0KCc/JylcbiAgICAgICAgICAgIC5zaGlmdCgpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lID0gZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB9O1xuXG4gICAgdmFyIGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ3Vlc3N0aW1hdGVFeHRlbnNpb24odHlwZSkge1xuICAgICAgICAvLyBpZiBubyBleHRlbnNpb24gc3VwcGxpZWQsIGV4aXQgaGVyZVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgc3VidHlwZVxuICAgICAgICB2YXIgc3VidHlwZSA9IHR5cGUuc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgICAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgICAgICBpZiAoL3N2Zy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdzdmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC96aXB8Y29tcHJlc3NlZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICd6aXAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9wbGFpbi8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICd0eHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9tc3dvcmQvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIHZhbGlkIHN1YnR5cGVcbiAgICAgICAgaWYgKC9bYS16XSsvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyB1c2UganBnIGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKHN1YnR5cGUgPT09ICdqcGVnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnanBnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuIHN1YnR5cGVcbiAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICB2YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIGxlZnRQYWQodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgICAgICByZXR1cm4gKHBhZGRpbmcgKyB2YWx1ZSkuc2xpY2UoLXBhZGRpbmcubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldERhdGVTdHJpbmcgPSBmdW5jdGlvbiBnZXREYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldERhdGUoKSwgJzAwJykgK1xuICAgICAgICAgICAgJ18nICtcbiAgICAgICAgICAgIGxlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldE1pbnV0ZXMoKSwgJzAwJykgK1xuICAgICAgICAgICAgJy0nICtcbiAgICAgICAgICAgIGxlZnRQYWQoZGF0ZS5nZXRTZWNvbmRzKCksICcwMCcpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlRnJvbUJsb2IgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJsb2IoYmxvYiwgZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICAgIHZhciBmaWxlID1cbiAgICAgICAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIHR5cGUpXG4gICAgICAgICAgICAgICAgOiBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgYmxvYi50eXBlKTtcbiAgICAgICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICAgICAgaWYgKGJsb2IuX3JlbGF0aXZlUGF0aCkgZmlsZS5fcmVsYXRpdmVQYXRoID0gYmxvYi5fcmVsYXRpdmVQYXRoO1xuXG4gICAgICAgIC8vIGlmIGJsb2IgaGFzIG5hbWUgcHJvcGVydHksIHVzZSBhcyBmaWxlbmFtZSBpZiBubyBmaWxlbmFtZSBzdXBwbGllZFxuICAgICAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBnZXREYXRlU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBmaWxlbmFtZSBzdXBwbGllZCBidXQgbm8gZXh0ZW5zaW9uIGFuZCBmaWxlbmFtZSBoYXMgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChmaWxlbmFtZSAmJiBleHRlbnNpb24gPT09IG51bGwgJiYgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24gfHwgZ3Vlc3N0aW1hdGVFeHRlbnNpb24oZmlsZS50eXBlKTtcbiAgICAgICAgICAgIGZpbGUubmFtZSA9IGZpbGVuYW1lICsgKGV4dGVuc2lvbiA/ICcuJyArIGV4dGVuc2lvbiA6ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkJ1aWxkZXIgPSBmdW5jdGlvbiBnZXRCbG9iQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuQmxvYkJ1aWxkZXIgPVxuICAgICAgICAgICAgd2luZG93LkJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgICAgIHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgd2luZG93Lk1TQmxvYkJ1aWxkZXIpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQmxvYiA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2IoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBCQiA9IGdldEJsb2JCdWlsZGVyKCk7XG5cbiAgICAgICAgaWYgKEJCKSB7XG4gICAgICAgICAgICB2YXIgYmIgPSBuZXcgQkIoKTtcbiAgICAgICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYmIuZ2V0QmxvYihtaW1lVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlID0gZnVuY3Rpb24gZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlKFxuICAgICAgICBieXRlU3RyaW5nLFxuICAgICAgICBtaW1lVHlwZVxuICAgICkge1xuICAgICAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShhYik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmVhdGVCbG9iKGFiLCBtaW1lVHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgICAgIHJldHVybiAoL15kYXRhOiguKyk7Ly5leGVjKGRhdGFVUkkpIHx8IFtdKVsxXSB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgICAgICB2YXIgZGF0YSA9IGRhdGFVUkkuc3BsaXQoJywnKVsxXTtcblxuICAgICAgICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgYXMgdGhhdCBjYXVzZXMgSW52YWxpZENoYXJhY3RlckVycm9yIGluIElFXG4gICAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICByZXR1cm4gYXRvYihnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgdmFyIG1pbWVUeXBlID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcbiAgICAgICAgdmFyIGJ5dGVTdHJpbmcgPSBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSk7XG5cbiAgICAgICAgcmV0dXJuIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZShieXRlU3RyaW5nLCBtaW1lVHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSwgZmlsZW5hbWUsIGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZ2V0RmlsZUZyb21CbG9iKGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSwgZmlsZW5hbWUsIG51bGwsIGV4dGVuc2lvbik7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlTmFtZUZyb21IZWFkZXIgPSBmdW5jdGlvbiBnZXRGaWxlTmFtZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgaXMgY29udGVudCBkaXNwb3NpdGlvbiBoZWFkZXIsIGlmIG5vdCBleGl0XG4gICAgICAgIGlmICghL15jb250ZW50LWRpc3Bvc2l0aW9uOi9pLnRlc3QoaGVhZGVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IGZpbGVuYW1lIHBhcnRzXG4gICAgICAgIHZhciBtYXRjaGVzID0gaGVhZGVyXG4gICAgICAgICAgICAuc3BsaXQoL2ZpbGVuYW1lPXxmaWxlbmFtZVxcKj0uKycnLylcbiAgICAgICAgICAgIC5zcGxpY2UoMSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnRyaW0oKS5yZXBsYWNlKC9eW1wiJ118WztcIiddezAsMn0kL2csICcnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPyBkZWNvZGVVUkkobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlU2l6ZUZyb21IZWFkZXIgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIGlmICgvY29udGVudC1sZW5ndGg6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlci5tYXRjaCgvWzAtOV0rLylbMF07XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSA/IHBhcnNlSW50KHNpemUsIDEwKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRUcmFuZnNlcklkRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoL3gtY29udGVudC10cmFuc2Zlci1pZDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IChoZWFkZXIuc3BsaXQoJzonKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIGlkIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzID0gZnVuY3Rpb24gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvd3MgPSBoZWFkZXJzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gcm93c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgICAgICAgICAgICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZpbGVMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWxlTG9hZGVyKGZldGNoRm4pIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBzaXplOiBudWxsLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0ICYmIHN0YXRlLnJlcXVlc3QuYWJvcnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZCBzb3VyY2VcbiAgICAgICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICAgICAgLy8gZ2V0IHF1aWNrIHJlZmVyZW5jZVxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcblxuICAgICAgICAgICAgYXBpLmZpcmUoJ2luaXQnLCBzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBMb2FkIEZpbGVzXG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgYmxvYnMsIHNldCBkZWZhdWx0IG5hbWUgdG8gY3VycmVudCBkYXRlXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBnZXRGaWxlRnJvbUJsb2Ioc291cmNlLCBzb3VyY2UubmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVhbCBhcyBpZiBpcyBleHRlcm5hbCBVUkwsIGxldCdzIGxvYWQgaXQhXG4gICAgICAgICAgICAgICAgbG9hZFVSTChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxvYWRzIGEgdXJsXG4gICAgICAgIHZhciBsb2FkVVJMID0gZnVuY3Rpb24gbG9hZFVSTCh1cmwpIHtcbiAgICAgICAgICAgIC8vIGlzIHJlbW90ZSB1cmwgYW5kIG5vIGZldGNoIG1ldGhvZCBzdXBwbGllZFxuICAgICAgICAgICAgaWYgKCFmZXRjaEZuKSB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBcIkNhbid0IGxvYWQgVVJMXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDQwMCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIGxvYWQgZmlsZVxuICAgICAgICAgICAgc3RhdGUucmVxdWVzdCA9IGZldGNoRm4oXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHR1cm4gYmxvYiByZXNwb25zZSBpbnRvIGEgZmlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGdldEZpbGVGcm9tQmxvYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgYmxvYiwgd2UgZ28gd2l0aCBibG9iLCBpZiBubyByZXNwb25zZSwgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlIGluc3RhbmNlb2YgQmxvYiA/IHJlc3BvbnNlIDogcmVzcG9uc2UgPyByZXNwb25zZS5ib2R5IDogbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0ZWQgc29tZSBtZXRhIGRhdGEgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNpemUgPSB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSBwcm9ncmVzcywgd2UncmUgbm90IGdvaW5nIHRvIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHByb2dyZXNzIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjdXJyZW50IC8gdG90YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIHN0YXRlLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlaW5mbyA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdtZXRhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBmaWxlaW5mby5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVpbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGVpbmZvLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbih7fSwgb24oKSwge1xuICAgICAgICAgICAgc2V0U291cmNlOiBmdW5jdGlvbiBzZXRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5zb3VyY2UgPSBzb3VyY2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFByb2dyZXNzOiBnZXRQcm9ncmVzcywgLy8gZmlsZSBsb2FkIHByb2dyZXNzXG4gICAgICAgICAgICBhYm9ydDogYWJvcnQsIC8vIGFib3J0IGZpbGUgbG9hZFxuICAgICAgICAgICAgbG9hZDogbG9hZCwgLy8gc3RhcnQgbG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgaXNHZXQgPSBmdW5jdGlvbiBpc0dldChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIC9HRVR8SEVBRC8udGVzdChtZXRob2QpO1xuICAgIH07XG5cbiAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiBzZW5kUmVxdWVzdChkYXRhLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIG9uaGVhZGVyczogZnVuY3Rpb24gb25oZWFkZXJzKCkge30sXG4gICAgICAgICAgICBvbnByb2dyZXNzOiBmdW5jdGlvbiBvbnByb2dyZXNzKCkge30sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICAgICAgb250aW1lb3V0OiBmdW5jdGlvbiBvbnRpbWVvdXQoKSB7fSxcbiAgICAgICAgICAgIG9uZXJyb3I6IGZ1bmN0aW9uIG9uZXJyb3IoKSB7fSxcbiAgICAgICAgICAgIG9uYWJvcnQ6IGZ1bmN0aW9uIG9uYWJvcnQoKSB7fSxcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICAgICAgdmFyIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhlYWRlcnNSZWNlaXZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZW5jb2RlIHVybFxuICAgICAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcblxuICAgICAgICAvLyBpZiBtZXRob2QgaXMgR0VULCBhZGQgYW55IHJlY2VpdmVkIGRhdGEgdG8gdXJsXG5cbiAgICAgICAgaWYgKGlzR2V0KG9wdGlvbnMubWV0aG9kKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICB1cmwgPVxuICAgICAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgICAgICB1cmwgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVlc3RcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIHByb2dyZXNzIG9mIGxvYWRcbiAgICAgICAgdmFyIHByb2Nlc3MgPSBpc0dldChvcHRpb25zLm1ldGhvZCkgPyB4aHIgOiB4aHIudXBsb2FkO1xuICAgICAgICBwcm9jZXNzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBubyBwcm9ncmVzcyBldmVudCB3aGVuIGFib3J0ZWQgKCBvbnByb2dyZXNzIGlzIGNhbGxlZCBvbmNlIGFmdGVyIGFib3J0KCkgKVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFwaS5vbnByb2dyZXNzKGUubGVuZ3RoQ29tcHV0YWJsZSwgZS5sb2FkZWQsIGUudG90YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRyaWVzIHRvIGdldCBoZWFkZXIgaW5mbyB0byB0aGUgYXBwIGFzIGZhc3QgYXMgcG9zc2libGVcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gbm90IGludGVyZXN0aW5nIGluIHRoZXNlIHN0YXRlcyAoJ3Vuc2VudCcgYW5kICdvcGVuZW5kJyBhcyB0aGV5IGRvbid0IGdpdmUgdXMgYW55IGFkZGl0aW9uYWwgaW5mbylcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHNlcnZlciByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcnNSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHdlJ3ZlIHByb2JhYmx5IHJlY2VpdmVkIHNvbWUgdXNlZnVsIGRhdGEgaW4gcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgYXBpLm9uaGVhZGVycyh4aHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxvYWQgc3VjY2Vzc2Z1bFxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpcyBjbGFzc2lmaWVkIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGFwaS5vbmxvYWQoeGhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBlcnJvciBkdXJpbmcgbG9hZFxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5vbmVycm9yKHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGFwaS5vbmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGkub250aW1lb3V0KHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb3BlbiB1cCBvcGVuIHVwIVxuICAgICAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAvLyBzZXQgdGltZW91dCBpZiBkZWZpbmVkIChkbyBpdCBhZnRlciBvcGVuIHNvIElFMTEgcGxheXMgYmFsbClcbiAgICAgICAgaWYgKGlzSW50KG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGhlYWRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaGVhZGVyc1trZXldKSk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0IHR5cGUgb2YgcmVzcG9uc2VcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY3JlZGVudGlhbHNcbiAgICAgICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCdzIHNlbmQgb3VyIGRhdGFcbiAgICAgICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlc3BvbnNlID0gZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2UodHlwZSwgY29kZSwgYm9keSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRpbWVvdXRSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShjYikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaGFzUVMgPSBmdW5jdGlvbiBoYXNRUyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIC9cXD8vLnRlc3Qoc3RyKTtcbiAgICB9O1xuICAgIHZhciBidWlsZFVSTCA9IGZ1bmN0aW9uIGJ1aWxkVVJMKCkge1xuICAgICAgICB2YXIgdXJsID0gJyc7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgdXJsICs9IGhhc1FTKHVybCkgJiYgaGFzUVMocGFydCkgPyBwYXJ0LnJlcGxhY2UoL1xcPy8sICcmJykgOiBwYXJ0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZldGNoRnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVGZXRjaEZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXBpVXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGRvIGxvY2FsIG9yIHJlbW90ZSByZXF1ZXN0IGJhc2VkIG9uIGlmIHRoZSB1cmwgaXMgZXh0ZXJuYWxcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIC8vIGdldCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGdldEZpbGVGcm9tQmxvYihvbmxvYWQoeGhyLnJlc3BvbnNlKSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzKGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgQ2h1bmtTdGF0dXMgPSB7XG4gICAgICAgIFFVRVVFRDogMCxcbiAgICAgICAgQ09NUExFVEU6IDEsXG4gICAgICAgIFBST0NFU1NJTkc6IDIsXG4gICAgICAgIEVSUk9SOiAzLFxuICAgICAgICBXQUlUSU5HOiA0LFxuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6KCkgPT4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8vIGFwaVVybCwgYWN0aW9uLCBuYW1lLCBmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnNcbiAgICB2YXIgcHJvY2Vzc0ZpbGVDaHVua2VkID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICBhcGlVcmwsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGxvYWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHRyYW5zZmVyLFxuICAgICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICAgIC8vIGFsbCBjaHVua3NcbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUcmFuc2ZlcklkID0gb3B0aW9ucy5jaHVua1RyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua1NlcnZlciA9IG9wdGlvbnMuY2h1bmtTZXJ2ZXIsXG4gICAgICAgICAgICBjaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgIGNodW5rUmV0cnlEZWxheXMgPSBvcHRpb25zLmNodW5rUmV0cnlEZWxheXM7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBzdGF0ZVxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBzZXJ2ZXJJZDogY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IG9ubG9hZCBoYW5kbGVyc1xuICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmRhdGEgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih4aHIsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QgPT09ICdIRUFEJyA/IHhoci5nZXRSZXNwb25zZUhlYWRlcignVXBsb2FkLU9mZnNldCcpIDogeGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICAgICAgdmFyIHJlcXVlc3RUcmFuc2ZlcklkID0gZnVuY3Rpb24gcmVxdWVzdFRyYW5zZmVySWQoY2IpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKGZpbGUsIG1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICBvbmRhdGEoZm9ybURhdGEpLFxuICAgICAgICAgICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0ID0gZnVuY3Rpb24gcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGNiKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdFVybCA9IGJ1aWxkVVJMKGFwaVVybCwgY2h1bmtTZXJ2ZXIudXJsLCBzdGF0ZS5zZXJ2ZXJJZCk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhzdGF0ZS5zZXJ2ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24uaGVhZGVycyk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHJlcXVlc3RVcmwsIHJlcXVlc3RQYXJhbXMpO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNyZWF0ZSBjaHVua3NcbiAgICAgICAgdmFyIGxhc3RDaHVua0luZGV4ID0gTWF0aC5mbG9vcihmaWxlLnNpemUgLyBjaHVua1NpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXN0Q2h1bmtJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSwgJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKTtcbiAgICAgICAgICAgIGNodW5rc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IF90b0NvbnN1bWFibGVBcnJheShjaHVua1JldHJ5RGVsYXlzKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IENodW5rU3RhdHVzLlFVRVVFRCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyA9IGZ1bmN0aW9uIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcygpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkKHN0YXRlLnNlcnZlcklkKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2FuUHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gY2FuUHJvY2Vzc0NodW5rKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5RVUVVRUQgfHwgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcHJvY2Vzc0NodW5rKGNodW5rKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIGlzIHBhdXNlZCwgd2FpdCBoZXJlXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBnZXQgbmV4dCBjaHVuayB0byBwcm9jZXNzXG4gICAgICAgICAgICBjaHVuayA9IGNodW5rIHx8IGNodW5rcy5maW5kKGNhblByb2Nlc3NDaHVuayk7XG5cbiAgICAgICAgICAgIC8vIG5vIG1vcmUgY2h1bmtzIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgZG9uZT9cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5ldmVyeShmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLnN0YXR1cyA9PT0gQ2h1bmtTdGF0dXMuQ09NUExFVEU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vIGNodW5rIHRvIGhhbmRsZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHByb2Nlc3NpbmcgdGhpcyBjaHVua1xuICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuUFJPQ0VTU0lORztcbiAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gYWxsb3cgcGFyc2luZyBvZiBmb3JtZGF0YVxuICAgICAgICAgICAgdmFyIG9uZGF0YSA9XG4gICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXIub25kYXRhIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXIub25lcnJvciB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdFVybCA9IGJ1aWxkVVJMKGFwaVVybCwgY2h1bmtTZXJ2ZXIudXJsLCBzdGF0ZS5zZXJ2ZXJJZCk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgY2h1bmtTZXJ2ZXIuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGNodW5rU2VydmVyLmhlYWRlcnMoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIuaGVhZGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IGNodW5rLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTmFtZSc6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSAoY2h1bmsucmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShjaHVuay5kYXRhKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXJsLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGNodW5rU2VydmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuQ09NUExFVEU7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVxdWVzdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgbW9yZSBjaHVua3NcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBsZW5ndGhDb21wdXRhYmxlID8gbG9hZGVkIDogbnVsbDtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaHVuay5lcnJvciA9IG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpKHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuUVVFVUVEO1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXRyeVByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIHJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSB7XG4gICAgICAgICAgICAvLyBubyBtb3JlIHJldHJpZXMgbGVmdFxuICAgICAgICAgICAgaWYgKGNodW5rLnJldHJpZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIG5ldyByZXRyeVxuICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuV0FJVElORztcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjaHVuay50aW1lb3V0KTtcbiAgICAgICAgICAgIGNodW5rLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgICAgICB9LCBjaHVuay5yZXRyaWVzLnNoaWZ0KCkpO1xuXG4gICAgICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byByZXRyeVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB1cGRhdGVUb3RhbFByb2dyZXNzKCkge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRvdGFsIHByb2dyZXNzIGZyYWN0aW9uXG4gICAgICAgICAgICB2YXIgdG90YWxCeXRlc1RyYW5zZmVyZWQgPSBjaHVua3MucmVkdWNlKGZ1bmN0aW9uKHAsIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IG51bGwgfHwgY2h1bmsucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBwICsgY2h1bmsucHJvZ3Jlc3M7XG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgLy8gY2FuJ3QgY29tcHV0ZSBwcm9ncmVzc1xuICAgICAgICAgICAgaWYgKHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID09PSBudWxsKSByZXR1cm4gcHJvZ3Jlc3MoZmFsc2UsIDAsIDApO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcHJvZ3Jlc3MgdmFsdWVzXG4gICAgICAgICAgICB2YXIgdG90YWxTaXplID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKyBjaHVuay5zaXplO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNhbiB1cGRhdGUgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICAgICAgICBwcm9ncmVzcyh0cnVlLCB0b3RhbEJ5dGVzVHJhbnNmZXJlZCwgdG90YWxTaXplKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwcm9jZXNzIG5ldyBjaHVua3NcbiAgICAgICAgdmFyIHByb2Nlc3NDaHVua3MgPSBmdW5jdGlvbiBwcm9jZXNzQ2h1bmtzKCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsUHJvY2Vzc2luZyA9IGNodW5rcy5maWx0ZXIoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsUHJvY2Vzc2luZyA+PSAxKSByZXR1cm47XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWJvcnRDaHVua3MgPSBmdW5jdGlvbiBhYm9ydENodW5rcygpIHtcbiAgICAgICAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjaHVuay5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsZXQncyBnbyFcbiAgICAgICAgaWYgKCFzdGF0ZS5zZXJ2ZXJJZCkge1xuICAgICAgICAgICAgcmVxdWVzdFRyYW5zZmVySWQoZnVuY3Rpb24oc2VydmVySWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHBhc3MgYmFjayB0byBpdGVtIHNvIHdlIGNhbiB1c2UgaXQgaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcihzZXJ2ZXJJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUcmFuc2Zlck9mZnNldChmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG1hcmsgY2h1bmtzIHdpdGggbG93ZXIgb2Zmc2V0IGFzIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5vZmZzZXQgPCBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gY2h1bmsuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFib3J0Q2h1bmtzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OigpID0+IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdmFyIGNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbihcbiAgICAgICAgYXBpVXJsLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlcikge1xuICAgICAgICAgICAgLy8gbm8gZmlsZSByZWNlaXZlZFxuICAgICAgICAgICAgaWYgKCFmaWxlKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGlmIHdhcyBwYXNzZWQgYSBmaWxlLCBhbmQgd2UgY2FuIGNodW5rIGl0LCBleGl0IGhlcmVcbiAgICAgICAgICAgIHZhciBjYW5DaHVua1VwbG9hZCA9IG9wdGlvbnMuY2h1bmtVcGxvYWRzO1xuICAgICAgICAgICAgdmFyIHNob3VsZENodW5rVXBsb2FkID0gY2FuQ2h1bmtVcGxvYWQgJiYgZmlsZS5zaXplID4gb3B0aW9ucy5jaHVua1NpemU7XG4gICAgICAgICAgICB2YXIgd2lsbENodW5rVXBsb2FkID0gY2FuQ2h1bmtVcGxvYWQgJiYgKHNob3VsZENodW5rVXBsb2FkIHx8IG9wdGlvbnMuY2h1bmtGb3JjZSk7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgJiYgd2lsbENodW5rVXBsb2FkKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRmlsZUNodW5rZWQoXG4gICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBzZXQgaGFuZGxlcnNcbiAgICAgICAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICAgICAgICAgIGFjdGlvbi5vbmRhdGEgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmxvYWQgPVxuICAgICAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhmaWxlLCBtZXRhZGF0YSkgfHwge31cbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgZm9ybWRhdGEgb2JqZWN0XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICAgICAgLy8gYWRkIG1ldGFkYXRhIHVuZGVyIHNhbWUgbmFtZVxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUdXJuIGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyBzbyBubyBtYXR0ZXIgd2hhdCB0aGUgaW5wdXQsIHdlIGNhbiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5XG4gICAgICAgICAgICAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgPyBbeyBuYW1lOiBudWxsLCBmaWxlOiBmaWxlIH1dIDogZmlsZSkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubmFtZSA9PT0gbnVsbCA/IGl0ZW0uZmlsZS5uYW1lIDogJycgKyBpdGVtLm5hbWUgKyBpdGVtLmZpbGUubmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICBvbmRhdGEoZm9ybURhdGEpLFxuICAgICAgICAgICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXBpVXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5hcHBseSh2b2lkIDAsIFtuYW1lXS5jb25jYXQocGFyYW1zLCBbb3B0aW9uc10pKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gaW50ZXJuYWwgaGFuZGxlclxuICAgICAgICByZXR1cm4gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSA9PiB7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdmFyIGNyZWF0ZVJldmVydEZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGlVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGlzIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGFjdGlvbiBzdXBwbGllZCwgcmV0dXJuIHN0dWIgZnVuY3Rpb24sIGludGVyZmFjZSB3aWxsIHdvcmssIGJ1dCBmaWxlIHdvbid0IGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICB1bmlxdWVGaWxlSWQsXG4gICAgICAgICAgICAgICAgYXBpVXJsICsgYWN0aW9uLnVybCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gLy8gY29udGFpbnMgbWV0aG9kLCBoZWFkZXJzIGFuZCB3aXRoQ3JlZGVudGlhbHMgcHJvcGVydGllc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRSYW5kb21OdW1iZXIgPSBmdW5jdGlvbiBnZXRSYW5kb21OdW1iZXIoKSB7XG4gICAgICAgIHZhciBtaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBtYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSBmdW5jdGlvbiBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIoY2IpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICB2YXIgdGlja01pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMjU7XG4gICAgICAgIHZhciB0aWNrTWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAyNTA7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IGdldFJhbmRvbU51bWJlcih0aWNrTWluLCB0aWNrTWF4KTtcblxuICAgICAgICAgICAgaWYgKHJ1bnRpbWUgKyBkZWxheSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBydW50aW1lICsgZGVsYXkgLSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gcnVudGltZSAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzID49IDEgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY2IoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIGRlbGF5KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB0aWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvciA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVQcm9jZXNzb3IocHJvY2Vzc0ZuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcmNlaXZlZFByb2dyZXNzOiAwLFxuICAgICAgICAgICAgcGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyOiBudWxsLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBwZXJjZWl2ZWREdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gPSBvcHRpb25zLmFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uO1xuXG4gICAgICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhmaWxlLCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzRm4gPSBmdW5jdGlvbiBwcm9ncmVzc0ZuKCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIG5vdCB5ZXQgc3RhcnRlZCB0aGUgcmVhbCBkb3dubG9hZCwgc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgbWlnaHQgbm90IGdvIHRocm91Z2gsIGZvciBpbnN0YW5jZSwgdGhlcmUgbWlnaHQgYmUgc29tZSBzZXJ2ZXIgdHJvdWJsZVxuICAgICAgICAgICAgICAgIC8vIGlmIHN0YXRlLnByb2dyZXNzIGlzIG51bGwsIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWxsb3cgY29tcHV0aW5nIHByb2dyZXNzIGFuZCB3ZSBzaG93IHRoZSBzcGlubmVyIGluc3RlYWRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZHVyYXRpb24gPT09IDAgfHwgc3RhdGUucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIGFzIHdlJ3JlIG5vdyBwcm9jZXNzaW5nLCBmaXJlIHRoZSBwcm9ncmVzcyBldmVudFxuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIGFwaS5nZXRQcm9ncmVzcygpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gY29tcGxldGVGbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQtcGVyY2VpdmVkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBsZXQncyBzdGFydCBwcm9jZXNzaW5nXG4gICAgICAgICAgICBhcGkuZmlyZSgnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwZXJjZWl2ZWQgcGVyZm9ybWFuY2UgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzRm4oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmYWtlIHByb2dyZXNzIGlzIGRvbmUsIGFuZCBhIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd2UndmUgbm90IHlldCBjYWxsZWQgdGhlIGNvbXBsZXRlIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUucmVzcG9uc2UgJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEgJiYgIXN0YXRlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyByYW5kb20gZGVsYXkgYXMgaW4gYSBsaXN0IG9mIGZpbGVzIHlvdSBzdGFydCBub3RpY2luZ1xuICAgICAgICAgICAgICAgIC8vIGZpbGVzIHVwbG9hZGluZyBhdCB0aGUgZXhhY3Qgc2FtZSBzcGVlZFxuICAgICAgICAgICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uID8gZ2V0UmFuZG9tTnVtYmVyKDc1MCwgMTUwMCkgOiAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyByZW1lbWJlciByZXF1ZXN0IHNvIHdlIGNhbiBhYm9ydCBpdCBsYXRlclxuICAgICAgICAgICAgc3RhdGUucmVxdWVzdCA9IHByb2Nlc3NGbihcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlsZSB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgZmlsZSxcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBtZXRhZGF0YSB0byBzZW5kIGFsb25nXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgKGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKVxuICAgICAgICAgICAgICAgIC8vIGxvYWQgZXhwZWN0cyB0aGUgYm9keSB0byBiZSBhIHNlcnZlciBpZCBpZlxuICAgICAgICAgICAgICAgIC8vIHlvdSB3YW50IHRvIG1ha2UgdXNlIG9mIHJldmVydFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHB1dCB0aGUgcmVzcG9uc2UgaW4gc3RhdGUgc28gd2UgY2FuIGFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBvdXRzaWRlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gaXNPYmplY3QocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIHByb2dyZXNzIHRvIDEgYXMgd2UncmUgbm93IGRvbmVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBsb2FkIGlzIGRvbmUgbGV0J3Mgc2hhcmUgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSByZWFsbHkgZG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwZXJjZWl2ZWQgcHJvZ3Jlc3MgaXMgMSAoIHdhaXQgZm9yIHBlcmNlaXZlZCBwcm9ncmVzcyB0byBjb21wbGV0ZSApXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzICggbnVsbCApXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICFhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uICYmIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0eXBlLCBjb2RlLCBib2R5XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsIHVwZGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIG90aGVycyBhYm91dCB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJycgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIHByb2Nlc3NpbmcgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gY29tcHV0YWJsZSA/IGN1cnJlbnQgLyB0b3RhbCA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NGbigpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBkb2VzIG5vdCBleHBlY3QgYSB2YWx1ZVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSB0aGUgYWJvcnQgZXZlbnQgc28gd2UgY2FuIHN3aXRjaCB2aXN1YWxzXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcsIHN0YXRlLnJlc3BvbnNlID8gc3RhdGUucmVzcG9uc2UuYm9keSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaWQgZm9yIHRoaXMgdHJhbnNmZXJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih0cmFuc2ZlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCd0cmFuc2ZlcicsIHRyYW5zZmVySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICAvLyBubyByZXF1ZXN0IHJ1bm5pbmcsIGNhbid0IGFib3J0XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnJlcXVlc3QpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gc3RvcCB1cGRhdGVyXG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgLy8gYWJvcnQgYWN0dWFsIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0LmFib3J0KSBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGhhcyByZXNwb25zZSBvYmplY3QsIHdlJ3ZlIGNvbXBsZXRlZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGUucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5yZXNwb25zZSA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFByb2dyZXNzID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3MgPyBNYXRoLm1pbihzdGF0ZS5wcm9ncmVzcywgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MpIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5wcm9ncmVzcyB8fCBudWxsO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXREdXJhdGlvbiA9IGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uXG4gICAgICAgICAgICA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHN0YXRlLmR1cmF0aW9uLCBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZHVyYXRpb247XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oe30sIG9uKCksIHtcbiAgICAgICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsIC8vIHN0YXJ0IHByb2Nlc3NpbmcgZmlsZVxuICAgICAgICAgICAgYWJvcnQ6IGFib3J0LCAvLyBhYm9ydCBhY3RpdmUgcHJvY2VzcyByZXF1ZXN0XG4gICAgICAgICAgICBnZXRQcm9ncmVzczogZ2V0UHJvZ3Jlc3MsXG4gICAgICAgICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICAgICAgICByZXNldDogcmVzZXQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5zdWJzdHIoMCwgbmFtZS5sYXN0SW5kZXhPZignLicpKSB8fCBuYW1lO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmlsZVN0dWIgPSBmdW5jdGlvbiBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbc291cmNlLm5hbWUsIHNvdXJjZS5zaXplLCBzb3VyY2UudHlwZV07XG5cbiAgICAgICAgLy8gaXMgYmxvYiBvciBiYXNlNjQsIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhlIG5hbWVcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IgfHwgaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGRhdGFbMF0gPSBzb3VyY2UubmFtZSB8fCBnZXREYXRlU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIGlzIGJhc2U2NCBkYXRhIHVyaSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIGFuZCB0eXBlXG4gICAgICAgICAgICBkYXRhWzFdID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGRhdGFbMl0gPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoc291cmNlKSkge1xuICAgICAgICAgICAgLy8gdXJsXG4gICAgICAgICAgICBkYXRhWzBdID0gZ2V0RmlsZW5hbWVGcm9tVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICBkYXRhWzFdID0gMDtcbiAgICAgICAgICAgIGRhdGFbMl0gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhWzBdLFxuICAgICAgICAgICAgc2l6ZTogZGF0YVsxXSxcbiAgICAgICAgICAgIHR5cGU6IGRhdGFbMl0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc0ZpbGUgPSBmdW5jdGlvbiBpc0ZpbGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCAodmFsdWUgaW5zdGFuY2VvZiBCbG9iICYmIHZhbHVlLm5hbWUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZXBDbG9uZU9iamVjdCA9IGZ1bmN0aW9uIGRlZXBDbG9uZU9iamVjdChzcmMpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChzcmMpKSByZXR1cm4gc3JjO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gaXNBcnJheShzcmMpID8gW10gOiB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdiA9IHNyY1trZXldO1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2ICYmIGlzT2JqZWN0KHYpID8gZGVlcENsb25lT2JqZWN0KHYpIDogdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXRlbSA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW0oKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgIHZhciBzZXJ2ZXJGaWxlUmVmZXJlbmNlID1cbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgdmFyIGZpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICAgIC8vIHVuaXF1ZSBpZCBmb3IgdGhpcyBpdGVtLCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBpdGVtIGFjcm9zcyB2aWV3c1xuICAgICAgICB2YXIgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBpdGVtIHN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICAvLyBpcyBhcmNoaXZlZFxuICAgICAgICAgICAgYXJjaGl2ZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBpZiBpcyBmcm96ZW4sIG5vIGxvbmdlciBmaXJlcyBldmVudHNcbiAgICAgICAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIHJlbW92ZWQgZnJvbSB2aWV3XG4gICAgICAgICAgICByZWxlYXNlZDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuXG4gICAgICAgICAgICAvLyBmaWxlIG1vZGVsIHJlZmVyZW5jZVxuICAgICAgICAgICAgZmlsZTogZmlsZSxcblxuICAgICAgICAgICAgLy8gaWQgb2YgZmlsZSBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNlcnZlckZpbGVSZWZlcmVuY2UsXG5cbiAgICAgICAgICAgIC8vIGlkIG9mIGZpbGUgdHJhbnNmZXIgb24gc2VydmVyXG4gICAgICAgICAgICB0cmFuc2ZlcklkOiBudWxsLFxuXG4gICAgICAgICAgICAvLyBpcyBhYm9ydGVkXG4gICAgICAgICAgICBwcm9jZXNzaW5nQWJvcnRlZDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlbSBzdGF0dXNcbiAgICAgICAgICAgIHN0YXR1czogc2VydmVyRmlsZVJlZmVyZW5jZSA/IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSA6IEl0ZW1TdGF0dXMuSU5JVCxcblxuICAgICAgICAgICAgLy8gYWN0aXZlIHByb2Nlc3Nlc1xuICAgICAgICAgICAgYWN0aXZlTG9hZGVyOiBudWxsLFxuICAgICAgICAgICAgYWN0aXZlUHJvY2Vzc29yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNhbGxiYWNrIHVzZWQgd2hlbiBhYm9ydCBwcm9jZXNzaW5nIGlzIGNhbGxlZCB0byBsaW5rIGJhY2sgdG8gdGhlIHJlc29sdmUgbWV0aG9kXG4gICAgICAgIHZhciBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlcm5hbGx5IGFkZGVkIGl0ZW0gbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuXG4gICAgICAgIC8vIGl0ZW0gZGF0YVxuICAgICAgICB2YXIgc2V0U3RhdHVzID0gZnVuY3Rpb24gc2V0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5zdGF0dXMgPSBzdGF0dXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZpcmUgZXZlbnQgdW5sZXNzIHRoZSBpdGVtIGhhcyBiZWVuIGFyY2hpdmVkXG4gICAgICAgIHZhciBmaXJlID0gZnVuY3Rpb24gZmlyZShldmVudCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlbGVhc2VkIHx8IHN0YXRlLmZyb3plbikgcmV0dXJuO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxO1xuICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwaS5maXJlLmFwcGx5KGFwaSwgW2V2ZW50XS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmlsZSBkYXRhXG4gICAgICAgIHZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoc3RhdGUuZmlsZS5uYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEZpbGVUeXBlID0gZnVuY3Rpb24gZ2V0RmlsZVR5cGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS50eXBlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0RmlsZVNpemUgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLnNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRGaWxlID0gZnVuY3Rpb24gZ2V0RmlsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxvZ2ljIHRvIGxvYWQgYSBmaWxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBsb2FkID0gZnVuY3Rpb24gbG9hZChzb3VyY2UsIGxvYWRlciwgb25sb2FkKSB7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgb3JpZ2luYWwgaXRlbSBzb3VyY2VcbiAgICAgICAgICAgIHN0YXRlLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICAgICAgLy8gc291cmNlIGlzIGtub3duXG4gICAgICAgICAgICBhcGkuZmlyZVN5bmMoJ2luaXQnKTtcblxuICAgICAgICAgICAgLy8gZmlsZSBzdHViIGlzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5maWxlKSB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmVTeW5jKCdsb2FkLXNraXAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBhIHN0dWIgZmlsZSBvYmplY3Qgd2hpbGUgbG9hZGluZyB0aGUgYWN0dWFsIGRhdGFcbiAgICAgICAgICAgIHN0YXRlLmZpbGUgPSBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBzdGFydHMgbG9hZGluZ1xuICAgICAgICAgICAgbG9hZGVyLm9uKCdpbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1pbml0Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gd2UnZXZlIHJlY2VpdmVkIGEgc2l6ZSBpbmRpY2F0aW9uLCBsZXQncyB1cGRhdGUgdGhlIHN0dWJcbiAgICAgICAgICAgIGxvYWRlci5vbignbWV0YScsIGZ1bmN0aW9uKG1ldGEpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgc2l6ZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgICAgICAgICBzdGF0ZS5maWxlLnNpemUgPSBtZXRhLnNpemU7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgbmFtZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgICAgICAgICBzdGF0ZS5maWxlLmZpbGVuYW1lID0gbWV0YS5maWxlbmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBzb3VyY2UsIHdlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAobWV0YS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG1ldGEuc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgPSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2l6ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdGhlIGZpbGUgaXMgbm93IGxvYWRpbmcgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHByb2dyZXNzIGluZGljYXRvcnNcbiAgICAgICAgICAgIGxvYWRlci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURJTkcpO1xuXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhbiBlcnJvciB3YXMgdGhyb3duIHdoaWxlIGxvYWRpbmcgdGhlIGZpbGUsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIGVycm9yIHN0YXRlXG4gICAgICAgICAgICBsb2FkZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcblxuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB1c2VyIG9yIGFub3RoZXIgcHJvY2VzcyBhYm9ydGVkIHRoZSBmaWxlIGxvYWQgKGNhbm5vdCByZXRyeSlcbiAgICAgICAgICAgIGxvYWRlci5vbignYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWFib3J0Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZG9uZSBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIub24oJ2xvYWQnLCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gYXMgd2UndmUgbm93IGxvYWRlZCB0aGUgZmlsZSB0aGUgbG9hZGVyIGlzIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiBmaWxlIGhhcyBsb2FkZWQgc3VjY2VzZnVsbHlcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCAocG9zc2libHkpIHRyYW5zZm9ybWVkIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGlzRmlsZShyZXN1bHQpID8gcmVzdWx0IDogc3RhdGUuZmlsZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk8gJiYgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1maWxlLWVycm9yJywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlLCB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9ubG9hZCBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm8gc2VydmVyIGlkLCBsZXQncyBnaXZlIHRoaXMgZmlsZSB0aGUgZnVsbCB0cmVhdG1lbnRcbiAgICAgICAgICAgICAgICBvbmxvYWQoZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNldCBsb2FkZXIgc291cmNlIGRhdGFcbiAgICAgICAgICAgIGxvYWRlci5zZXRTb3VyY2Uoc291cmNlKTtcblxuICAgICAgICAgICAgLy8gc2V0IGFzIGFjdGl2ZSBsb2FkZXJcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IGxvYWRlcjtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgc291cmNlIGRhdGFcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJldHJ5TG9hZCA9IGZ1bmN0aW9uIHJldHJ5TG9hZCgpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWJvcnRMb2FkID0gZnVuY3Rpb24gYWJvcnRMb2FkKCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklOSVQpO1xuICAgICAgICAgICAgZmlyZSgnbG9hZC1hYm9ydCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxvZ2ljIHRvIHByb2Nlc3MgYSBmaWxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcykge1xuICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyB3YXMgYWJvcnRlZFxuICAgICAgICAgICAgaWYgKHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdyBwcm9jZXNzaW5nXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIG5vIGZpbGUgbG9hZGVkIHdlJ2xsIHdhaXQgZm9yIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5maWxlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICBhcGkub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXR1cCBwcm9jZXNzb3JcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbignbG9hZCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdGhlIHVwbG9hZFxuICAgICAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRyYW5zZmVyIGlkXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ3RyYW5zZmVyJywgZnVuY3Rpb24odHJhbnNmZXJJZCkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IHRyYW5zZmVySWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkLXBlcmNlaXZlZCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXIgdGhlIHVwbG9hZFxuICAgICAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1jb21wbGV0ZScsIHNlcnZlckZpbGVSZWZlcmVuY2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXN0YXJ0Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbignYWJvcnQnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGZpbGUgd2FzIHVwbG9hZGVkIGJ1dCBwcm9jZXNzaW5nIHdhcyBjYW5jZWxsZWQgZHVyaW5nIHBlcmNlaXZlZCBwcm9jZXNzb3IgdGltZSBzdG9yZSBmaWxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRpbWVvdXQgc28gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCByZW1vdmUgYWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1wcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3aGVuIHN1Y2Nlc3NmdWxseSB0cmFuc2Zvcm1lZFxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgYXJjaGl2ZWQgaW4gdGhlIG1lYW4gdGltZSwgZG9uJ3QgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hcmNoaXZlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBmaWxlIVxuICAgICAgICAgICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBmaWxlXG4gICAgICAgICAgICBvbnByb2Nlc3Moc3RhdGUuZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgICAgICAgICAvLyBzZXQgYXMgYWN0aXZlIHByb2Nlc3NvclxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0UHJvY2Vzc2luZyA9IGZ1bmN0aW9uIHJlcXVlc3RQcm9jZXNzaW5nKCkge1xuICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWJvcnRQcm9jZXNzaW5nID0gZnVuY3Rpb24gYWJvcnRQcm9jZXNzaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yLmFib3J0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBsb2dpYyB0byByZXZlcnQgYSBwcm9jZXNzZWQgZmlsZVxuICAgICAgICAvL1xuICAgICAgICB2YXIgcmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KHJldmVydEZpbGVVcGxvYWQsIGZvcmNlUmV2ZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gYSBjb21wbGV0ZWQgdXBsb2FkIHdpbGwgaGF2ZSBhIHNlcnZlckZpbGVSZWZlcmVuY2UsIGEgZmFpbGVkIGNodW5rZWQgdXBsb2FkIHdoZXJlXG4gICAgICAgICAgICAgICAgLy8gZ2V0dGluZyBhIHNlcnZlcklkIHN1Y2NlZWRlZCBidXQgPj0wIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgd2lsbCBoYXZlIHRyYW5zZmVySWQgc2V0XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlclRyYW5zZmVySWQgPVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhdGUudHJhbnNmZXJJZDtcblxuICAgICAgICAgICAgICAgIC8vIGNhbm5vdCByZXZlcnQgd2l0aG91dCBhIHNlcnZlciBpZCBmb3IgdGhpcyBwcm9jZXNzXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlclRyYW5zZmVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IHRoZSB1cGxvYWQgKGZpcmUgYW5kIGZvcmdldClcbiAgICAgICAgICAgICAgICByZXZlcnRGaWxlVXBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJUcmFuc2ZlcklkLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGZpbGUgc2VydmVyIGlkIGFuZCB0cmFuc2ZlciBpZCBhcyBub3cgaXQncyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgZXJyb3Igc3RhdGUgd2hlbiByZXZlcnRpbmcgaXMgb3B0aW9uYWwsIGl0IHdpbGwgYWx3YXlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvaCBubyBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpcmUgZXZlbnRcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZXhwb3NlZCBtZXRob2RzXG4gICAgICAgIHZhciBfc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiBzZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGtleXNbMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGF0YSA9IGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY29tcGFyZSBvbGQgdmFsdWUgYWdhaW5zdCBuZXcgdmFsdWUsIGlmIHRoZXkncmUgdGhlIHNhbWUsIHdlJ3JlIG5vdCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGRhdGFbbGFzdF0pID09PSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHZhbHVlXG4gICAgICAgICAgICBkYXRhW2xhc3RdID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdXBkYXRlXG4gICAgICAgICAgICBmaXJlKCdtZXRhZGF0YS11cGRhdGUnLCB7XG4gICAgICAgICAgICAgICAga2V5OiByb290LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRhZGF0YVtyb290XSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIGdldE1ldGFkYXRhKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZU9iamVjdChrZXkgPyBtZXRhZGF0YVtrZXldIDogbWV0YWRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3JpZ2luID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VydmVySWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZmVySWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUudHJhbnNmZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZToge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiB7IGdldDogZ2V0RmlsZUV4dGVuc2lvbiB9LFxuICAgICAgICAgICAgICAgIGZpbGVUeXBlOiB7IGdldDogZ2V0RmlsZVR5cGUgfSxcbiAgICAgICAgICAgICAgICBmaWxlU2l6ZTogeyBnZXQ6IGdldEZpbGVTaXplIH0sXG4gICAgICAgICAgICAgICAgZmlsZTogeyBnZXQ6IGdldEZpbGUgfSxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5fcmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBnZXRNZXRhZGF0YTogZ2V0TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc2V0TWV0YWRhdGE6IGZ1bmN0aW9uIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9zZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtQVBJW25hbWVdID0gaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFib3J0TG9hZDogYWJvcnRMb2FkLFxuICAgICAgICAgICAgICAgIHJldHJ5TG9hZDogcmV0cnlMb2FkLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RQcm9jZXNzaW5nOiByZXF1ZXN0UHJvY2Vzc2luZyxcbiAgICAgICAgICAgICAgICBhYm9ydFByb2Nlc3Npbmc6IGFib3J0UHJvY2Vzc2luZyxcblxuICAgICAgICAgICAgICAgIGxvYWQ6IGxvYWQsXG4gICAgICAgICAgICAgICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICAgICAgICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdGUuZnJvemVuID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdGUucmVsZWFzZWQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbGVhc2VkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnJlbGVhc2VkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBhcmNoaXZlOiBmdW5jdGlvbiBhcmNoaXZlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLmFyY2hpdmVkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmNoaXZlZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5hcmNoaXZlZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgICAgIHZhciBpdGVtQVBJID0gY3JlYXRlT2JqZWN0KGFwaSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1BUEk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlRdWVyeShpdGVtcywgcXVlcnkpIHtcbiAgICAgICAgLy8ganVzdCByZXR1cm4gZmlyc3QgaW5kZXhcbiAgICAgICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGludmFsaWQgcXVlcmllc1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGl0ZW0gYnkgaWQgKG9yIC0xIGlmIG5vdCBmb3VuZClcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gcXVlcnk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUJ5SWQgPSBmdW5jdGlvbiBnZXRJdGVtQnlJZChpdGVtcywgaXRlbUlkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEl0ZW1JbmRleEJ5UXVlcnkoaXRlbXMsIGl0ZW1JZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXNbaW5kZXhdIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBmZXRjaEJsb2IgPSBmdW5jdGlvbiBmZXRjaEJsb2IodXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYicsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhoZWFkZXJzKS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoJ2xvYWQnLCB4aHIuc3RhdHVzLCBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksIGhlYWRlcnMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgZXJyb3IoY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25oZWFkZXJzID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICBoZWFkZXJzKGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RG9tYWluRnJvbVVSTCA9IGZ1bmN0aW9uIGdldERvbWFpbkZyb21VUkwodXJsKSB7XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgdXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKCdibG9iOicsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XSk/OlxcL1xcLy8sICckMScpXG4gICAgICAgICAgICAuc3BsaXQoJy8nKVswXTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRXh0ZXJuYWxVUkwgPSBmdW5jdGlvbiBpc0V4dGVybmFsVVJMKHVybCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHVybC5pbmRleE9mKCc6JykgPiAtMSB8fCB1cmwuaW5kZXhPZignLy8nKSA+IC0xKSAmJlxuICAgICAgICAgICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkeW5hbWljTGFiZWwgPSBmdW5jdGlvbiBkeW5hbWljTGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24obGFiZWwpID8gbGFiZWwuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpIDogbGFiZWw7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc01vY2tJdGVtID0gZnVuY3Rpb24gaXNNb2NrSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0VXBkYXRlZCA9IGZ1bmN0aW9uIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICBzdGF0ZS5saXN0VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNUycsIHsgaXRlbXM6IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIHZhciBvcHRpb25hbFByb21pc2UgPSBmdW5jdGlvbiBvcHRpb25hbFByb21pc2UoZm4pIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgc29ydEl0ZW1zID0gZnVuY3Rpb24gc29ydEl0ZW1zKHN0YXRlLCBjb21wYXJlKSB7XG4gICAgICAgIHN0YXRlLml0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoY3JlYXRlSXRlbUFQSShhKSwgY3JlYXRlSXRlbUFQSShiKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIGl0ZW0gYmFzZWQgb24gc3RhdGVcbiAgICB2YXIgZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUgPSBmdW5jdGlvbiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeSxcbiAgICAgICAgICAgICAgICBfcmVmJHN1Y2Nlc3MgPSBfcmVmLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBfcmVmJGZhaWx1cmUgPSBfcmVmLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9IF9yZWYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncXVlcnknLCAnc3VjY2VzcycsICdmYWlsdXJlJ10pO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1IYW5kbGVyKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWN0aW9ucyA9IGZ1bmN0aW9uIGFjdGlvbnMoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBYm9ydHMgYWxsIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFCT1JUX0FMTDogZnVuY3Rpb24gQUJPUlRfQUxMKCkge1xuICAgICAgICAgICAgICAgIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5mcmVlemUoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyBpbml0aWFsIGZpbGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERJRF9TRVRfRklMRVM6IGZ1bmN0aW9uIERJRF9TRVRfRklMRVMoX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjIkdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMiR2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBfcmVmMiR2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBtYXAgdmFsdWVzIHRvIGZpbGUgb2JqZWN0c1xuICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IHZhbHVlLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGUuc291cmNlID8gZmlsZS5zb3VyY2UgOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZmlsZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGZpbGVzLCBpZiBmaWxlIGlzIGluIGxpc3QsIGxlYXZlIGl0IGJlLCBpZiBub3QsIHJlbW92ZVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXRlbXMgc2hvdWxkIGJlIG1vdmVkXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgICAgICAgICAgYWN0aXZlSXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0ZW0gbm90IGlzIGluIG5ldyB2YWx1ZSwgcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICFmaWxlcy5maW5kKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHJlbW92ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBuZXcgZmlsZXNcbiAgICAgICAgICAgICAgICBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpbGUgaXMgYWxyZWFkeSBpbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNvdXJjZSA9PT0gZmlsZS5zb3VyY2UgfHwgaXRlbS5maWxlID09PSBmaWxlLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgaW4gbGlzdCwgYWRkXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FERF9JVEVNJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuTk9ORSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEFEQVRBOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fTUVUQURBVEEoX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmMy5pZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSBfcmVmMy5jaGFuZ2U7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNpbGVudCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGNsb3NlIHN1Y2Nlc3Npb24gd2UgY29tYmluZWQgYWxsIGNhbGxzIHRvZ2V0aGVyIHRvIHNhdmUgcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJldmVydCBhbmQgYXR0ZW1wdCB0byB1cGxvYWQgd2hlbiB3ZSdyZSB1cGxvYWRpbmcgdG8gYSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnSVNfQVNZTkMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIHVwZGF0ZSB0aGUgb3V0cHV0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZVByZXBhcmVGaWxlID0gcXVlcnkoJ0dFVF9CRUZPUkVfUFJFUEFSRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGlzIGxvY2FsIGl0ZW0gd2UgbmVlZCB0byBlbmFibGUgdXBsb2FkIGJ1dHRvbiBzbyBjaGFuZ2UgY2FuIGJlIHByb3BhZ2F0ZWQgdG8gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBhc3luYyBzY2VuYXJpb3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwbG9hZCA9IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHB1c2ggdGhpcyBmb3J3YXJkIGEgYml0IHNvIHRoZSBpbnRlcmZhY2UgaXMgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldmVydCA9IGZ1bmN0aW9uIHJldmVydChkb1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZG9VcGxvYWQgPyB1cGxvYWQgOiBmdW5jdGlvbigpIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydChkb1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIHJlLXVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldmVydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IHVwbG9hZGluZywgY2FuY2VsIHVwbG9hZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgTU9WRV9JVEVNOiBmdW5jdGlvbiBNT1ZFX0lURU0oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmNC5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfcmVmNC5pbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgc3RhdGUuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIHN0YXRlLml0ZW1zLnNwbGljZShjdXJyZW50SW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFNPUlQ6IGZ1bmN0aW9uIFNPUlQoX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZSA9IF9yZWY1LmNvbXBhcmU7XG4gICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NPUlRfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQUREX0lURU1TOiBmdW5jdGlvbiBBRERfSVRFTVMoX3JlZjYpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBfcmVmNi5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfcmVmNi5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBfcmVmNi5pbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkc3VjY2VzcyA9IF9yZWY2LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNiRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjYkc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkZmFpbHVyZSA9IF9yZWY2LmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmNiRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjYkZmFpbHVyZTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxJdGVtcyA9IHF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gaW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gMCA6IHRvdGFsSXRlbXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkRmlsZSA9IGZ1bmN0aW9uIGlzVmFsaWRGaWxlKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaWxlKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhzb3VyY2UubmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhaXNFbXB0eShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkSXRlbXMgPSBpdGVtcy5maWx0ZXIoaXNWYWxpZEZpbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gdmFsaWRJdGVtcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Uuc291cmNlIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogc291cmNlLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBRERfSVRFTTogZnVuY3Rpb24gQUREX0lURU0oX3JlZjcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjcuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRpbmRleCA9IF9yZWY3LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9yZWY3JGluZGV4ID09PSB2b2lkIDAgPyAtMSA6IF9yZWY3JGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY3LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRzdWNjZXNzID0gX3JlZjcuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWY3JHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNyRzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRmYWlsdXJlID0gX3JlZjcuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSA9IF9yZWY3JGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNyRmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRvcHRpb25zID0gX3JlZjcub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWY3JG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjckb3B0aW9ucztcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBzb3VyY2Ugc3VwcGxpZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdObyBzb3VyY2UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgZmlsZSBpdGVtcywgdXNlZCB0byBmaWx0ZXIgZHJvcHBlZCBkaXJlY3RvcnkgY29udGVudHNcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzRmlsZShzb3VyY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWwgc2lsZW50bHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgdGhlcmUncyBzdGlsbCByb29tIGluIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNSb29tRm9ySXRlbShzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgYWxsb3dlZCwgd2UgY2FuJ3QgcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gaXMgYWxsb3dlZCBidXQgd2UncmUgbm90IGFsbG93ZWQgdG8gcmVwbGFjZSBpdCB3ZSBleGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgJiYgIXN0YXRlLm9wdGlvbnMuYWxsb3dSZXBsYWNlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogbnVsbCB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgcmVwbGFjZSB0aGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAvLyBpZCBvZiBmaXJzdCBpdGVtIHdlJ3JlIGFib3V0IHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZW0gPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcylbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaGFzIGJlZW4gcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXJ2ZXIgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmNlUmV2ZXJ0ID0gcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VSZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gYWRkIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7IC8vIG5vIG5lZWQgdG8gaGFuZGxlIHRoaXMgY2F0Y2ggc3RhdGUgZm9yIG5vd1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaXJzdCBpdGVtIGFzIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhpcyBpdGVtXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IF9pdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGRpZCB0aGUgZmlsZSBvcmlnaW5hdGVcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSAnbG9jYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnbGltYm8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBibGFuayBpdGVtXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBkaWQgdGhpcyBmaWxlIGNvbWUgZnJvbVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW5wdXQgZmlsZSBuZXZlciBoYXMgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgbWV0YSBkYXRhXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5tZXRhZGF0YSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShrZXksIG9wdGlvbnMubWV0YWRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVycygnRElEX0NSRUFURV9JVEVNJywgaXRlbSwgeyBxdWVyeTogcXVlcnksIGRpc3BhdGNoOiBkaXNwYXRjaCB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4IGlmIGlzIG5vdCBhbGxvd2VkIHRvIHBpY2sgbG9jYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaXRlbUluc2VydExvY2F0aW9uRnJlZWRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGl0ZW1JbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAtMSA6IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbSB0byBsaXN0XG4gICAgICAgICAgICAgICAgaW5zZXJ0SXRlbShzdGF0ZS5pdGVtcywgaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGdldCBhIHF1aWNrIHJlZmVyZW5jZSB0byB0aGUgaXRlbSBpZFxuICAgICAgICAgICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBvYnNlcnZlIGl0ZW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgaXRlbS5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0lOSVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1pbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9MT0FEJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLW1ldGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLXByb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTJywgeyBpZDogaWQsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShlcnJvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgY2xpZW50IGVycm9yLCBubyB3YXkgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA+PSA0MDAgJiYgZXJyb3IuY29kZSA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBlcnJvci5jb2RlICsgJyAoJyArIGVycm9yLmJvZHkgKyAnKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3QgdGhlIGZpbGUgc28gY2FuIGJlIGRlYWx0IHdpdGggdGhyb3VnaCBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBwb3NzaWJsZSBzZXJ2ZXIgZXJyb3IsIHNvIG1pZ2h0IGJlIHBvc3NpYmxlIHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLWZpbGUtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvci5zdGF0dXMsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLWFib3J0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1za2lwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdDT01QTEVURV9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNob3VsZCBub3QgYWRkIHRoaXMgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vbignbWV0YWRhdGEtdXBkYXRlJywgZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBREFUQScsIHsgaWQ6IGlkLCBjaGFuZ2U6IGNoYW5nZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBkZWNpZGUgaWYgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFucyB3ZSdsbCBkbyB0aGlzIGFuZCB3YWl0IGZvciBpZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihzaG91bGRQcmVwYXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHJlcGFyZU91dHB1dCA9IGJlZm9yZVByZXBhcmVGaWxlKGl0ZW0sIHNob3VsZFByZXBhcmVPdXRwdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIGxvYWRDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZGxlIHN0YXRlIGFuZCB0aGVuIHJ1biBQUkVQQVJFX09VVFBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gbG9hZGVkLCBhbGxvdyBwbHVnaW5zIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gcmVhZCBkYXRhIChxdWlja2x5KVxuICAgICAgICAgICAgICAgICAgICAvLyAtIGFkZCBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdESURfTE9BRF9JVEVNJywgaXRlbSwgeyBxdWVyeTogcXVlcnksIGRpc3BhdGNoOiBkaXNwYXRjaCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKHF1ZXJ5KCdHRVRfQkVGT1JFX0FERF9GSUxFJyksIGNyZWF0ZUl0ZW1BUEkoaXRlbSkpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFkZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgIWUuZXJyb3IgfHwgIWUuc3RhdHVzKSByZXR1cm4gaGFuZGxlQWRkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1zdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1wcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsIHsgaWQ6IGlkLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXJldmVydC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtY29tcGxldGUnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogc2VydmVyRmlsZVJlZmVyZW5jZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICAgICAgICAgIHZhciBfcmVmOCA9IHN0YXRlLm9wdGlvbnMuc2VydmVyIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfcmVmOC51cmwsXG4gICAgICAgICAgICAgICAgICAgIGxvYWQgPSBfcmVmOC5sb2FkLFxuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gX3JlZjgucmVzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2ggPSBfcmVmOC5mZXRjaDtcblxuICAgICAgICAgICAgICAgIGl0ZW0ubG9hZChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbG9hZHMgdGhlIGZpbGUgYmFzZWQgb24gdGhlIHR5cGUgb2YgZmlsZSAoc3RyaW5nLCBiYXNlNjQsIGJsb2IsIGZpbGUpIGFuZCBsb2NhdGlvbiBvZiBmaWxlIChsb2NhbCwgcmVtb3RlLCBsaW1ibylcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmlsZUxvYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gaW5wdXQsIGlmIGlzIHJlbW90ZSwgc2VlIGlmIHNob3VsZCB1c2UgY3VzdG9tIGZldGNoLCBlbHNlIHVzZSBkZWZhdWx0IGZldGNoQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgZmV0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyByZW1vdGUgdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHRyeSB0byBmZXRjaCB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIGxpbWJvIG9yIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgcmVzdG9yZSkgLy8gbGltYm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBsb2FkKSAvLyBsb2NhbFxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGxvYWRlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihmaWxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgcHJvY2VzcyB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignTE9BRF9GSUxFJywgZmlsZSwgeyBxdWVyeTogcXVlcnkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgUkVRVUVTVF9QUkVQQVJFX09VVFBVVDogZnVuY3Rpb24gUkVRVUVTVF9QUkVQQVJFX09VVFBVVChfcmVmOSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjkuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWY5LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY5JGZhaWx1cmUgPSBfcmVmOS5mYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gX3JlZjkkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY5JGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVzcG9uc2UgaWYgaXRlbSBhcmNoaXZlZFxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGFyY2hpdmVkIGl0ZW1zLCBhbiBpdGVtIGNvdWxkIGhhdmUgYmVlbiBhcmNoaXZlZCAobG9hZCBhYm9ydGVkKSB3aGlsZSB3YWl0aW5nIHRvIGJlIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdQUkVQQVJFX09VVFBVVCcsIGl0ZW0uZmlsZSwgeyBxdWVyeTogcXVlcnksIGl0ZW06IGl0ZW0gfSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdDT01QTEVURV9QUkVQQVJFX09VVFBVVCcsIHJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIENPTVBMRVRFX0xPQURfSVRFTTogZnVuY3Rpb24gQ09NUExFVEVfTE9BRF9JVEVNKF9yZWYxMCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjEwLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGRhdGEuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgICAgICAgICAvLyBzb3J0IGl0ZW1zIGluIGxpc3RcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgaW50ZXJmYWNlIGtub3cgdGhlIGl0ZW0gaGFzIGxvYWRlZFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGl0ZW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbmQgYWRkZWQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBpdGVtcyBzbyBjYW4gbm93IGJlIHNhZmVseSByZXR1cm5lZCBmb3IgdXNlXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBzZXJ2ZXIgZmlsZSB3ZSBuZWVkIHRvIHNob3cgYSBkaWZmZXJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0xPQ0FMX0lURU0nLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXMgYSB0ZW1wIHNlcnZlciBmaWxlIHdlIHByZXZlbnQgYXN5bmMgdXBsb2FkIGNhbGwgaGVyZSAoYXMgdGhlIGZpbGUgaXMgYWxyZWFkeSBvbiB0aGUgc2VydmVyKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5zZXJ2ZXJJZCB8fCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZCB3ZSBhcmUgYWxsb3dlZCB0byB1cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHksIGxldHMgZG8gaXRcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkoJ0lTX0FTWU5DJykgJiYgc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgUkVUUllfSVRFTV9MT0FEOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSBsb2FkaW5nIHRoZSBzb3VyY2Ugb25lIG1vcmUgdGltZVxuICAgICAgICAgICAgICAgIGl0ZW0ucmV0cnlMb2FkKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9JVEVNX1BSRVBBUkU6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtLCBfc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IGJlIHF1ZXVlZCAob3IgaXMgYWxyZWFkeSBxdWV1ZWQpXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1DYW5CZVF1ZXVlZEZvclByb2Nlc3NpbmcgPVxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0aW5nIGZvciBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdlbnQgd3JvbmcgZWFybGllclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SO1xuXG4gICAgICAgICAgICAgICAgLy8gbm90IHJlYWR5IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmICghaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc05vdyA9IGZ1bmN0aW9uIHByb2Nlc3NOb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5oaWRkZW4gPyBwcm9jZXNzTm93KCkgOiBzZXRUaW1lb3V0KHByb2Nlc3NOb3csIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRvbmUgcHJvY2Vzc2luZyBvciB0cmllZCB0byByZXZlcnQgYnV0IGRpZG4ndCB3b3JrLCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihwcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTsgLy8gZG9uJ3QgY29udGludWUgd2l0aCBwcm9jZXNzaW5nIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJlcXVlc3RQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdQUk9DRVNTX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sIHRydWUpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFBST0NFU1NfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4UGFyYWxsZWxVcGxvYWRzID0gcXVlcnkoJ0dFVF9NQVhfUEFSQUxMRUxfVVBMT0FEUycpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbEN1cnJlbnRVcGxvYWRzID0gcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkcpXG4gICAgICAgICAgICAgICAgICAgIC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSBhbmQgd2FpdCB0aWxsIHF1ZXVlIGlzIGZyZWVkIHVwXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBxdWV1ZSBmb3IgbGF0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIGl0IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2FzIG5vdCBxdWV1ZWQgb3IgaXMgYWxyZWFkeSBwcm9jZXNzaW5nIGV4aXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc05leHQgPSBmdW5jdGlvbiBwcm9jZXNzTmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZXVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZUVudHJ5ID0gc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gaXRlbXMgbGVmdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgaXRlbSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gcXVldWVFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBxdWV1ZUVudHJ5LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gcXVldWVFbnRyeS5mYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRlbSB3YXMgYXJjaGl2ZWQgd2hpbGUgaW4gcXVldWUsIGp1bXAgdG8gbmV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1SZWZlcmVuY2UgfHwgaXRlbVJlZmVyZW5jZS5hcmNoaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWVkIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcXVlcnk6IGlkLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpdGVtLm9uT25jZSgncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBsb2NhbCwgYW5kIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nLCB0cmlnZ2VyIHJlbW92ZSBvZiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyByZXZlcnQgd2lsbCByZW1vdmUgZmlsZSBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFVwbG9hZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJlbW92ZShpdGVtLnNvdXJjZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgaXRlbXMgcHJvY2Vzc2VkPyBObyBlcnJvcnM/XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxJdGVtc1Byb2Nlc3NlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkubGVuZ3RoID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBlcnJvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZpbGUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpdGVtLnByb2Nlc3MoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXIucHJvY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1RyYW5zZmVySWQ6IGl0ZW0udHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXI6IG9wdGlvbnMuc2VydmVyLnBhdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1VwbG9hZHM6IG9wdGlvbnMuY2h1bmtVcGxvYWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua0ZvcmNlOiBvcHRpb25zLmNodW5rRm9yY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rUmV0cnlEZWxheXM6IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb246IHF1ZXJ5KCdHRVRfQUxMT1dfTUlOSU1VTV9VUExPQURfRFVSQVRJT04nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgZmlsZSwgeyBxdWVyeTogcXVlcnksIGl0ZW06IGl0ZW0gfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVRSWV9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX1JFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsUHJvbWlzZShxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpLCBjcmVhdGVJdGVtQVBJKGl0ZW0pKS50aGVuKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZW1vdmVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRU1PVkVfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRnJvbVZpZXcgPSBmdW5jdGlvbiByZW1vdmVGcm9tVmlldygpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGlkIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyY2hpdmUgdGhlIGl0ZW0sIHRoaXMgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKS5hcmNoaXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGVsbCB0aGUgdmlldyB0aGUgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVNT1ZFX0lURU0nLCB7IGVycm9yOiBudWxsLCBpZDogaWQsIGl0ZW06IGl0ZW0gfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IHRoZSBsaXN0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5IHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIGZpbGUgYW5kIHRoZSBgc2VydmVyLnJlbW92ZWAgZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCxcbiAgICAgICAgICAgICAgICAvLyBzZW5kIHNvdXJjZSB0aGVyZSBzbyBkZXYgY2FuIHJlbW92ZSBmaWxlIGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZW1vdmUgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9SRU1PVkUnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZW1vdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgc3RhdHVzLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVSZW1vdmVFcnJvcikoc3RhdHVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgcmVxdWVzdGluZyByZXZlcnQgYW5kIGNhbiByZXZlcnQgbmVlZCB0byBjYWxsIHJldmVydCBoYW5kbGVyIChub3QgY2FsbGluZyByZXF1ZXN0XyBiZWNhdXNlIHRoYXQgd291bGQgYWxzbyB0cmlnZ2VyIGJlZm9yZVJlbW92ZUhvb2spXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLnJldmVydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luICE9PSBGaWxlT3JpZ2luLkxPQ0FMICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNodW5rZWQgdXBsb2FkcyBhcmUgZW5hYmxlZCBhbmQgd2UncmUgdXBsb2FkaW5nIGluIGNodW5rcyBmb3IgdGhpcyBzcGVjaWZpYyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiB0aGUgZmlsZSBpc24ndCBiaWcgZW5vdWdoIGZvciBjaHVua2VkIHVwbG9hZHMgYnV0IGNodW5rRm9yY2UgaXMgc2V0IHRoZW4gY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IGJlZm9yZSByZW1vdmluZyBmcm9tIHRoZSB2aWV3Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUub3B0aW9ucy5jaHVua1VwbG9hZHMgJiYgaXRlbS5maWxlLnNpemUgPiBzdGF0ZS5vcHRpb25zLmNodW5rU2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5vcHRpb25zLmNodW5rVXBsb2FkcyAmJiBzdGF0ZS5vcHRpb25zLmNodW5rRm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG5vdyBzYWZlbHkgcmVtb3ZlIGZyb20gdmlld1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBBQk9SVF9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBBQk9SVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiBpcyBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlcnZlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFib3J0XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBpbnN0YW50IHVwbG9hZGluZywgcmV2ZXJ0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcgdGhlIGZpbGUgd2lsbCBhbHNvIGJlIHJlbW92ZWQgaWYgd2UgcmV2ZXJ0LFxuICAgICAgICAgICAgICAgIC8vIHNvIGlmIGEgYmVmb3JlIHJlbW92ZSBmaWxlIGhvb2sgaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIHJ1biBpdCBub3dcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUmV2ZXJ0ID0gZnVuY3Rpb24gaGFuZGxlUmV2ZXJ0KHNob3VsZFJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldmVydCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0UmVtb3ZlUmVzdWx0ID0gZm4oY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RSZW1vdmVSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQocmVxdWVzdFJlbW92ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFJlbW92ZVJlc3VsdC50aGVuKGhhbmRsZVJldmVydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkIHx8IGlzTW9ja0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFNFVF9PUFRJT05TOiBmdW5jdGlvbiBTRVRfT1BUSU9OUyhfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF9yZWYxMS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1NFVF8nICsgZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKSwgeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZm9ybWF0RmlsZW5hbWUgPSBmdW5jdGlvbiBmb3JtYXRGaWxlbmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRWxlbWVudCQxID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgICAgIHZhciBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc2NyaWJlQXJjID0gZnVuY3Rpb24gZGVzY3JpYmVBcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXJjU3dlZXApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIFsnTScsIHN0YXJ0LngsIHN0YXJ0LnksICdBJywgcmFkaXVzLCByYWRpdXMsIDAsIGFyY1N3ZWVwLCAwLCBlbmQueCwgZW5kLnldLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgdmFyIHBlcmNlbnRhZ2VBcmMgPSBmdW5jdGlvbiBwZXJjZW50YWdlQXJjKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGFyY1N3ZWVwID0gMTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSAmJiB0byAtIGZyb20gPD0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiB0byAmJiBmcm9tIC0gdG8gPj0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlQXJjKFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICAgICAgICBhcmNTd2VlcFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIHN0YXJ0IGF0IDBcbiAgICAgICAgcHJvcHMuc3BpbiA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHByb3BzLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIC8vIHN2Z1xuICAgICAgICB2YXIgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICAgICB9KTtcblxuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICAgICAgcm9vdC5yZWYuc3ZnID0gc3ZnO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5hbGlnbikge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB3aWR0aCBvZiBzdHJva2VcbiAgICAgICAgdmFyIHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNpemUgb2YgcmluZ1xuICAgICAgICB2YXIgc2l6ZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuXG4gICAgICAgIC8vIHJpbmcgc3RhdGVcbiAgICAgICAgdmFyIHJpbmdGcm9tID0gMDtcbiAgICAgICAgdmFyIHJpbmdUbyA9IDA7XG5cbiAgICAgICAgLy8gbm93IGluIGJ1c3kgbW9kZVxuICAgICAgICBpZiAocHJvcHMuc3Bpbikge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gMC41O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gcHJvcHMucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcGVyY2VudGFnZUFyYyhzaXplLCBzaXplLCBzaXplIC0gcmluZ1N0cm9rZVdpZHRoLCByaW5nRnJvbSwgcmluZ1RvKTtcblxuICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ2QnLCBjb29yZGluYXRlcyk7XG5cbiAgICAgICAgLy8gaGlkZSB3aGlsZSBjb250YWlucyAwIHZhbHVlXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS1vcGFjaXR5JywgcHJvcHMuc3BpbiB8fCBwcm9wcy5wcm9ncmVzcyA+IDAgPyAxIDogMCk7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICB0YWc6ICdkaXYnLFxuICAgICAgICBuYW1lOiAncHJvZ3Jlc3MtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ3Byb2dyZXNzJywgJ3NwaW4nLCAnYWxpZ24nXSxcbiAgICAgICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgICAgIHN0aWZmbmVzczogMC45NSxcbiAgICAgICAgICAgICAgICAgICAgZGFtcGluZzogMC42NSxcbiAgICAgICAgICAgICAgICAgICAgbWFzczogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlJDEgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IChwcm9wcy5pY29uIHx8ICcnKSArICgnPHNwYW4+JyArIHByb3BzLmxhYmVsICsgJzwvc3Bhbj4nKTtcblxuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQxID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkO1xuICAgICAgICB2YXIgc2hvdWxkRGlzYWJsZSA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpIHx8IHByb3BzLm9wYWNpdHkgPT09IDA7XG5cbiAgICAgICAgaWYgKHNob3VsZERpc2FibGUgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNhYmxlICYmIGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZpbGVBY3Rpb25CdXR0b24gPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnYnV0dG9uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgIH0sXG5cbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgbmFtZTogJ2ZpbGUtYWN0aW9uLWJ1dHRvbicsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydsYWJlbCddLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDEsXG4gICAgfSk7XG5cbiAgICB2YXIgdG9OYXR1cmFsRmlsZVNpemUgPSBmdW5jdGlvbiB0b05hdHVyYWxGaWxlU2l6ZShieXRlcykge1xuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9XG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcuJztcbiAgICAgICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwMDA7XG4gICAgICAgIC8vIG5vIG5lZ2F0aXZlIGJ5dGUgc2l6ZXNcbiAgICAgICAgYnl0ZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGJ5dGVzKSk7XG5cbiAgICAgICAgdmFyIEtCID0gYmFzZTtcbiAgICAgICAgdmFyIE1CID0gYmFzZSAqIGJhc2U7XG4gICAgICAgIHZhciBHQiA9IGJhc2UgKiBiYXNlICogYmFzZTtcblxuICAgICAgICAvLyBqdXN0IGJ5dGVzXG4gICAgICAgIGlmIChieXRlcyA8IEtCKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXMgKyAnIGJ5dGVzJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtpbG9ieXRlc1xuICAgICAgICBpZiAoYnl0ZXMgPCBNQikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYnl0ZXMgLyBLQikgKyAnIEtCJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lZ2FieXRlc1xuICAgICAgICBpZiAoYnl0ZXMgPCBHQikge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBNQiwgMSwgZGVjaW1hbFNlcGFyYXRvcikgKyAnIE1CJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdpZ2FieXRlc1xuICAgICAgICByZXR1cm4gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIEdCLCAyLCBkZWNpbWFsU2VwYXJhdG9yKSArICcgR0InO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyA9IGZ1bmN0aW9uIHJlbW92ZURlY2ltYWxzV2hlblplcm8odmFsdWUsIGRlY2ltYWxDb3VudCwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLnRvRml4ZWQoZGVjaW1hbENvdW50KVxuICAgICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0ICE9PSAnMCc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSQyID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIGZpbGVuYW1lXG4gICAgICAgIHZhciBmaWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgICAgICBmaWxlTmFtZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1tYWluJztcbiAgICAgICAgLy8gaGlkZSBmb3Igc2NyZWVucmVhZGVyc1xuICAgICAgICAvLyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gYSBmaWVsZHNldCB3aXRoIGxlZ2VuZCB0aGF0IGNvbnRhaW5zIHRoZSBmaWxlbmFtZVxuICAgICAgICAvLyBubyBuZWVkIHRvIHJlYWQgaXQgdHdpY2VcbiAgICAgICAgYXR0cihmaWxlTmFtZSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlTmFtZSk7XG4gICAgICAgIHJvb3QucmVmLmZpbGVOYW1lID0gZmlsZU5hbWU7XG5cbiAgICAgICAgLy8gZmlsZXNpemVcbiAgICAgICAgdmFyIGZpbGVTaXplID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIGZpbGVTaXplLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLXN1Yic7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZVNpemUpO1xuICAgICAgICByb290LnJlZi5maWxlU2l6ZSA9IGZpbGVTaXplO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlc1xuICAgICAgICB0ZXh0KGZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9XQUlUSU5HX0ZPUl9TSVpFJykpO1xuICAgICAgICB0ZXh0KGZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxlID0gZnVuY3Rpb24gdXBkYXRlRmlsZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgICAgICB0ZXh0KFxuICAgICAgICAgICAgcm9vdC5yZWYuZmlsZVNpemUsXG4gICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZShcbiAgICAgICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9TSVpFJywgcHJvcHMuaWQpLFxuICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGVTaXplT25FcnJvciA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGVTaXplT25FcnJvcihfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAvLyBpZiBzaXplIGlzIGF2YWlsYWJsZSBkb24ndCBmYWxsYmFjayB0byB1bmtub3duIHNpemUgbWVzc2FnZVxuICAgICAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZpbGUoeyByb290OiByb290LCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlSW5mbyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1pbmZvJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZUZpbGUsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQTogdXBkYXRlRmlsZSxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgfSksXG5cbiAgICAgICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIHRvUGVyY2VudGFnZSA9IGZ1bmN0aW9uIHRvUGVyY2VudGFnZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkMyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuXG4gICAgICAgIC8vIG1haW4gc3RhdHVzXG4gICAgICAgIHZhciBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIG1haW4uY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLXN0YXR1cy1tYWluJztcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICAgICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAgICAgLy8gc3ViIHN0YXR1c1xuICAgICAgICB2YXIgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIHN1Yi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1Yic7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ViKTtcbiAgICAgICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgICAgIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MoeyByb290OiByb290LCBhY3Rpb246IHsgcHJvZ3Jlc3M6IG51bGwgfSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtTG9hZFByb2dyZXNzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgdmFyIHRpdGxlID1cbiAgICAgICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9MT0FESU5HJykgKyAnICcgKyB0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKSArICclJztcblxuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICAgICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyA9IGZ1bmN0aW9uIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB2YXIgdGl0bGUgPVxuICAgICAgICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSArXG4gICAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgK1xuICAgICAgICAgICAgICAgICAgJyUnO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1JFVFJZJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG4gICAgfTtcblxuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCAnJyk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY4LmFjdGlvbjtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCBhY3Rpb24uc3RhdHVzLm1haW4pO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1YiwgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsZVN0YXR1cyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1zdGF0dXMnLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogZXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogZXJyb3IsXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDMsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gICAgICovXG5cbiAgICB2YXIgQnV0dG9ucyA9IHtcbiAgICAgICAgQWJvcnRJdGVtTG9hZDoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLWxvYWQnLFxuICAgICAgICAgICAgYWxpZ246ICdMT0FEX0lORElDQVRPUl9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbUxvYWQ6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tbG9hZCcsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZW1vdmVJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRU1PVkVfSVRFTScsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVNT1ZFJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmVtb3ZlLWl0ZW0nLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nLCAvLyBsZWZ0XG4gICAgICAgIH0sXG4gICAgICAgIFByb2Nlc3NJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9QUk9DRVNTJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcHJvY2Vzcy1pdGVtJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIEFib3J0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZXZlcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1VORE9fSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fVU5ETycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJywgLy8gcmlnaHRcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gbWFrZSBhIGxpc3Qgb2YgYnV0dG9ucywgd2UgY2FuIHRoZW4gcmVtb3ZlIGJ1dHRvbnMgZnJvbSB0aGlzIGxpc3QgaWYgdGhleSdyZSBkaXNhYmxlZFxuICAgIHZhciBCdXR0b25LZXlzID0gW107XG4gICAgZm9yaW4oQnV0dG9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIEJ1dHRvbktleXMucHVzaChrZXkpO1xuICAgIH0pO1xuXG4gICAgdmFyIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQocm9vdCkge1xuICAgICAgICBpZiAoZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkgPT09ICdyaWdodCcpIHJldHVybiAwO1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC5oaWRkZW4gPyBudWxsIDogYnV0dG9uUmVjdC53aWR0aCArIGJ1dHRvblJlY3QubGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gZnVuY3Rpb24gY2FsY3VsYXRlQnV0dG9uV2lkdGgocm9vdCkge1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC53aWR0aDtcbiAgICB9O1xuXG4gICAgLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuICAgIHZhciBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQocm9vdCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgLyA0KTtcbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQubGVmdCAvIDIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyk7XG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuICAgIH07XG4gICAgdmFyIGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50ID0gZnVuY3Rpb24gZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicpO1xuICAgIH07XG5cbiAgICB2YXIgRGVmYXVsdFN0eWxlID0ge1xuICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgfSxcbiAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgICAgIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvcjogeyBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuNzUsIHNjYWxlWTogMC43NSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICB9O1xuXG4gICAgdmFyIElkbGVTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICB9O1xuXG4gICAgdmFyIFByb2Nlc3NpbmdTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfTtcblxuICAgIHZhciBTdHlsZU1hcCA9IHtcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDoge1xuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEsIGFsaWduOiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudCB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IHtcbiAgICAgICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEsIHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX0xPQURfSVRFTTogSWRsZVN0eWxlLFxuICAgICAgICBESURfTE9BRF9MT0NBTF9JVEVNOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlLFxuICAgIH07XG5cbiAgICAvLyBjb21wbGV0ZSBpbmRpY2F0b3Igdmlld1xuICAgIHZhciBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IHJvb3QucXVlcnkoJ0dFVF9JQ09OX0RPTkUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogJ3Byb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNCA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgICAgICAvLyBjb3B5IEJ1dHRvbnMgb2JqZWN0XG4gICAgICAgIHZhciBMb2NhbEJ1dHRvbnMgPSBPYmplY3Qua2V5cyhCdXR0b25zKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICAgICAgcHJldltjdXJyXSA9IE9iamVjdC5hc3NpZ24oe30sIEJ1dHRvbnNbY3Vycl0pO1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgICAgICB2YXIgYWxsb3dSZXZlcnQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVWRVJUJyk7XG5cbiAgICAgICAgLy8gYWxsb3cgcmVtb3ZlIGZpbGVcbiAgICAgICAgdmFyIGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgICAgIHZhciBhbGxvd1Byb2Nlc3MgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUFJPQ0VTUycpO1xuXG4gICAgICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgICAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHJvb3QucXVlcnkoJ0dFVF9JTlNUQU5UX1VQTE9BRCcpO1xuXG4gICAgICAgIC8vIGlzIGFzeW5jIHNldCB1cFxuICAgICAgICB2YXIgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICAgICAgdmFyIGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiA9IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nKTtcblxuICAgICAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICAgICAgdmFyIGJ1dHRvbkZpbHRlcjtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcmV2ZXJ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEvUmV2ZXJ0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm9jZXNzIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gcHJvY2VzcyBjb250cm9scyBhdmFpbGFibGVcbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyID8gQnV0dG9uS2V5cy5maWx0ZXIoYnV0dG9uRmlsdGVyKSA6IEJ1dHRvbktleXMuY29uY2F0KCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGljb24gYW5kIGxhYmVsIGZvciByZXZlcnQgYnV0dG9uIHdoZW4gaW5zdGFudCB1cGxvYWRpbmdcbiAgICAgICAgaWYgKGluc3RhbnRVcGxvYWQgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5sYWJlbCA9ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJztcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgICAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsXG4gICAgICAgICAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFN0eWxlTWFwWydESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJ10uc3RhdHVzLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVCdXR0b25XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdmUgcmVtb3ZlIGJ1dHRvbiB0byByaWdodFxuICAgICAgICBpZiAoYWxpZ25SZW1vdmVJdGVtQnV0dG9uICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10uYWxpZ24gPSAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJztcbiAgICAgICAgICAgIHZhciBfbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIF9tYXAuaW5mby50cmFuc2xhdGVYID0gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQ7XG4gICAgICAgICAgICBfbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgX21hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG93L2hpZGUgUmVtb3ZlSXRlbSBidXR0b25cbiAgICAgICAgaWYgKCFhbGxvd1JlbW92ZSkge1xuICAgICAgICAgICAgTG9jYWxCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICAgICAgZm9yaW4oTG9jYWxCdXR0b25zLCBmdW5jdGlvbihrZXksIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgICAgICAgIHZhciBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgIGxhYmVsOiByb290LnF1ZXJ5KGRlZmluaXRpb24ubGFiZWwpLFxuICAgICAgICAgICAgICAgIGljb246IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5pY29uKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhcHBlbmRlZD9cbiAgICAgICAgICAgIGlmIChlbmFibGVkQnV0dG9ucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvZ2dsZVxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHBvc2l0aW9uIGF0dHJpYnV0ZVxuICAgICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfJyArIGRlZmluaXRpb24uYWxpZ24pO1xuXG4gICAgICAgICAgICAvLyBhZGQgY2xhc3NcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGRlZmluaXRpb24uY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goZGVmaW5pdGlvbi5hY3Rpb24sIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgICAgICAgIHJvb3QucmVmWydidXR0b24nICsga2V5XSA9IGJ1dHRvblZpZXc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrbWFya1xuICAgICAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcpXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yLmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgICAgICAnR0VUX1NUWUxFX0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgICAgIHJvb3QucmVmLmluZm8gPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlSW5mbywgeyBpZDogaWQgfSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgICAgIHJvb3QucmVmLnN0YXR1cyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVTdGF0dXMsIHsgaWQ6IGlkIH0pKTtcblxuICAgICAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgICB2YXIgbG9hZEluZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGxvYWRJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWxvYWQtaW5kaWNhdG9yJyk7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvciA9IGxvYWRJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIHZhciBwcm9ncmVzc0luZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yID0gcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHN0eWxlc1xuICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDIgPSBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjMuYWN0aW9ucyxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG5cbiAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHlsZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGRlZmluZSBuZXcgYWN0aXZlIHN0eWxlc1xuICAgICAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgICAgICAgIHZhciBzdHlsZXNUb0FwcGx5ID0gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCBmdW5jdGlvbihuYW1lLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSByb290LnJlZltuYW1lXTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgICAgICAgICBmb3JpbihkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJiB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5wdXNoKHsgY29udHJvbDogY29udHJvbCwga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYWN0aXZlIHN0eWxlcyB0byBlbGVtZW50XG4gICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IF9yZWY0LmNvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5ID0gX3JlZjQua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgICAgICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyhcbiAgICAgICAgICAgIF9yZWY1XG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVByb2Nlc3NpbmcubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUwoXG4gICAgICAgICAgICBfcmVmN1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1SZW1vdmFsLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORyhfcmVmOCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NUQVJUX0lURU1fTE9BRChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiBmdW5jdGlvbiBESURfU1RBUlRfSVRFTV9SRU1PVkUoX3JlZjEwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTKF9yZWYxMSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTEucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTEuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTKF9yZWYxMikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTIucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTIuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBmaWxlID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgICAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnZmlsZScsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJDUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBmaWxlbmFtZVxuICAgICAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgICAgIC8vIGZpbGUgYXBwZW5kZWRcbiAgICAgICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGUsIHsgaWQ6IHByb3BzLmlkIH0pKTtcblxuICAgICAgICAvLyBkYXRhIGhhcyBtb3ZlZCB0byBkYXRhLmpzXG4gICAgICAgIHJvb3QucmVmLmRhdGEgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBzdG9yYWdlXG4gICAgICovXG4gICAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlV3JhcHBlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICAgICAgbmFtZTogJ2ZpbGUtd3JhcHBlcicsXG4gICAgfSk7XG5cbiAgICB2YXIgUEFORUxfU1BSSU5HX1BST1BTID0geyB0eXBlOiAnc3ByaW5nJywgZGFtcGluZzogMC42LCBtYXNzOiA3IH07XG5cbiAgICB2YXIgY3JlYXRlJDYgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogUEFORUxfU1BSSU5HX1BST1BTLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgY3JlYXRlU2VjdGlvbihyb290LCBzZWN0aW9uLCBwcm9wcy5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS0nICsgcHJvcHMubmFtZSk7XG5cbiAgICAgICAgcm9vdC5yZWYuc2NhbGFibGUgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciB2aWV3Q29uc3RydWN0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgICAgIG5hbWU6ICdwYW5lbC0nICsgc2VjdGlvbi5uYW1lICsgJyBmaWxlcG9uZC0tJyArIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHZpZXdDb25zdHJ1Y3Rvciwgc2VjdGlvbi5wcm9wcyk7XG5cbiAgICAgICAgcm9vdC5yZWZbc2VjdGlvbi5uYW1lXSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHZpZXcpO1xuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkMyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICAgICAgLy8gdXBkYXRlIHNjYWxhYmxlIHN0YXRlXG4gICAgICAgIGlmIChyb290LnJlZi5zY2FsYWJsZSA9PT0gbnVsbCB8fCBwcm9wcy5zY2FsYWJsZSAhPT0gcm9vdC5yZWYuc2NhbGFibGUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoZWlnaHQsIGNhbid0IHNldFxuICAgICAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBjaGlsZCByZWN0c1xuICAgICAgICB2YXIgdG9wUmVjdCA9IHJvb3QucmVmLnRvcC5yZWN0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgodG9wUmVjdC5oZWlnaHQgKyBib3R0b21SZWN0LmhlaWdodCwgcHJvcHMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnRyYW5zbGF0ZVkgPSB0b3BSZWN0LmhlaWdodDtcblxuICAgICAgICAvLyBzY2FsZSBjZW50ZXIgcGFydFxuICAgICAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnNjYWxlWSA9IChoZWlnaHQgLSB0b3BSZWN0LmhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0KSAvIDEwMDtcblxuICAgICAgICAvLyBvZmZzZXQgYm90dG9tIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkgPSBoZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdwYW5lbCcsXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAgICAgcmV0dXJuIChwcm9wcy5oZWlnaHRDdXJyZW50ID0gcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogd3JpdGUkMyxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkNixcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ2hlaWdodCcsICdoZWlnaHRDdXJyZW50JywgJ3NjYWxhYmxlJ10sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlRHJhZ0hlbHBlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdIZWxwZXIoaXRlbXMpIHtcbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SW5kZXg6IGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbUluZGV4OiBmdW5jdGlvbiBnZXRJdGVtSW5kZXgoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtSWRzLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSVRFTV9UUkFOU0xBVEVfU1BSSU5HID0ge1xuICAgICAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICAgICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgICAgICBkYW1waW5nOiAwLjQ1LFxuICAgICAgICBtYXNzOiAxMCxcbiAgICB9O1xuXG4gICAgdmFyIElURU1fU0NBTEVfU1BSSU5HID0gJ3NwcmluZyc7XG5cbiAgICB2YXIgU3RhdGVNYXAgPSB7XG4gICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICdidXN5JyxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogJ2xvYWQtaW52YWxpZCcsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6ICdsb2FkLWVycm9yJyxcbiAgICAgICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6ICdyZW1vdmUtZXJyb3InLFxuICAgICAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICdidXN5JyxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiAncHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogJ3Byb2Nlc3NpbmctZXJyb3InLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogJ3Byb2Nlc3NpbmctcmV2ZXJ0LWVycm9yJyxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiAnaWRsZScsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIC8vIHNlbGVjdFxuICAgICAgICByb290LnJlZi5oYW5kbGVDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBpZFxuICAgICAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWl0ZW0tJyArIHByb3BzLmlkO1xuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAgICAgLy8gZmlsZSB2aWV3XG4gICAgICAgIHJvb3QucmVmLmNvbnRhaW5lciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVdyYXBwZXIsIHsgaWQ6IHByb3BzLmlkIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZmlsZSBwYW5lbFxuICAgICAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdpdGVtLXBhbmVsJyB9KSk7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBzdGFydCBoZWlnaHRcbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgICAgICAvLyBieSBkZWZhdWx0IG5vdCBtYXJrZWQgZm9yIHJlbW92YWxcbiAgICAgICAgcHJvcHMubWFya2VkRm9yUmVtb3ZhbCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCB0byBpZGxlIHNvIHNob3dzIGdyYWIgY3Vyc29yXG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgICAgICB2YXIgZ3JhYiA9IGZ1bmN0aW9uIGdyYWIoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IGUucGFnZVksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnQ2VudGVyID0ge1xuICAgICAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICB5OiBlLm9mZnNldFksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZHJhZ1N0YXRlID0gY3JlYXRlRHJhZ0hlbHBlcihyb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykpO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfR1JBQl9JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuXG4gICAgICAgICAgICB2YXIgZHJhZyA9IGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgICAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGRyYWdnZWQgc3RvcCBsaXN0ZW5pbmcgdG8gY2xpY2tzLCB3aWxsIHJlLWFkZCB3aGVuIGRvbmUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueCAqIHByb3BzLmRyYWdPZmZzZXQueCArXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueSAqIHByb3BzLmRyYWdPZmZzZXQueTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDE2ICYmICFyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBR19JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgZ3JhYik7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQxID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfVVBEQVRFX1BBTkVMX0hFSUdIVDogZnVuY3Rpb24gRElEX1VQREFURV9QQU5FTF9IRUlHSFQoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgICAgICByb290LmhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgd3JpdGUkNCA9IGNyZWF0ZVJvdXRlKFxuICAgICAgICB7XG4gICAgICAgICAgICBESURfR1JBQl9JVEVNOiBmdW5jdGlvbiBESURfR1JBQl9JVEVNKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICAgICAgICAgICAgeTogcm9vdC50cmFuc2xhdGVZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRElEX0RSQUdfSVRFTTogZnVuY3Rpb24gRElEX0RSQUdfSVRFTShfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJhZyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRElEX0RST1BfSVRFTTogZnVuY3Rpb24gRElEX0RST1BfSVRFTShfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJvcCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNi5hY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjYucHJvcHMsXG4gICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNi5zaG91bGRPcHRpbWl6ZTtcblxuICAgICAgICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3Quc2NhbGVYIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgICAgICAgICAuY29uY2F0KClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YXRlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgc2FtZSBzdGF0ZSB0d2ljZVxuICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSAhPT0gcHJvcHMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBwcm9wcy5jdXJyZW50U3RhdGUgPSBhY3Rpb24udHlwZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBzdGF0ZVxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmZpbGVwb25kSXRlbVN0YXRlID0gU3RhdGVNYXBbcHJvcHMuY3VycmVudFN0YXRlXSB8fCAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID1cbiAgICAgICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fCByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgICAgICBpZiAoIWFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgcm91dGUkMSh7IHJvb3Q6IHJvb3QsIGFjdGlvbnM6IGFjdGlvbnMsIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QuaGVpZ2h0ICYmIHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzeW5jIHBhbmVsIGhlaWdodCB3aXRoIGl0ZW0gaGVpZ2h0XG4gICAgICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSByb290LmhlaWdodDtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgaXRlbSA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ3LFxuICAgICAgICB3cml0ZTogd3JpdGUkNCxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmNykge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdSRUxFQVNFX0lURU0nLCB7IHF1ZXJ5OiBwcm9wcy5pZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgICBuYW1lOiAnaXRlbScsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogW1xuICAgICAgICAgICAgICAgICdpZCcsXG4gICAgICAgICAgICAgICAgJ2ludGVyYWN0aW9uTWV0aG9kJyxcbiAgICAgICAgICAgICAgICAnbWFya2VkRm9yUmVtb3ZhbCcsXG4gICAgICAgICAgICAgICAgJ3NwYXduRGF0ZScsXG4gICAgICAgICAgICAgICAgJ2RyYWdDZW50ZXInLFxuICAgICAgICAgICAgICAgICdkcmFnT3JpZ2luJyxcbiAgICAgICAgICAgICAgICAnZHJhZ09mZnNldCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknLCAnaGVpZ2h0J10sXG5cbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IElURU1fVFJBTlNMQVRFX1NQUklORyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAxNTAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0SXRlbXNQZXJSb3cgPSBmdW5jdGlvbihob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCkge1xuICAgICAgICAvLyBhZGQgb25lIHBpeGVsIGxlZXdheSwgd2hlbiB1c2luZyBwZXJjZW50YWdlcyBmb3IgaXRlbSB3aWR0aCB0b3RhbCBpdGVtcyBjYW4gYmUgMS45OSBwZXIgcm93XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKGhvcml6b250YWxTcGFjZSArIDEpIC8gaXRlbVdpZHRoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbih2aWV3LCBjaGlsZHJlbiwgcG9zaXRpb25JblZpZXcpIHtcbiAgICAgICAgaWYgKCFwb3NpdGlvbkluVmlldykgcmV0dXJuO1xuXG4gICAgICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSB2aWV3LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgLy8gY29uc3QgY2hpbGRyZW4gPSB2aWV3LmNoaWxkVmlld3M7XG4gICAgICAgIHZhciBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gLTEsIGRvbid0IG1vdmUgaXRlbXMgdG8gYWNjb21vZGF0ZSAoZWl0aGVyIGFkZCB0byB0b3Agb3IgYm90dG9tKVxuICAgICAgICBpZiAobCA9PT0gMCB8fCBwb3NpdGlvbkluVmlldy50b3AgPCBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQudG9wKSByZXR1cm4gLTE7XG5cbiAgICAgICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgICAgIHZhciBpdGVtID0gY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGl0ZW0ucmVjdC5lbGVtZW50O1xuICAgICAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgICAgIHZhciBpdGVtV2lkdGggPSBpdGVtUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAgICAgLy8gc3RhY2tcbiAgICAgICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRNaWQgPSBjaGlsZC5yZWN0Lm91dGVyLnRvcCArIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkTWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdyaWRcbiAgICAgICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpblRvcCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBpdGVtUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGw7IF9pbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhYID0gX2luZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcihfaW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgaXRlbVRvcCA9IG9mZnNldFkgLSBpdGVtUmVjdC5tYXJnaW5Ub3A7XG4gICAgICAgICAgICB2YXIgaXRlbVJpZ2h0ID0gb2Zmc2V0WCArIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkluVmlldy50b3AgPCBpdGVtQm90dG9tICYmIHBvc2l0aW9uSW5WaWV3LnRvcCA+IGl0ZW1Ub3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcubGVmdCA8IGl0ZW1SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luZGV4ICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gX2luZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsO1xuICAgIH07XG5cbiAgICB2YXIgZHJvcEFyZWFEaW1lbnNpb25zID0ge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBnZXQgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2V0SGVpZ2h0KHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2V0V2lkdGgodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMud2lkdGggPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIHNldERpbWVuc2lvbnMoaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IGhlaWdodCA9PT0gMCkgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJDggPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgICAgLy8gbmVlZCB0byBzZXQgcm9sZSB0byBsaXN0IGFzIG90aGVyd2lzZSBpdCB3b24ndCBiZSByZWFkIGFzIGEgbGlzdCBieSBWb2ljZU92ZXJcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgICAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbVxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvblxuICAgICAqL1xuICAgIHZhciBhZGRJdGVtVmlldyA9IGZ1bmN0aW9uIGFkZEl0ZW1WaWV3KF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgICAgaW5kZXggPSBhY3Rpb24uaW5kZXgsXG4gICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IGFjdGlvbi5pbnRlcmFjdGlvbk1ldGhvZDtcblxuICAgICAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgc3Bhd25EYXRlID0gbm93O1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDE7XG5cbiAgICAgICAgaWYgKGludGVyYWN0aW9uTWV0aG9kICE9PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIHZhciBjb29sZG93biA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9JTlRFUlZBTCcpO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBub3cgLSByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZTtcbiAgICAgICAgICAgIHNwYXduRGF0ZSA9IGRpc3QgPCBjb29sZG93biA/IG5vdyArIChjb29sZG93biAtIGRpc3QpIDogbm93O1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBzcGF3bkRhdGU7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgICAgICAvLyB2aWV3IHR5cGVcbiAgICAgICAgICAgICAgICBpdGVtLFxuXG4gICAgICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXduRGF0ZTogc3Bhd25EYXRlLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgbW92ZUl0ZW0gPSBmdW5jdGlvbiBtb3ZlSXRlbShpdGVtLCB4LCB5KSB7XG4gICAgICAgIHZhciB2eCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgICAgdmFyIHZ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuICAgICAgICAvLyBzZXQgdG8gbnVsbCB0byByZW1vdmUgYW5pbWF0aW9uIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgIGlmIChpdGVtLmRyYWdPZmZzZXQpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gaXRlbS5kcmFnT3JpZ2luLnggKyBpdGVtLmRyYWdPZmZzZXQueDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IGl0ZW0uZHJhZ09yaWdpbi55ICsgaXRlbS5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgICAgICAgaXRlbS5zY2FsZVkgPSAxLjAyNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuXG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGl0ZW0uc3Bhd25EYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgaXMgZGVmYXVsdCBzY2FsZSBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgIGl0ZW0uc2NhbGVYID0gMTtcbiAgICAgICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICAgICAgaXRlbS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW50cm9JdGVtVmlldyA9IGZ1bmN0aW9uIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KSB7XG4gICAgICAgIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkRST1ApIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gdnggKiAyMDtcblxuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSB2eSAqIDEwO1xuXG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDAuODtcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVZID0gMC44O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSAzMDtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gMzA7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgaXRlbVxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvblxuICAgICAqL1xuICAgIHZhciByZW1vdmVJdGVtVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1WaWV3KF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICAgICAgdmFyIHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuaW1hdGUgdmlldyBvdXQgb2Ygdmlld1xuICAgICAgICB2aWV3LnNjYWxlWCA9IDAuOTtcbiAgICAgICAgdmlldy5zY2FsZVkgPSAwLjk7XG4gICAgICAgIHZpZXcub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgLy8gbWFyayBmb3IgcmVtb3ZhbFxuICAgICAgICB2aWV3Lm1hcmtlZEZvclJlbW92YWwgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUhlaWdodCA9IGZ1bmN0aW9uIGdldEl0ZW1IZWlnaHQoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbSAqIDAuNSArXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICogMC41XG4gICAgICAgICk7XG4gICAgfTtcbiAgICB2YXIgZ2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gZ2V0SXRlbVdpZHRoKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQud2lkdGggK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkxlZnQgKiAwLjUgK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0ICogMC41XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkcmFnSXRlbSA9IGZ1bmN0aW9uIGRyYWdJdGVtKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgICAgZHJhZ1N0YXRlID0gYWN0aW9uLmRyYWdTdGF0ZTtcblxuICAgICAgICAvLyByZWZlcmVuY2UgdG8gaXRlbVxuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogaWQgfSk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGlkO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgICAgICB2YXIgb2xkSW5kZXggPSBkcmFnU3RhdGUuZ2V0SXRlbUluZGV4KGl0ZW0pO1xuXG4gICAgICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm47XG5cbiAgICAgICAgdmFyIGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHZpZXcuZHJhZ09yaWdpbi54ICsgdmlldy5kcmFnT2Zmc2V0LnggKyB2aWV3LmRyYWdDZW50ZXIueCxcbiAgICAgICAgICAgIHk6IHZpZXcuZHJhZ09yaWdpbi55ICsgdmlldy5kcmFnT2Zmc2V0LnkgKyB2aWV3LmRyYWdDZW50ZXIueSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgZHJhZyBhcmVhIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgICAgICB2YXIgZHJhZ1dpZHRoID0gZ2V0SXRlbVdpZHRoKHZpZXcpO1xuXG4gICAgICAgIC8vIGdldCByb3dzIGFuZCBjb2x1bW5zIChUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgcm93IGFuZCBvbmUgY29sdW1uIGlmIGEgZmlsZSBpcyBwcmVzZW50KVxuICAgICAgICB2YXIgY29scyA9IE1hdGguZmxvb3Iocm9vdC5yZWN0Lm91dGVyLndpZHRoIC8gZHJhZ1dpZHRoKTtcbiAgICAgICAgaWYgKGNvbHMgPiBudW1JdGVtcykgY29scyA9IG51bUl0ZW1zO1xuXG4gICAgICAgIC8vIHJvd3MgYXJlIHVzZWQgdG8gZmluZCB3aGVuIHdlIGhhdmUgbGVmdCB0aGUgcHJldmlldyBhcmVhIGJvdW5kaW5nIGJveFxuICAgICAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IobnVtSXRlbXMgLyBjb2xzICsgMSk7XG5cbiAgICAgICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldEhlaWdodCA9IGRyYWdIZWlnaHQgKiByb3dzO1xuICAgICAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0V2lkdGggPSBkcmFnV2lkdGggKiBjb2xzO1xuXG4gICAgICAgIC8vIGdldCBuZXcgaW5kZXggb2YgZHJhZ2dlZCBpdGVtXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnkgLyBkcmFnSGVpZ2h0KSxcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnggLyBkcmFnV2lkdGgpLFxuICAgICAgICAgICAgZ2V0R3JpZEluZGV4OiBmdW5jdGlvbiBnZXRHcmlkSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueSA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi54ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldFdpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi54IDwgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKiBjb2xzICsgdGhpcy54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbEluZGV4OiBmdW5jdGlvbiBnZXRDb2xJbmRleCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlldy5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gdmlldztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGw7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRCb3R0b20gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUb3AgPSBjaGlsZEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCb3R0b20gPSBjaGlsZFRvcCArIGNoaWxkSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZFRvcCArIGRyYWdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBuZXcgaW5kZXhcbiAgICAgICAgdmFyIGluZGV4ID0gY29scyA+IDEgPyBsb2NhdGlvbi5nZXRHcmlkSW5kZXgoKSA6IGxvY2F0aW9uLmdldENvbEluZGV4KCk7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHZpZXcsIGluZGV4OiBpbmRleCB9KTtcblxuICAgICAgICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gY2hhbmdlZCwgZGlzcGF0Y2ggcmVvcmRlciBhY3Rpb25cbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICBkcmFnU3RhdGUuc2V0SW5kZXgoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9sZEluZGV4LFxuICAgICAgICAgICAgICAgIHRhcmdldDogaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhY3Rpb24gcm91dGVzXG4gICAgICovXG4gICAgdmFyIHJvdXRlJDIgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9BRERfSVRFTTogYWRkSXRlbVZpZXcsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogcmVtb3ZlSXRlbVZpZXcsXG4gICAgICAgIERJRF9EUkFHX0lURU06IGRyYWdJdGVtLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gdmlld1xuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJvcHNcbiAgICAgKi9cbiAgICB2YXIgd3JpdGUkNSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjUuYWN0aW9ucyxcbiAgICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjUuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUkMih7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcbiAgICAgICAgdmFyIGRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgICAgICAvLyBhdmFpbGFibGUgc3BhY2Ugb24gaG9yaXpvbnRhbCBheGlzXG4gICAgICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcblxuICAgICAgICAvLyBvbmx5IGRyYXcgY2hpbGRyZW4gdGhhdCBoYXZlIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzb3J0IGJhc2VkIG9uIGN1cnJlbnQgYWN0aXZlIGl0ZW1zXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3RcbiAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4XG4gICAgICAgIHZhciBkcmFnSW5kZXggPSBkcmFnQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgID8gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihyb290LCBjaGlsZHJlbiwgZHJhZ0Nvb3JkaW5hdGVzKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgICAgICB2YXIgYWRkSW5kZXggPSByb290LnJlZi5hZGRJbmRleCB8fCBudWxsO1xuXG4gICAgICAgIC8vIGFkZCBpbmRleCBubyBsb25nZXIgbmVlZGVkIHRpbGwgcG9zc2libHkgbmV4dCBkcmF3XG4gICAgICAgIHJvb3QucmVmLmFkZEluZGV4ID0gbnVsbDtcblxuICAgICAgICB2YXIgZHJhZ0luZGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHJlbW92ZUluZGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGFkZEluZGV4T2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudDtcbiAgICAgICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIHZhciBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgICAgICAvLyBzdGFja1xuICAgICAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHZhciBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gaW5kZXggLSBkcmFnSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5tYXJrZWRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCAwLCBvZmZzZXRZICsgZHJhZ09mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc3VhbEhlaWdodCA9IGl0ZW1IZWlnaHQgKiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCA/IGNoaWxkLm9wYWNpdHkgOiAxKTtcblxuICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gdmlzdWFsSGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2WCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJldlkgPSAwO1xuXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZHJhZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdJbmRleE9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBhZGRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRJbmRleE9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXJrZWRGb3JSZW1vdmFsICYmIGNoaWxkLm9wYWNpdHkgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSW5kZXhPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzdWFsSW5kZXggPSBpbmRleCArIGFkZEluZGV4T2Zmc2V0ICsgZHJhZ0luZGV4T2Zmc2V0ICsgcmVtb3ZlSW5kZXhPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhYID0gdmlzdWFsSW5kZXggJSBpdGVtc1BlclJvdztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gaW5kZXhZICogaXRlbUhlaWdodDtcblxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvclkgPSBNYXRoLnNpZ24ob2Zmc2V0WSAtIHByZXZZKTtcblxuICAgICAgICAgICAgICAgIHByZXZYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IG9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSwgdmVjdG9yWCwgdmVjdG9yWSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIGFjdGlvbnMgdGhhdCBhcmUgbWVhbnQgc3BlY2lmaWNhbGx5IGZvciBhIGNlcnRhaW4gY2hpbGQgb2YgdGhlIGxpc3RcbiAgICAgKiBAcGFyYW0gY2hpbGRcbiAgICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgICAqL1xuICAgIHZhciBmaWx0ZXJTZXRJdGVtQWN0aW9ucyA9IGZ1bmN0aW9uIGZpbHRlclNldEl0ZW1BY3Rpb25zKGNoaWxkLCBhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25zLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIGFjdGlvbiBoYXMgYW4gaWQsIGZpbHRlciBvdXQgYWN0aW9ucyB0aGF0IGRvbid0IGhhdmUgdGhpcyBjaGlsZCBpZFxuICAgICAgICAgICAgaWYgKGFjdGlvbi5kYXRhICYmIGFjdGlvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBhY3Rpb24uZGF0YS5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgYWxsIG90aGVyIGFjdGlvbnNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3QgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkOCxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDUsXG4gICAgICAgIHRhZzogJ3VsJyxcbiAgICAgICAgbmFtZTogJ2xpc3QnLFxuICAgICAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uIGRpZFdyaXRlVmlldyhfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICAgICAgcm9vdC5jaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3Lm1hcmtlZEZvclJlbW92YWwgJiYgdmlldy5vcGFjaXR5ID09PSAwICYmIHZpZXcucmVzdGluZztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQ6IGZpbHRlclNldEl0ZW1BY3Rpb25zLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFsnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlJDkgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3QpKTtcbiAgICAgICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHN0b3JlRHJhZ0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gc3RvcmVEcmFnQ29vcmRpbmF0ZXMoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQgLSByb290LnJlZi5saXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgICAgICAgdG9wOlxuICAgICAgICAgICAgICAgIGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAgICAgKHJvb3QucmVjdC5vdXRlci50b3AgKyByb290LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyByb290LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXJEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjbGVhckRyYWdDb29yZGluYXRlcyhfcmVmMykge1xuICAgICAgICB2YXIgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlJDMgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9EUkFHOiBzdG9yZURyYWdDb29yZGluYXRlcyxcbiAgICAgICAgRElEX0VORF9EUkFHOiBjbGVhckRyYWdDb29yZGluYXRlcyxcbiAgICB9KTtcblxuICAgIHZhciB3cml0ZSQ2ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNC5hY3Rpb25zO1xuXG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUkMyh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcblxuICAgICAgICAvLyBjdXJyZW50IGRyYWcgcG9zaXRpb25cbiAgICAgICAgcm9vdC5yZWYubGlzdC5kcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAgICAgLy8gaWYgY3VycmVudGx5IG92ZXJmbG93aW5nIGJ1dCBubyBsb25nZXIgcmVjZWl2ZWQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKHByb3BzLm92ZXJmbG93aW5nICYmICFwcm9wcy5vdmVyZmxvdykge1xuICAgICAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgb3ZlcmZsb3cgc3RhdGVcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJyc7XG4gICAgICAgICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBub3Qgb3ZlcmZsb3dpbmcgY3VycmVudGx5IGJ1dCBkb2VzIHJlY2VpdmUgb3ZlcmZsb3cgdmFsdWVcbiAgICAgICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChwcm9wcy5vdmVyZmxvdyk7XG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHByb3BzLm92ZXJmbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICdvdmVyZmxvdyc7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxpc3RTY3JvbGxlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgICAgICB3cml0ZTogd3JpdGUkNixcbiAgICAgICAgbmFtZTogJ2xpc3Qtc2Nyb2xsZXInLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFsnb3ZlcmZsb3cnLCAnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICAgICAgICBzdHlsZXM6IFsnaGVpZ2h0JywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgYXR0clRvZ2dsZSA9IGZ1bmN0aW9uIGF0dHJUb2dnbGUoZWxlbWVudCwgbmFtZSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyc7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCBlbmFibGVkVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0RmlsZUlucHV0ID0gZnVuY3Rpb24gcmVzZXRGaWxlSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgLy8gbm8gdmFsdWUsIG5vIG5lZWQgdG8gcmVzZXRcbiAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gZm9yIElFMTBcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgICAgICAgIHZhciBmb3JtID0gY3JlYXRlRWxlbWVudCQxKCdmb3JtJyk7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGlucHV0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXQsIHJlZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIC8vIHNldCBpZCBzbyBjYW4gYmUgcmVmZXJlbmNlZCBmcm9tIG91dHNpZGUgbGFiZWxzXG4gICAgICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gc2V0IG5hbWUgb2YgZWxlbWVudCAoaXMgcmVtb3ZlZCB3aGVuIGEgdmFsdWUgaXMgc2V0KVxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ25hbWUnLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtY29udHJvbHMnLCAnZmlsZXBvbmQtLWFzc2lzdGFudC0nICsgcHJvcHMuaWQpO1xuXG4gICAgICAgIC8vIHNldCBsYWJlbCwgd2UgdXNlIGxhYmVsbGVkIGJ5IGFzIG90aGVyd2lzZSB0aGUgc2NyZWVucmVhZGVyIGRvZXMgbm90IHJlYWQgdGhlIFwiYnJvd3NlXCIgdGV4dCBpbiB0aGUgbGFiZWwgKGFzIGl0IGhhcyB0YWJpbmRleDogMClcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyBzZXQgY29uZmlndXJhYmxlIHByb3BzXG4gICAgICAgIHNldEFjY2VwdGVkRmlsZVR5cGVzKHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTJykgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZUFsbG93TXVsdGlwbGUoeyByb290OiByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH0gfSk7XG4gICAgICAgIHRvZ2dsZURpcmVjdG9yeUZpbHRlcih7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWScpIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVEaXNhYmxlZCh7IHJvb3Q6IHJvb3QgfSk7XG4gICAgICAgIHRvZ2dsZVJlcXVpcmVkKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSB9IH0pO1xuICAgICAgICBzZXRDYXB0dXJlTWV0aG9kKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQ0FQVFVSRV9NRVRIT0QnKSB9IH0pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICByb290LnJlZi5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QuZWxlbWVudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBmaWxlcyBhbmQgbW92ZSB2YWx1ZSBvZiB3ZWJraXRSZWxhdGl2ZVBhdGggcGF0aCB0byBfcmVsYXRpdmVQYXRoXG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBBcnJheS5mcm9tKHJvb3QuZWxlbWVudC5maWxlcykubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3ZSBhZGQgYSBsaXR0bGUgZGVsYXkgc28gdGhlIE9TIGZpbGUgc2VsZWN0IHdpbmRvdyBjYW4gbW92ZSBvdXQgb2YgdGhlIHdheSBiZWZvcmUgd2UgYWRkIG91ciBmaWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGxvYWQgZmlsZXNcbiAgICAgICAgICAgICAgICBwcm9wcy5vbmxvYWQoZmlsZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5wdXQsIGl0J3MganVzdCBmb3IgZXhwb3NpbmcgYSBtZXRob2QgdG8gZHJvcCBmaWxlcywgc2hvdWxkIG5vdCByZXRhaW4gYW55IHN0YXRlXG4gICAgICAgICAgICAgICAgcmVzZXRGaWxlSW5wdXQocm9vdC5lbGVtZW50KTtcbiAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJvb3QucmVmLmhhbmRsZUNoYW5nZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRBY2NlcHRlZEZpbGVUeXBlcyA9IGZ1bmN0aW9uIHNldEFjY2VwdGVkRmlsZVR5cGVzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfU1lOQ19BQ0NFUFRfQVRUUklCVVRFJykpIHJldHVybjtcbiAgICAgICAgYXR0clRvZ2dsZShcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgICdhY2NlcHQnLFxuICAgICAgICAgICAgISFhY3Rpb24udmFsdWUsXG4gICAgICAgICAgICBhY3Rpb24udmFsdWUgPyBhY3Rpb24udmFsdWUuam9pbignLCcpIDogJydcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvZ2dsZUFsbG93TXVsdGlwbGUgPSBmdW5jdGlvbiB0b2dnbGVBbGxvd011bHRpcGxlKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdtdWx0aXBsZScsIGFjdGlvbi52YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIgPSBmdW5jdGlvbiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3dlYmtpdGRpcmVjdG9yeScsIGFjdGlvbi52YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVEaXNhYmxlZCA9IGZ1bmN0aW9uIHRvZ2dsZURpc2FibGVkKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGRvZXNBbGxvd0Jyb3dzZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19CUk9XU0UnKTtcbiAgICAgICAgdmFyIGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsIGRpc2FibGVGaWVsZCk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVSZXF1aXJlZCA9IGZ1bmN0aW9uIHRvZ2dsZVJlcXVpcmVkKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgICAgLy8gd2FudCB0byByZW1vdmUgcmVxdWlyZWQsIGFsd2F5cyBwb3NzaWJsZVxuICAgICAgICBpZiAoIWFjdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3YW50IHRvIG1ha2UgcmVxdWlyZWQsIG9ubHkgcG9zc2libGUgd2hlbiB6ZXJvIGl0ZW1zXG4gICAgICAgIGVsc2UgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID09PSAwKSB7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldENhcHR1cmVNZXRob2QgPSBmdW5jdGlvbiBzZXRDYXB0dXJlTWV0aG9kKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgICAgYXR0clRvZ2dsZShcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgICdjYXB0dXJlJyxcbiAgICAgICAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWVcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVJlcXVpcmVkU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlUmVxdWlyZWRTdGF0dXMoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgICB2YXIgZWxlbWVudCA9IHJvb3QuZWxlbWVudDtcbiAgICAgICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIHdoZW4gbW9yZSB0aGFuIHplcm8gaXRlbXNcbiAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID4gMCkge1xuICAgICAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgdHJ1ZSwgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgdmFsaWRhdGlvbiBtZXNzYWdlc1xuICAgICAgICAgICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWRkIHJlcXVpcmVkIGlmIHRoZSBmaWVsZCBoYXMgYmVlbiBkZWVtZWQgcmVxdWlyZWRcbiAgICAgICAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSkge1xuICAgICAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzKF9yZWY5KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgaWYgKCFzaG91bGRDaGVja1ZhbGlkaXR5KSByZXR1cm47XG4gICAgICAgIHJvb3QuZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eShyb290LnF1ZXJ5KCdHRVRfTEFCRUxfSU5WQUxJRF9GSUVMRCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnaW5wdXQnLFxuICAgICAgICBuYW1lOiAnYnJvd3NlcicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRhLFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgICAgICBESURfUkVNT1ZFX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyxcblxuICAgICAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgICAgICBESURfU0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFk6IHRvZ2dsZURpcmVjdG9yeUZpbHRlcixcbiAgICAgICAgICAgIERJRF9TRVRfQUxMT1dfTVVMVElQTEU6IHRvZ2dsZUFsbG93TXVsdGlwbGUsXG4gICAgICAgICAgICBESURfU0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVM6IHNldEFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgICAgICAgRElEX1NFVF9DQVBUVVJFX01FVEhPRDogc2V0Q2FwdHVyZU1ldGhvZCxcbiAgICAgICAgICAgIERJRF9TRVRfUkVRVUlSRUQ6IHRvZ2dsZVJlcXVpcmVkLFxuICAgICAgICB9KSxcbiAgICB9KTtcblxuICAgIHZhciBLZXkgPSB7XG4gICAgICAgIEVOVEVSOiAxMyxcbiAgICAgICAgU1BBQ0U6IDMyLFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJGIgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGxhYmVsIGFuZCBsaW5rIGl0IHRvIHRoZSBmaWxlIGJyb3dzZXJcbiAgICAgICAgdmFyIGxhYmVsID0gY3JlYXRlRWxlbWVudCQxKCdsYWJlbCcpO1xuICAgICAgICBhdHRyKGxhYmVsLCAnZm9yJywgJ2ZpbGVwb25kLS1icm93c2VyLScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICAgICAgYXR0cihsYWJlbCwgJ2lkJywgJ2ZpbGVwb25kLS1kcm9wLWxhYmVsLScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgbGFiZWwgZm9yIHNjcmVlbnJlYWRlcnMsIHRoZSBpbnB1dCBlbGVtZW50IHdpbGwgcmVhZCB0aGUgY29udGVudHMgb2YgdGhlIGxhYmVsIHdoZW4gaXQncyBmb2N1c3NlZC4gSWYgd2UgZG9uJ3Qgc2V0IGFyaWEtaGlkZGVuIHRoZSBzY3JlZW5yZWFkZXIgd2lsbCBhbHNvIG5hdmlnYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgbGFiZWwgc2VwYXJhdGVseSBmcm9tIHRoZSBpbnB1dC5cbiAgICAgICAgYXR0cihsYWJlbCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBoYW5kbGUga2V5c1xuICAgICAgICByb290LnJlZi5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZhdGlvbktleSA9IGUua2V5Q29kZSA9PT0gS2V5LkVOVEVSIHx8IGUua2V5Q29kZSA9PT0gS2V5LlNQQUNFO1xuICAgICAgICAgICAgaWYgKCFpc0FjdGl2YXRpb25LZXkpIHJldHVybjtcbiAgICAgICAgICAgIC8vIHN0b3BzIGZyb20gdHJpZ2dlcmluZyB0aGUgZWxlbWVudCBhIHNlY29uZCB0aW1lXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgICAgICByb290LnJlZi5sYWJlbC5jbGljaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2xpY2sgdHdpY2VcbiAgICAgICAgICAgIGlmIChpc0xhYmVsQ2xpY2spIHJldHVybjtcblxuICAgICAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgcHJvcHMuY2FwdGlvbik7XG5cbiAgICAgICAgLy8gYWRkIVxuICAgICAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgcm9vdC5yZWYubGFiZWwgPSBsYWJlbDtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUxhYmVsVmFsdWUgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGNsaWNrYWJsZSA9IGxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWxlcG9uZC0tbGFiZWwtYWN0aW9uJyk7XG4gICAgICAgIGlmIChjbGlja2FibGUpIHtcbiAgICAgICAgICAgIGF0dHIoY2xpY2thYmxlLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRyb3BMYWJlbCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGIsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9TRVRfTEFCRUxfSURMRTogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9JRExFKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgICAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogJ2RyaXAtYmxvYicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGFkZEJsb2IgPSBmdW5jdGlvbiBhZGRCbG9iKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJsb2IsIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogMi41LFxuICAgICAgICAgICAgICAgIHNjYWxlWTogMi41LFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogY2VudGVyWSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBtb3ZlQmxvYiA9IGZ1bmN0aW9uIG1vdmVCbG9iKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICBhZGRCbG9iKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWSA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcDtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAxO1xuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIHZhciBoaWRlQmxvYiA9IGZ1bmN0aW9uIGhpZGVCbG9iKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdDtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGxvZGVCbG9iID0gZnVuY3Rpb24gZXhwbG9kZUJsb2IoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDIuNTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ3ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zO1xuICAgICAgICByb3V0ZSQ0KHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuICAgICAgICB2YXIgYmxvYiA9IHJvb3QucmVmLmJsb2I7XG5cbiAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwICYmIGJsb2IgJiYgYmxvYi5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQ0ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgICAgIERJRF9EUk9QOiBleHBsb2RlQmxvYixcbiAgICAgICAgRElEX0VORF9EUkFHOiBoaWRlQmxvYixcbiAgICB9KTtcblxuICAgIHZhciBkcmlwID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIG5hbWU6ICdkcmlwJyxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDcsXG4gICAgfSk7XG5cbiAgICB2YXIgc2V0SW5wdXRGaWxlcyA9IGZ1bmN0aW9uIHNldElucHV0RmlsZXMoZWxlbWVudCwgZmlsZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIERhdGFUcmFuc2ZlciBpbnN0YW5jZSBhbmQgYWRkIGEgbmV3bHkgY3JlYXRlZCBmaWxlXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLml0ZW1zLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlKFtmaWxlXSwgZmlsZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBEYXRhVHJhbnNmZXIgZmlsZXMgbGlzdCB0byB0aGUgZmlsZSBpbnB1dFxuICAgICAgICAgICAgZWxlbWVudC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICByZXR1cm4gKHJvb3QucmVmLmZpZWxkcyA9IHt9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpZWxkID0gZnVuY3Rpb24gZ2V0RmllbGQocm9vdCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucmVmLmZpZWxkc1tpZF07XG4gICAgfTtcblxuICAgIHZhciBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMgPSBmdW5jdGlvbiBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCkge1xuICAgICAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUmVvcmRlckl0ZW1zID0gZnVuY3Rpb24gZGlkUmVvcmRlckl0ZW1zKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgcmV0dXJuIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFkZEl0ZW0gPSBmdW5jdGlvbiBkaWRBZGRJdGVtKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgaXNMb2NhbEZpbGUgPSBmaWxlSXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUw7XG4gICAgICAgIHZhciBzaG91bGRVc2VGaWxlSW5wdXQgPSAhaXNMb2NhbEZpbGUgJiYgcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJyk7XG4gICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCQxKCdpbnB1dCcpO1xuICAgICAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSBzaG91bGRVc2VGaWxlSW5wdXQgPyAnZmlsZScgOiAnaGlkZGVuJztcbiAgICAgICAgZGF0YUNvbnRhaW5lci5uYW1lID0gcm9vdC5xdWVyeSgnR0VUX05BTUUnKTtcbiAgICAgICAgZGF0YUNvbnRhaW5lci5kaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXSA9IGRhdGFDb250YWluZXI7XG4gICAgICAgIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZExvYWRJdGVtJDEgPSBmdW5jdGlvbiBkaWRMb2FkSXRlbShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgICAgIGlmICghZmllbGQpIHJldHVybjtcblxuICAgICAgICAvLyBzdG9yZSBzZXJ2ZXIgcmVmIGluIGhpZGRlbiBpbnB1dFxuICAgICAgICBpZiAoYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGwpIGZpZWxkLnZhbHVlID0gYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgLy8gc3RvcmUgZmlsZSBpdGVtIGluIGZpbGUgaW5wdXRcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQnKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaWxlSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgc2V0SW5wdXRGaWxlcyhmaWVsZCwgW2ZpbGVJdGVtLmZpbGVdKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFByZXBhcmVPdXRwdXQgPSBmdW5jdGlvbiBkaWRQcmVwYXJlT3V0cHV0KF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgICAgLy8gdGhpcyB0aW1lb3V0IHB1c2hlcyB0aGUgaGFuZGxlciBhZnRlciAnbG9hZCdcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQnKSkgcmV0dXJuO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICAgICAgICAgIHNldElucHV0RmlsZXMoZmllbGQsIFthY3Rpb24uZmlsZV0pO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldERpc2FibGVkID0gZnVuY3Rpb24gZGlkU2V0RGlzYWJsZWQoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFJlbW92ZUl0ZW0gPSBmdW5jdGlvbiBkaWRSZW1vdmVJdGVtKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZmllbGQucGFyZW50Tm9kZSkgZmllbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmaWVsZCk7XG4gICAgICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbiAgICB9O1xuXG4gICAgLy8gb25seSBydW5zIGZvciBzZXJ2ZXIgZmlsZXMgKHNvIGRvZXNuJ3QgZGVhbCB3aXRoIGZpbGUgaW5wdXQpXG4gICAgdmFyIGRpZERlZmluZVZhbHVlID0gZnVuY3Rpb24gZGlkRGVmaW5lVmFsdWUoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjguYWN0aW9uO1xuICAgICAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgIGlmIChhY3Rpb24udmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGZpZWxkIHZhbHVlXG4gICAgICAgICAgICBmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXQgZmllbGQgdmFsdWVcbiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDggPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9TRVRfRElTQUJMRUQ6IGRpZFNldERpc2FibGVkLFxuICAgICAgICBESURfQUREX0lURU06IGRpZEFkZEl0ZW0sXG4gICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtJDEsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogZGlkUmVtb3ZlSXRlbSxcbiAgICAgICAgRElEX0RFRklORV9WQUxVRTogZGlkRGVmaW5lVmFsdWUsXG4gICAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogZGlkUHJlcGFyZU91dHB1dCxcbiAgICAgICAgRElEX1JFT1JERVJfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICAgICAgRElEX1NPUlRfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICB9KTtcblxuICAgIHZhciBkYXRhID0gY3JlYXRlVmlldyh7XG4gICAgICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRjLFxuICAgICAgICB3cml0ZTogd3JpdGUkOCxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHZhciBnZXRSb290Tm9kZSA9IGZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICdnZXRSb290Tm9kZScgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xuICAgIH07XG5cbiAgICB2YXIgaW1hZ2VzID0gWydqcGcnLCAnanBlZycsICdwbmcnLCAnZ2lmJywgJ2JtcCcsICd3ZWJwJywgJ3N2ZycsICd0aWZmJ107XG4gICAgdmFyIHRleHQkMSA9IFsnY3NzJywgJ2NzdicsICdodG1sJywgJ3R4dCddO1xuICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHppcDogJ3ppcHxjb21wcmVzc2VkJyxcbiAgICAgICAgZXB1YjogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbiAgICB9O1xuXG4gICAgdmFyIGd1ZXNzdGltYXRlTWltZVR5cGUgPSBmdW5jdGlvbiBndWVzc3RpbWF0ZU1pbWVUeXBlKCkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChpbWFnZXMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnaW1hZ2UvJyArXG4gICAgICAgICAgICAgICAgKGV4dGVuc2lvbiA9PT0gJ2pwZycgPyAnanBlZycgOiBleHRlbnNpb24gPT09ICdzdmcnID8gJ3N2Zyt4bWwnIDogZXh0ZW5zaW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCQxLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dC8nICsgZXh0ZW5zaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zID0gZnVuY3Rpb24gcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IGxpbmtzIGZyb20gdHJhbnNmZXIsIGlmIGZvdW5kIHdlJ2xsIGV4aXQgaW1tZWRpYXRlbHkgKHVubGVzcyBhIGZpbGUgaXMgaW4gdGhlIGRhdGFUcmFuc2ZlciBhcyB3ZWxsLCB0aGlzIGlzIGJlY2F1c2UgRmlyZWZveCBjb3VsZCByZXByZXNlbnQgdGhlIGZpbGUgYXMgYSBVUkwgYW5kIGEgZmlsZSBvYmplY3QgYXQgdGhlIHNhbWUgdGltZSlcbiAgICAgICAgICAgIHZhciBsaW5rcyA9IGdldExpbmtzKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoICYmICFoYXNGaWxlcyhkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGlua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgICAgICAgZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKS50aGVuKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBkYXRhdHJhbnNmZXIgaGFzIGZpbGVzXG4gICAgICovXG4gICAgdmFyIGhhc0ZpbGVzID0gZnVuY3Rpb24gaGFzRmlsZXMoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIuZmlsZXMpIHJldHVybiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBmaWxlcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgICAqL1xuICAgIHZhciBnZXRGaWxlcyA9IGZ1bmN0aW9uIGdldEZpbGVzKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHRyYW5zZmVyIGl0ZW1zIGFzIHByb21pc2VzXG4gICAgICAgICAgICB2YXIgcHJvbWlzZWRGaWxlcyA9IChkYXRhVHJhbnNmZXIuaXRlbXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5pdGVtcykgOiBbXSlcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmlsZVN5c3RlbUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIC8vIG1hcCBlYWNoIGl0ZW0gdG8gcHJvbWlzZVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaWYgaXMgZW1wdHksIHNlZSBpZiB3ZSBjYW4gZXh0cmFjdCBzb21lIGluZm8gZnJvbSB0aGUgZmlsZXMgcHJvcGVydHkgYXMgYSBmYWxsYmFja1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRlc3QgZm9yIGRpcmVjdG9yaWVzIChzaG91bGQgbm90IGJlIGFsbG93ZWQpXG4gICAgICAgICAgICAgICAgLy8gVXNlIEZpbGVSZWFkZXIsIHByb2JsZW0gaXMgdGhhdCB0aGUgZmlsZXMgcHJvcGVydHkgZ2V0cyBsb3N0IGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVHJhbnNmZXIuZmlsZXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcykgOiBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZWRGaWxlcylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXR1cm5lZEZpbGVHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkRmlsZUdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoLmFwcGx5KGZpbGVzLCBncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmUgKGZpbHRlciBvdXQgZW1wdHkgZmlsZXMpIVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLl9yZWxhdGl2ZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0ZpbGVTeXN0ZW1JdGVtID0gZnVuY3Rpb24gaXNGaWxlU3lzdGVtSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpc0VudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBnZXRBc0VudHJ5KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmlzRmlsZSB8fCBlbnRyeS5pc0RpcmVjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlc0Zyb21JdGVtID0gZnVuY3Rpb24gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZ2V0RmlsZXNJbkRpcmVjdG9yeShnZXRBc0VudHJ5KGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoW2l0ZW0uZ2V0QXNGaWxlKCldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlc0luRGlyZWN0b3J5ID0gZnVuY3Rpb24gZ2V0RmlsZXNJbkRpcmVjdG9yeShlbnRyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gdGhlIHRvdGFsIGVudHJpZXMgdG8gcmVhZFxuICAgICAgICAgICAgdmFyIGRpckNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIGZpbGVDb3VudGVyID0gMDtcblxuICAgICAgICAgICAgdmFyIHJlc29sdmVJZkRvbmUgPSBmdW5jdGlvbiByZXNvbHZlSWZEb25lKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQ291bnRlciA9PT0gMCAmJiBkaXJDb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHRoZSByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uIHJlYWRFbnRyaWVzKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZGlyQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdG9yeVJlYWRlciA9IGRpckVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0b3JpZXMgYXJlIHJldHVybmVkIGluIGJhdGNoZXMsIHdlIG5lZWQgdG8gcHJvY2VzcyBhbGwgYmF0Y2hlcyBiZWZvcmUgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIHZhciByZWFkQmF0Y2ggPSBmdW5jdGlvbiByZWFkQmF0Y2goKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmVhZCBtb3JlIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFkIGFzIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRGaWxlID0gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5mdWxsUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRGaWxlLl9yZWxhdGl2ZVBhdGggPSBlbnRyeS5mdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY29ycmVjdGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBuZXh0IGJhdGNoIG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ28hXG4gICAgICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY29ycmVjdE1pc3NpbmdGaWxlVHlwZSA9IGZ1bmN0aW9uIGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS50eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIHZhciBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgICAgICB2YXIgbmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgdmFyIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShmaWxlLm5hbWUpKTtcbiAgICAgICAgaWYgKCF0eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgdHlwZSk7XG4gICAgICAgIGZpbGUubmFtZSA9IG5hbWU7XG4gICAgICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGU7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG5cbiAgICB2YXIgaXNEaXJlY3RvcnlFbnRyeSA9IGZ1bmN0aW9uIGlzRGlyZWN0b3J5RW50cnkoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG4gICAgfTtcblxuICAgIHZhciBpc0VudHJ5ID0gZnVuY3Rpb24gaXNFbnRyeShpdGVtKSB7XG4gICAgICAgIHJldHVybiAnd2Via2l0R2V0QXNFbnRyeScgaW4gaXRlbTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEFzRW50cnkgPSBmdW5jdGlvbiBnZXRBc0VudHJ5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBsaW5rcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgICAqL1xuICAgIHZhciBnZXRMaW5rcyA9IGZ1bmN0aW9uIGdldExpbmtzKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGxvb2sgaW4gbWV0YSBkYXRhIHByb3BlcnR5XG4gICAgICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBub3BlIG5vcGUgbm9wZSAocHJvYmFibHkgSUUgdHJvdWJsZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgfTtcblxuICAgIHZhciBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEgPSBmdW5jdGlvbiBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3VybCcpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEgPSBmdW5jdGlvbiBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFttYXRjaGVzWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIHZhciBkcmFnTkRyb3BPYnNlcnZlcnMgPSBbXTtcblxuICAgIHZhciBldmVudFBvc2l0aW9uID0gZnVuY3Rpb24gZXZlbnRQb3NpdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlTGVmdDogZS5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VUb3A6IGUucGFnZVksXG4gICAgICAgICAgICBzY29wZUxlZnQ6IGUub2Zmc2V0WCB8fCBlLmxheWVyWCxcbiAgICAgICAgICAgIHNjb3BlVG9wOiBlLm9mZnNldFkgfHwgZS5sYXllclksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEcmFnTkRyb3BDbGllbnQgPSBmdW5jdGlvbiBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHNjb3BlVG9PYnNlcnZlLFxuICAgICAgICBmaWx0ZXJFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGdldERyYWdORHJvcE9ic2VydmVyKHNjb3BlVG9PYnNlcnZlKTtcblxuICAgICAgICB2YXIgY2xpZW50ID0ge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIG9uZHJvcDogZnVuY3Rpb24gb25kcm9wKCkge30sXG4gICAgICAgICAgICBvbmVudGVyOiBmdW5jdGlvbiBvbmVudGVyKCkge30sXG4gICAgICAgICAgICBvbmRyYWc6IGZ1bmN0aW9uIG9uZHJhZygpIHt9LFxuICAgICAgICAgICAgb25leGl0OiBmdW5jdGlvbiBvbmV4aXQoKSB7fSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgICAgICBhbGxvd2Ryb3A6IGZ1bmN0aW9uIGFsbG93ZHJvcCgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIgPSBmdW5jdGlvbiBnZXREcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KSB7XG4gICAgICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBkcmFnTkRyb3BPYnNlcnZlcnMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG9ic2VydmVyLCBkb2VzIG5vdCB5ZXQgZXhpc3QgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICB2YXIgbmV3T2JzZXJ2ZXIgPSBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KTtcbiAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnB1c2gobmV3T2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gbmV3T2JzZXJ2ZXI7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNsaWVudHMgPSBbXTtcblxuICAgICAgICB2YXIgcm91dGVzID0ge1xuICAgICAgICAgICAgZHJhZ2VudGVyOiBkcmFnZW50ZXIsXG4gICAgICAgICAgICBkcmFnb3ZlcjogZHJhZ292ZXIsXG4gICAgICAgICAgICBkcmFnbGVhdmU6IGRyYWdsZWF2ZSxcbiAgICAgICAgICAgIGRyb3A6IGRyb3AsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0ge307XG5cbiAgICAgICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCwgY3JlYXRlSGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTGlzdGVuZXIoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGFzIGNsaWVudFxuICAgICAgICAgICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlbW92ZUxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBtb3JlIGNsaWVudHMsIGNsZWFuIHVwIG9ic2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnNwbGljZShkcmFnTkRyb3BPYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Jpbihyb3V0ZXMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH07XG5cbiAgICB2YXIgZWxlbWVudEZyb21Qb2ludCA9IGZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQocm9vdCwgcG9pbnQpIHtcbiAgICAgICAgaWYgKCEoJ2VsZW1lbnRGcm9tUG9pbnQnIGluIHJvb3QpKSB7XG4gICAgICAgICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QuZWxlbWVudEZyb21Qb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KGUsIHRhcmdldCkge1xuICAgICAgICAvLyBnZXQgcm9vdFxuICAgICAgICB2YXIgcm9vdCA9IGdldFJvb3ROb2RlKHRhcmdldCk7XG5cbiAgICAgICAgLy8gZ2V0IGVsZW1lbnQgYXQgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgcm9vdCBpcyBub3QgYWN0dWFsIHNoYWRvdyBET00gYW5kIGRvZXMgbm90IGhhdmUgZWxlbWVudEZyb21Qb2ludCBtZXRob2QsIHVzZSB0aGUgb25lIG9uIGRvY3VtZW50XG4gICAgICAgIHZhciBlbGVtZW50QXRQb3NpdGlvbiA9IGVsZW1lbnRGcm9tUG9pbnQocm9vdCwge1xuICAgICAgICAgICAgeDogZS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHk6IGUucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRlc3QgaWYgdGFyZ2V0IGlzIHRoZSBlbGVtZW50IG9yIGlmIG9uZSBvZiBpdHMgY2hpbGRyZW4gaXNcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGluaXRpYWxUYXJnZXQgPSBudWxsO1xuXG4gICAgdmFyIHNldERyb3BFZmZlY3QgPSBmdW5jdGlvbiBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgZWZmZWN0KSB7XG4gICAgICAgIC8vIGlzIGluIHRyeSBjYXRjaCBhcyBJRTExIHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGVmZmVjdDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9O1xuXG4gICAgdmFyIGRyYWdlbnRlciA9IGZ1bmN0aW9uIGRyYWdlbnRlcihyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGluaXRpYWxUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIG9uZW50ZXIgPSBjbGllbnQub25lbnRlcjtcblxuICAgICAgICAgICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBlbnRlciBldmVudFxuICAgICAgICAgICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ292ZXIgPSBmdW5jdGlvbiBkcmFnb3Zlcihyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBvdmVyRHJvcFRhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY2xpZW50cy5zb21lKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyRWxlbWVudCA9IGNsaWVudC5maWx0ZXJFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGNsaWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lbnRlciA9IGNsaWVudC5vbmVudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25leGl0ID0gY2xpZW50Lm9uZXhpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZHJhZyA9IGNsaWVudC5vbmRyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2Ryb3AgPSBjbGllbnQuYWxsb3dkcm9wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdjb3B5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdHJhbnNmZXIgb2YgdGhlc2UgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG93c1RyYW5zZmVyID0gYWxsb3dkcm9wKGl0ZW1zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBjYW4gYmUgZHJvcHBlZCBvbiBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0dGluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlckRyb3BUYXJnZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYWQgbm8gcHJldmlvdXMgc3RhdGUsIG1lYW5zIHdlIGFyZSBlbnRlcmluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBvdmVyIGVsZW1lbnQgKG5vIG1hdHRlciBpZiBpdCBhbGxvd3MgdGhlIGRyb3Agb3Igbm90KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ292ZXInO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBhbGxvdyB0cmFuc2ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgb25kcmFnKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG92ZXIgYW4gZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhb3ZlckRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBqdXN0IGxlZnQgdGhpcyBjbGllbnQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3Aocm9vdCwgY2xpZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgICAgICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gY2xpZW50LmZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmRyb3AgPSBjbGllbnQub25kcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25leGl0ID0gY2xpZW50Lm9uZXhpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZHJvcCA9IGNsaWVudC5hbGxvd2Ryb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBmaWx0ZXJpbmcgb24gZWxlbWVudCB3ZSBuZWVkIHRvIGJlIG92ZXIgdGhlIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHRyYW5zZmVyIGZvciB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZHJvcChpdGVtcykpIHJldHVybiBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGRyb3AgdGhlc2UgaXRlbXMgb24gdGhpcyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgb25kcm9wKGV2ZW50UG9zaXRpb24oZSksIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ2xlYXZlID0gZnVuY3Rpb24gZHJhZ2xlYXZlKHJvb3QsIGNsaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvbmV4aXQgPSBjbGllbnQub25leGl0O1xuXG4gICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSG9wcGVyID0gZnVuY3Rpb24gY3JlYXRlSG9wcGVyKHNjb3BlLCB2YWxpZGF0ZUl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGlzIG5vdyBob3BwZXIgc2NvcGVcbiAgICAgICAgc2NvcGUuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWhvcHBlcicpO1xuXG4gICAgICAgIC8vIHNob3J0Y3V0c1xuICAgICAgICB2YXIgY2F0Y2hlc0Ryb3BzT25QYWdlID0gb3B0aW9ucy5jYXRjaGVzRHJvcHNPblBhZ2UsXG4gICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQgPSBvcHRpb25zLnJlcXVpcmVzRHJvcE9uRWxlbWVudCxcbiAgICAgICAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID0gb3B0aW9ucy5maWx0ZXJJdGVtcyxcbiAgICAgICAgICAgIGZpbHRlckl0ZW1zID1cbiAgICAgICAgICAgICAgICBfb3B0aW9ucyRmaWx0ZXJJdGVtcyA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBfb3B0aW9ucyRmaWx0ZXJJdGVtcztcblxuICAgICAgICAvLyBjcmVhdGUgYSBkbmQgY2xpZW50XG4gICAgICAgIHZhciBjbGllbnQgPSBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGNhdGNoZXNEcm9wc09uUGFnZSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHNjb3BlLFxuICAgICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3VycmVudCBjbGllbnQgc3RhdGVcbiAgICAgICAgdmFyIGxhc3RTdGF0ZSA9ICcnO1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gJyc7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lcyBpZiBhIGZpbGUgbWF5IGJlIGRyb3BwZWRcbiAgICAgICAgY2xpZW50LmFsbG93ZHJvcCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBjYW4sIHRocm93IGVycm9yIHRvIGluZGljYXRlIHRoZSBpdGVtcyBjYW5ub3QgYnkgZHJvcHBlZFxuXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJdGVtcyhmaWx0ZXJJdGVtcyhpdGVtcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmRyb3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgaXRlbXMpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlSXRlbXMoZmlsdGVyZWRJdGVtcykpIHtcbiAgICAgICAgICAgICAgICBhcGkub25kcmFnZW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLWRyb3AnO1xuXG4gICAgICAgICAgICBhcGkub25sb2FkKGZpbHRlcmVkSXRlbXMsIHBvc2l0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQub25kcmFnID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGFwaS5vbmRyYWcocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmVudGVyID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLW92ZXInO1xuXG4gICAgICAgICAgICBhcGkub25kcmFnc3RhcnQocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmV4aXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZXhpdCc7XG5cbiAgICAgICAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG9wcGVyU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAhPT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRhdGFzZXQuaG9wcGVyU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZ3N0YXJ0OiBmdW5jdGlvbiBvbmRyYWdzdGFydCgpIHt9LFxuICAgICAgICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZ2VuZDogZnVuY3Rpb24gb25kcmFnZW5kKCkge30sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgY2xpZW50XG4gICAgICAgICAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIHZhciBsaXN0ZW5lcnMkMSA9IFtdO1xuXG4gICAgdmFyIGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSkge1xuICAgICAgICAvLyBpZiBpcyBwYXN0aW5nIGluIGlucHV0IG9yIHRleHRhcmVhIGFuZCB0aGUgdGFyZ2V0IGlzIG91dHNpZGUgb2YgYSBmaWxlcG9uZCBzY29wZSwgaWdub3JlXG4gICAgICAgIHZhciBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChhY3RpdmVFbCAmJiAvdGV4dGFyZWF8aW5wdXQvaS50ZXN0KGFjdGl2ZUVsLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgICAgICAgdmFyIGluU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gYWN0aXZlRWw7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZmlsZXBvbmQtLXJvb3QnKSkge1xuICAgICAgICAgICAgICAgICAgICBpblNjb3BlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW5TY29wZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGUuY2xpcGJvYXJkRGF0YSkudGhlbihmdW5jdGlvbihmaWxlcykge1xuICAgICAgICAgICAgLy8gbm8gZmlsZXMgcmVjZWl2ZWRcbiAgICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICAgICAgICBsaXN0ZW5lcnMkMS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGZpbGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihjYikge1xuICAgICAgICAvLyBjYW4ndCBhZGQgdHdpY2VcbiAgICAgICAgaWYgKGxpc3RlbmVycyQxLmluY2x1ZGVzKGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGluaXRpYWwgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXJzJDEucHVzaChjYik7XG5cbiAgICAgICAgLy8gc2V0dXAgcGFzdGUgbGlzdGVuZXIgZm9yIGVudGlyZSBwYWdlXG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgIH07XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgICBhcnJheVJlbW92ZShsaXN0ZW5lcnMkMSwgbGlzdGVuZXJzJDEuaW5kZXhPZihsaXN0ZW5lcikpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwXG4gICAgICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgICAgICAgICAgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhc3RlciA9IGZ1bmN0aW9uIGNyZWF0ZVBhc3RlcigpIHtcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoZmlsZXMpIHtcbiAgICAgICAgICAgIGFwaS5vbmxvYWQoZmlsZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbihjYik7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAgICovXG4gICAgdmFyIGNyZWF0ZSRkID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYXNzaXN0YW50LScgKyBwcm9wcy5pZDtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ3N0YXR1cycpO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLXJlbGV2YW50JywgJ2FkZGl0aW9ucycpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBmaWxlbmFtZXMgPSBbXTtcblxuICAgIHZhciBhc3Npc3QgPSBmdW5jdGlvbiBhc3Npc3Qocm9vdCwgbWVzc2FnZSkge1xuICAgICAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXIkMSA9IGZ1bmN0aW9uIGNsZWFyKHJvb3QpIHtcbiAgICAgICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfTtcblxuICAgIHZhciBsaXN0TW9kaWZpZWQgPSBmdW5jdGlvbiBsaXN0TW9kaWZpZWQocm9vdCwgZmlsZW5hbWUsIGxhYmVsKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgICAgICBhc3Npc3QoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFiZWwgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIHRvdGFsICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICh0b3RhbCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1NJTkdVTEFSJylcbiAgICAgICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9DT1VOVF9QTFVSQUwnKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjbGVhciBncm91cCBhZnRlciBzZXQgYW1vdW50IG9mIHRpbWUgc28gdGhlIHN0YXR1cyBpcyBub3QgcmVhZCB0d2ljZVxuICAgICAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0KTtcbiAgICAgICAgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyJDEocm9vdCk7XG4gICAgICAgIH0sIDE1MDApO1xuICAgIH07XG5cbiAgICB2YXIgaXNVc2luZ0ZpbGVQb25kID0gZnVuY3Rpb24gaXNVc2luZ0ZpbGVQb25kKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QuZWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbUFkZGVkID0gZnVuY3Rpb24gaXRlbUFkZGVkKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgZmlsZW5hbWVzLnB1c2goaXRlbS5maWxlbmFtZSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCk7XG4gICAgICAgIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsaXN0TW9kaWZpZWQocm9vdCwgZmlsZW5hbWVzLmpvaW4oJywgJyksIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0FEREVEJykpO1xuXG4gICAgICAgICAgICBmaWxlbmFtZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfSwgNzUwKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1SZW1vdmVkID0gZnVuY3Rpb24gaXRlbVJlbW92ZWQoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBhY3Rpb24uaXRlbTtcbiAgICAgICAgbGlzdE1vZGlmaWVkKHJvb3QsIGl0ZW0uZmlsZW5hbWUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1JFTU9WRUQnKSk7XG4gICAgfTtcblxuICAgIHZhciBpdGVtUHJvY2Vzc2VkID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZChfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIC8vIHdpbGwgYWxzbyBub3RpZnkgdGhlIHVzZXIgd2hlbiBGaWxlUG9uZCBpcyBub3QgYmVpbmcgdXNlZCwgYXMgdGhlIHVzZXIgbWlnaHQgYmUgb2NjdXBpZWQgd2l0aCBvdGhlciBhY3Rpdml0aWVzIHdoaWxlIHVwbG9hZGluZyBhIGZpbGVcblxuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19DT01QTEVURScpO1xuXG4gICAgICAgIGFzc2lzdChyb290LCBmaWxlbmFtZSArICcgJyArIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1Qcm9jZXNzZWRVbmRvID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZFVuZG8oX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjUuYWN0aW9uO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJyk7XG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGZpbGVuYW1lICsgJyAnICsgbGFiZWwpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbUVycm9yID0gZnVuY3Rpb24gaXRlbUVycm9yKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAgICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgICAgIGFzc2lzdChyb290LCBhY3Rpb24uc3RhdHVzLm1haW4gKyAnICcgKyBmaWxlbmFtZSArICcgJyArIGFjdGlvbi5zdGF0dXMuc3ViKTtcbiAgICB9O1xuXG4gICAgdmFyIGFzc2lzdGFudCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRkLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogaXRlbUFkZGVkLFxuICAgICAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBpdGVtUmVtb3ZlZCxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWQsXG5cbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuICAgICAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgfSksXG5cbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIG5hbWU6ICdhc3Npc3RhbnQnLFxuICAgIH0pO1xuXG4gICAgdmFyIHRvQ2FtZWxzID0gZnVuY3Rpb24gdG9DYW1lbHMoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICctJztcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoc2VwYXJhdG9yICsgJy4nLCAnZycpLCBmdW5jdGlvbihzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWIuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gICAgICAgIHZhciBpbW1pZGlhdGVPbmx5ID1cbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBEYXRlLm5vdygpIC0gbGFzdDtcblxuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBpbnRlcnZhbCBhbmQgZGlzdFxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGFuIGFkZGl0aW9uYWwgNm1zIGJlZm9yZSBjYWxsaW5nIHRoZSBmdW5jdGlvbilcbiAgICAgICAgICAgICAgICBpZiAoIWltbWlkaWF0ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGludGVydmFsIC0gZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyFcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgTUFYX0ZJTEVTX0xJTUlUID0gMTAwMDAwMDtcblxuICAgIHZhciBwcmV2ZW50ID0gZnVuY3Rpb24gcHJldmVudChlKSB7XG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBBZGQgaWRcbiAgICAgICAgdmFyIGlkID0gcm9vdC5xdWVyeSgnR0VUX0lEJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gaWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSByb290LnF1ZXJ5KCdHRVRfQ0xBU1NfTkFNRScpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmllbGQgbGFiZWxcbiAgICAgICAgcm9vdC5yZWYubGFiZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAgICAgICAgIGRyb3BMYWJlbCxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfSURMRScpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gTGlzdCBvZiBpdGVtc1xuICAgICAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhsaXN0U2Nyb2xsZXIsIHsgdHJhbnNsYXRlWTogbnVsbCB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJhY2tncm91bmQgcGFuZWxcbiAgICAgICAgcm9vdC5yZWYucGFuZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAncGFuZWwtcm9vdCcgfSkpO1xuXG4gICAgICAgIC8vIEFzc2lzdGFudCBub3RpZmllcyBhc3Npc3RpdmUgdGVjaCB3aGVuIGNvbnRlbnQgY2hhbmdlc1xuICAgICAgICByb290LnJlZi5hc3Npc3RhbnQgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGFzc2lzdGFudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgcm9vdC5yZWYuZGF0YSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpO1xuXG4gICAgICAgIC8vIE1lYXN1cmUgKHRlc3RzIGlmIGZpeGVkIGhlaWdodCB3YXMgc2V0KVxuICAgICAgICAvLyBET0NUWVBFIG5lZWRzIHRvIGJlIHNldCBmb3IgdGhpcyB0byB3b3JrXG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgICAgICByb290LnJlZi5tZWFzdXJlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLm1lYXN1cmUpO1xuXG4gICAgICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgICAgIHJvb3QucmVmLmJvdW5kcyA9IG51bGw7XG5cbiAgICAgICAgLy8gYXBwbHkgaW5pdGlhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHJvb3QucXVlcnkoJ0dFVF9TVFlMRVMnKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eShzdHlsZS52YWx1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHdpZHRoIGNoYW5nZWRcbiAgICAgICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCA9IGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFU0laRV9ST09UJyk7XG4gICAgICAgIH0sIDI1MCk7XG5cbiAgICAgICAgLy8gaGlzdG9yeSBvZiB1cGRhdGVzXG4gICAgICAgIHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8gPSBudWxsO1xuICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAgICAgLy8gcHJldmVudCBzY3JvbGxpbmcgYW5kIHpvb21pbmcgb24gaU9TIChvbmx5IGlmIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLCBmb3IgdGhlbiB3ZSBjYW4gZW5hYmxlIHJlb3JkZXIpXG4gICAgICAgIHZhciBjYW5Ib3ZlciA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogZmluZSkgYW5kIChob3ZlcjogaG92ZXIpJykubWF0Y2hlcztcbiAgICAgICAgdmFyIGhhc1BvaW50ZXJFdmVudHMgPSAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3c7XG4gICAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpICYmIGhhc1BvaW50ZXJFdmVudHMgJiYgIWNhbkhvdmVyKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlc3RhcnQnLCBwcmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjcmVkaXRzXG4gICAgICAgIHZhciBjcmVkaXRzID0gcm9vdC5xdWVyeSgnR0VUX0NSRURJVFMnKTtcbiAgICAgICAgdmFyIGhhc0NyZWRpdHMgPSBjcmVkaXRzLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKGhhc0NyZWRpdHMpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgZnJhZy5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWNyZWRpdHMnO1xuICAgICAgICAgICAgZnJhZy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgIGZyYWcuaHJlZiA9IGNyZWRpdHNbMF07XG4gICAgICAgICAgICBmcmFnLnRhYmluZGV4ID0gLTE7XG4gICAgICAgICAgICBmcmFnLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgZnJhZy5yZWwgPSAnbm9vcGVuZXIgbm9yZWZlcnJlcic7XG4gICAgICAgICAgICBmcmFnLnRleHRDb250ZW50ID0gY3JlZGl0c1sxXTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmNyZWRpdHMgPSBmcmFnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ5ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmMy5hY3Rpb25zO1xuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIHJvdXRlJDUoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF9TRVRfU1RZTEVfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eShhY3Rpb24uZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9yZWY0LmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b0NhbWVscyh0eXBlLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpLCAnXycpO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0W25hbWVdID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICByb290LmludmFsaWRhdGVMYXlvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290LnJlY3QuZWxlbWVudC5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGJveCBib3VuZHMsIHdlIGRvIHRoaXMgb25seSBvbmNlXG4gICAgICAgIHZhciBib3VuZHMgPSByb290LnJlZi5ib3VuZHM7XG4gICAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgICAgICBib3VuZHMgPSByb290LnJlZi5ib3VuZHMgPSBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCk7XG5cbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgbWVhc3VyZSBlbGVtZW50XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG4gICAgICAgICAgICByb290LnJlZi5tZWFzdXJlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICAgICAgdmFyIF9yb290JHJlZiA9IHJvb3QucmVmLFxuICAgICAgICAgICAgaG9wcGVyID0gX3Jvb3QkcmVmLmhvcHBlcixcbiAgICAgICAgICAgIGxhYmVsID0gX3Jvb3QkcmVmLmxhYmVsLFxuICAgICAgICAgICAgbGlzdCA9IF9yb290JHJlZi5saXN0LFxuICAgICAgICAgICAgcGFuZWwgPSBfcm9vdCRyZWYucGFuZWw7XG5cbiAgICAgICAgLy8gc2V0cyBjb3JyZWN0IHN0YXRlIHRvIGhvcHBlciBzY29wZVxuICAgICAgICBpZiAoaG9wcGVyKSB7XG4gICAgICAgICAgICBob3BwZXIudXBkYXRlSG9wcGVyU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJvb2wgdG8gaW5kaWNhdGUgaWYgd2UncmUgZnVsbCBvciBub3RcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICB2YXIgaXNNdWx0aUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gaXNNdWx0aUl0ZW0gPyByb290LnF1ZXJ5KCdHRVRfTUFYX0ZJTEVTJykgfHwgTUFYX0ZJTEVTX0xJTUlUIDogMTtcbiAgICAgICAgdmFyIGF0TWF4Q2FwYWNpdHkgPSB0b3RhbEl0ZW1zID09PSBtYXhJdGVtcztcblxuICAgICAgICAvLyBhY3Rpb24gdXNlZCB0byBhZGQgaXRlbVxuICAgICAgICB2YXIgYWRkQWN0aW9uID0gYWN0aW9ucy5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnRElEX0FERF9JVEVNJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgcmVhY2hlZCBtYXggY2FwYWNpdHkgYW5kIHdlJ3ZlIGp1c3QgcmVhY2hlZCBpdFxuICAgICAgICBpZiAoYXRNYXhDYXBhY2l0eSAmJiBhZGRBY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0eXBlXG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb25NZXRob2QgPSBhZGRBY3Rpb24uZGF0YS5pbnRlcmFjdGlvbk1ldGhvZDtcblxuICAgICAgICAgICAgLy8gaGlkZSBsYWJlbFxuICAgICAgICAgICAgbGFiZWwub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpc011bHRpSXRlbSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDQwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAzMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0TWF4Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgIGxhYmVsLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0SXRlbU1hcmdpbiA9IGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpO1xuXG4gICAgICAgIHZhciBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSBsYWJlbC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB2YXIgY3VycmVudExhYmVsSGVpZ2h0ID0gIWlzTXVsdGlJdGVtIHx8IGF0TWF4Q2FwYWNpdHkgPyAwIDogbGFiZWxIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICAgICAgdmFyIGxpc3RNYXJnaW5Cb3R0b20gPSB0b3RhbEl0ZW1zID09PSAwID8gMCA6IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcblxuICAgICAgICB2YXIgdmlzdWFsSGVpZ2h0ID1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LnZpc3VhbCArIGxpc3RNYXJnaW5Cb3R0b207XG4gICAgICAgIHZhciBib3VuZHNIZWlnaHQgPVxuICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQuYm91bmRzICsgbGlzdE1hcmdpbkJvdHRvbTtcblxuICAgICAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgICAgIGxpc3QudHJhbnNsYXRlWSA9XG4gICAgICAgICAgICBNYXRoLm1heCgwLCBjdXJyZW50TGFiZWxIZWlnaHQgLSBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3ApIC0gbGlzdEl0ZW1NYXJnaW4udG9wO1xuXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgLy8gZml4ZWQgYXNwZWN0IHJhdGlvXG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBoZWlnaHQgYmFzZWQgb24gd2lkdGhcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGhpc3RvcnkgaWYgYXNwZWN0IHJhdGlvIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8gIT09IHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGlzIHdpZHRoXG4gICAgICAgICAgICB2YXIgaGlzdG9yeSA9IHJvb3QucmVmLnVwZGF0ZUhpc3Rvcnk7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2god2lkdGgpO1xuXG4gICAgICAgICAgICB2YXIgTUFYX0JPVU5DRVMgPSAyO1xuICAgICAgICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID4gTUFYX0JPVU5DRVMgKiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBoaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gbCAtIDEwO1xuICAgICAgICAgICAgICAgIHZhciBib3VuY2VzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbDsgaSA+PSBib3R0b207IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeVtpXSA9PT0gaGlzdG9yeVtpIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5jZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuY2VzID49IE1BWF9CT1VOQ0VTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb250IGFkanVzdCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbCBzbyBpdCBhZGhlcmVzIHRvIGFzcGVjdCByYXRpb1xuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhbmVsLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICAgICAgdmFyIGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgICAgICBoZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgICAgICByb290LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZHMuZml4ZWRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGZpeGVkIGhlaWdodFxuXG4gICAgICAgICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsXG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgICAgICB2YXIgX2xpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0XG4gICAgICAgICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBfbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IGNvbnRhaW5lciBib3VuZHMgYXMgdGhlc2UgYXJlIGhhbmRsZXMgYnkgQ1NTIGZpeGVkIGhlaWdodFxuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIG1heC1oZWlnaHRcblxuICAgICAgICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICAgICAgICB2YXIgaXNDYXBwZWRIZWlnaHQgPSB2aXN1YWxIZWlnaHQgPj0gYm91bmRzLmNhcHBlZEhlaWdodDtcbiAgICAgICAgICAgIHZhciBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBwYW5lbC5oZWlnaHQgPSBpc0NhcHBlZEhlaWdodFxuICAgICAgICAgICAgICAgID8gcGFuZWxIZWlnaHRcbiAgICAgICAgICAgICAgICA6IHBhbmVsSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgICAgICB2YXIgX2xpc3RBdmFpbGFibGVIZWlnaHQyID1cbiAgICAgICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgcGFuZWxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0IChpZiBpcyBvdmVyZmxvd2luZylcbiAgICAgICAgICAgIGlmICh2aXN1YWxIZWlnaHQgPiBib3VuZHMuY2FwcGVkSGVpZ2h0ICYmIGxpc3RIZWlnaHQudmlzdWFsID4gX2xpc3RBdmFpbGFibGVIZWlnaHQyKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IF9saXN0QXZhaWxhYmxlSGVpZ2h0MjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBib3VuZHMuY2FwcGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdW5kc0hlaWdodCAtIGxpc3RJdGVtTWFyZ2luLnRvcCAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAgICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgICAgICAgIHZhciBpdGVtTWFyZ2luID0gdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIHZpc3VhbEhlaWdodCAtIGl0ZW1NYXJnaW4pO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIGJvdW5kc0hlaWdodCAtIGl0ZW1NYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSBjcmVkaXRzIHRvIGJvdHRvbVxuICAgICAgICBpZiAocm9vdC5yZWYuY3JlZGl0cyAmJiBwYW5lbC5oZWlnaHRDdXJyZW50KVxuICAgICAgICAgICAgcm9vdC5yZWYuY3JlZGl0cy5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgnICsgcGFuZWwuaGVpZ2h0Q3VycmVudCArICdweCknO1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4gPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KSB7XG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdLmNoaWxkVmlld3NbMF07XG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHRvcDogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlTGlzdEhlaWdodCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxpc3RIZWlnaHQocm9vdCkge1xuICAgICAgICB2YXIgdmlzdWFsID0gMDtcbiAgICAgICAgdmFyIGJvdW5kcyA9IDA7XG5cbiAgICAgICAgLy8gZ2V0IGZpbGUgbGlzdCByZWZlcmVuY2VcbiAgICAgICAgdmFyIHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgICAgICB2YXIgaXRlbUxpc3QgPSBzY3JvbGxMaXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSBpdGVtTGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuLCBkb25lIVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcblxuICAgICAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gaXRlbUxpc3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICB2YXIgZHJhZ0luZGV4ID0gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihpdGVtTGlzdCwgY2hpbGRyZW4sIHNjcm9sbExpc3QuZHJhZ0Nvb3JkaW5hdGVzKTtcblxuICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuXG4gICAgICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpbkxlZnQgKyBjaGlsZFJlY3QubWFyZ2luUmlnaHQ7XG5cbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICAgICAgdmFyIG5ld0l0ZW0gPSB0eXBlb2YgZHJhZ0luZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBkcmFnSW5kZXggPj0gMCA/IDEgOiAwO1xuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW0gPSBjaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgdmFyIHZlcnRpY2FsSXRlbUNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoICsgbmV3SXRlbSArIHJlbW92ZWRJdGVtO1xuICAgICAgICB2YXIgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAgICAgLy8gc3RhY2tcbiAgICAgICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJvdW5kcyArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlzdWFsICs9IGhlaWdodCAqIGl0ZW0ub3BhY2l0eTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyaWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3VuZHMgPSBNYXRoLmNlaWwodmVydGljYWxJdGVtQ291bnQgLyBpdGVtc1BlclJvdykgKiBpdGVtSGVpZ2h0O1xuICAgICAgICAgICAgdmlzdWFsID0gYm91bmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmlzdWFsOiB2aXN1YWwsIGJvdW5kczogYm91bmRzIH07XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZUhlaWdodCB8fCBudWxsO1xuICAgICAgICB2YXIgY2FwcGVkSGVpZ2h0ID0gcGFyc2VJbnQocm9vdC5zdHlsZS5tYXhIZWlnaHQsIDEwKSB8fCBudWxsO1xuICAgICAgICB2YXIgZml4ZWRIZWlnaHQgPSBoZWlnaHQgPT09IDAgPyBudWxsIDogaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYXBwZWRIZWlnaHQ6IGNhcHBlZEhlaWdodCxcbiAgICAgICAgICAgIGZpeGVkSGVpZ2h0OiBmaXhlZEhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGV4Y2VlZHNNYXhGaWxlcyA9IGZ1bmN0aW9uIGV4Y2VlZHNNYXhGaWxlcyhyb290LCBpdGVtcykge1xuICAgICAgICB2YXIgYWxsb3dSZXBsYWNlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFUExBQ0UnKTtcbiAgICAgICAgdmFyIGFsbG93TXVsdGlwbGUgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgICAgIC8vIHRvdGFsIGFtb3VudCBvZiBpdGVtcyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHZhciB0b3RhbEJyb3dzZUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGlmIGRvZXMgbm90IGFsbG93IG11bHRpcGxlIGl0ZW1zIGFuZCBkcmFnZ2luZyBtb3JlIHRoYW4gb25lIGl0ZW1cbiAgICAgICAgaWYgKCFhbGxvd011bHRpcGxlICYmIHRvdGFsQnJvd3NlSXRlbXMgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgICAgICBtYXhJdGVtcyA9IGFsbG93TXVsdGlwbGUgPyBtYXhJdGVtcyA6IGFsbG93UmVwbGFjZSA/IG1heEl0ZW1zIDogMTtcblxuICAgICAgICAvLyBubyBtb3JlIHJvb20/XG4gICAgICAgIHZhciBoYXNNYXhJdGVtcyA9IGlzSW50KG1heEl0ZW1zKTtcbiAgICAgICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBnZXREcmFnSW5kZXggPSBmdW5jdGlvbiBnZXREcmFnSW5kZXgobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpdGVtTGlzdCA9IGxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgcmV0dXJuIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCB7XG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5zY29wZUxlZnQgLSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgICAgIHRvcDpcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgKyBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyBsaXN0LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsZSBkcm9wIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICB2YXIgdG9nZ2xlRHJvcCA9IGZ1bmN0aW9uIHRvZ2dsZURyb3Aocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgICAgIHZhciBob3BwZXIgPSBjcmVhdGVIb3BwZXIoXG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHF1aWNrIHZhbGlkYXRpb24gb2YgZHJvcHBlZCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlRHJvcEZpbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBzaG91bGQgYmUgdmFsaWRhdGVkIGJ5IGFsbCBmaWx0ZXJzIGFzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wVmFsaWRhdGlvbiA9IHJvb3QucXVlcnkoJ0dFVF9EUk9QX1ZBTElEQVRJT04nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BWYWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdBTExPV19IT1BQRVJfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHJvb3QucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZXZlcnkoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgJiYgYmVmb3JlRHJvcEZpbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJJdGVtcyhpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudDogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fRUxFTUVOVCcpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcywgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgaXRlbSBjaGlsZHJlbiBlbGVtZW50cyBhbmQgc29ydCBiYXNlZCBvbiBsaXN0IHNvcnRcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgcXVldWVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXREcmFnSW5kZXgocm9vdC5yZWYubGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1NUQVJUX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWcgPSBkZWJvdW5jZShmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaG9wcGVyLm9uZHJhZ2VuZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgICAgICAgIHJvb3QucmVmLmRyaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkcmlwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGJyb3dzZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZUJyb3dzZSA9IGZ1bmN0aW9uIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcykge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICAgICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlcixcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuYnJvd3Nlcik7XG4gICAgICAgICAgICByb290LnJlZi5icm93c2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZVBhc3RlID0gZnVuY3Rpb24gdG9nZ2xlUGFzdGUocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BBU1RFJyk7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgICAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBjcmVhdGVQYXN0ZXIoKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3Rlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXMhXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm91dGUgYWN0aW9uc1xuICAgICAqL1xuICAgIHZhciByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19CUk9XU0UoX3JlZjUpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9BTExPV19EUk9QOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX0RST1AoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfQUxMT1dfUEFTVEU6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfUEFTVEUoX3JlZjcpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgICB9LFxuICAgICAgICBESURfU0VUX0RJU0FCTEVEOiBmdW5jdGlvbiBESURfU0VUX0RJU0FCTEVEKF9yZWY4KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmOC5wcm9wcztcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgICAgICB0b2dnbGVQYXN0ZShyb290KTtcbiAgICAgICAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZDsgPD0gdGhpcyBkb2VzIG5vdCB3b3JrIG9uIGlPUyAxMFxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciByb290ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ5LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCddLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlcyB0aGUgYXBwXG4gICAgdmFyIGNyZWF0ZUFwcCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgLy8gbGV0IGVsZW1lbnRcbiAgICAgICAgdmFyIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgICAgICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgICAgICAgIGNyZWF0ZUluaXRpYWxTdGF0ZShkZWZhdWx0T3B0aW9ucyksXG5cbiAgICAgICAgICAgIC8vIHF1ZXJpZXNcbiAgICAgICAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgICAgICAgIC8vIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgICAgICAgW2FjdGlvbnMsIGNyZWF0ZU9wdGlvbkFjdGlvbnMoZGVmYXVsdE9wdGlvbnMpXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zOiBpbml0aWFsT3B0aW9ucyB9KTtcblxuICAgICAgICAvLyBraWNrIHRocmVhZCBpZiB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgICAgICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSByZXR1cm47XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICAgICAgdmFyIHJlc2l6ZURvbmVUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgIHZhciBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplRG9uZVRpbWVyKTtcbiAgICAgICAgICAgIHJlc2l6ZURvbmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNpemluZ0hvcml6b250YWxseSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgLy8gcmVuZGVyIGluaXRpYWwgdmlld1xuICAgICAgICB2YXIgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUFJJVkFURSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgIHZhciByZWFkV3JpdGVBcGkgPSB7XG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVhZHMgZnJvbSBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVhZDogZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZXNpemluZyBob3Jpem9udGFsbHlcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1dpZHRoID0gY3VycmVudFdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ICYmIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUQVJUX1JFU0laRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaXNSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3LmVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyByZWFkIHZpZXcgZGF0YVxuICAgICAgICAgICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGlzIGhpZGRlbiB3ZSBuZWVkIHRvIGtub3cgc28gd2UgZXhpdCByZXN0IG1vZGUgd2hlbiByZXZlYWxlZFxuICAgICAgICAgICAgICAgIGlzSGlkZGVuID0gdmlldy5yZWN0LmVsZW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZXMgdG8gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3dyaXRlOiBmdW5jdGlvbiBfd3JpdGUodHMpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGFjdGlvbnMgZnJvbSBzdG9yZVxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25zID0gc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLnByb2Nlc3NBY3Rpb25RdWV1ZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhL15TRVRfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgaWRsaW5nIGFuZCBubyBhY3Rpb25zIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcgJiYgIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgICAgICByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2xlYW4gdXAgYWxsIGFyY2hpdmVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVsZWFzZWRJdGVtcyhzdG9yZS5xdWVyeSgnR0VUX0lURU1TJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHJvY2Vzc0Rpc3BhdGNoUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZXJyb3IpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQub3V0cHV0ID0gZGF0YS5maWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gZGF0YS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLml0ZW0gfHwgZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1hcCBhbGwgaXRlbXMgaW4gYSBwb3NzaWJsZSBpdGVtcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lml0ZW1zID0gZGF0YS5pdGVtcy5tYXAoY3JlYXRlSXRlbUFQSSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgICAgICAgICAgaWYgKC9wcm9ncmVzcy8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZGF0YS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRSb3V0ZXMgPSB7XG4gICAgICAgICAgICBESURfREVTVFJPWTogY3JlYXRlRXZlbnQoJ2Rlc3Ryb3knKSxcblxuICAgICAgICAgICAgRElEX0lOSVQ6IGNyZWF0ZUV2ZW50KCdpbml0JyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19NQVhfRklMRVM6IGNyZWF0ZUV2ZW50KCd3YXJuaW5nJyksXG5cbiAgICAgICAgICAgIERJRF9JTklUX0lURU06IGNyZWF0ZUV2ZW50KCdpbml0ZmlsZScpLFxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogY3JlYXRlRXZlbnQoJ2FkZGZpbGVzdGFydCcpLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpXSxcblxuICAgICAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBjcmVhdGVFdmVudCgncHJlcGFyZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlc3RhcnQnKSxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVwcm9ncmVzcycpLFxuICAgICAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlYWJvcnQnKSxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEw6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXMnKSxcbiAgICAgICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVyZXZlcnQnKSxcblxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9SRU1PVkVfSVRFTTogY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNUzogY3JlYXRlRXZlbnQoJ3VwZGF0ZWZpbGVzJyksXG5cbiAgICAgICAgICAgIERJRF9BQ1RJVkFURV9JVEVNOiBjcmVhdGVFdmVudCgnYWN0aXZhdGVmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9SRU9SREVSX0lURU1TOiBjcmVhdGVFdmVudCgncmVvcmRlcmZpbGVzJyksXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cG9zZUV2ZW50ID0gZnVuY3Rpb24gZXhwb3NlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBldmVudCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBwb25kOiBleHBvcnRzIH0sIGV2ZW50KTtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXRhaWwudHlwZTtcbiAgICAgICAgICAgIHZpZXcuZWxlbWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6JyArIGV2ZW50LnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgaW5mb1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBiZWhhdmlvdXJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zZWQ6IHRydWUsIC8vIHRyaWdnZXJzIGxpc3RlbmVycyBvdXRzaWRlIG9mIHNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IG9iamVjdCB0byBwYXJhbXMgdXNlZCBmb3IgYG9uKClgIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgYG9uaW5pdCgpYFxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBpZiBpcyBwb3NzaWJsZSBlcnJvciBldmVudCwgbWFrZSBpdCB0aGUgZmlyc3QgcGFyYW1cbiAgICAgICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChldmVudC5maWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwZW5kIG90aGVyIHByb3BzXG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbJ3R5cGUnLCAnZXJyb3InLCAnZmlsZSddO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXJlZC5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucHVzaChldmVudFtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgICAgICAgZXhwb3J0cy5maXJlLmFwcGx5KGV4cG9ydHMsIFtldmVudC50eXBlXS5jb25jYXQocGFyYW1zKSk7XG5cbiAgICAgICAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHN0b3JlLnF1ZXJ5KCdHRVRfT04nICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvdXRlQWN0aW9uc1RvRXZlbnRzID0gZnVuY3Rpb24gcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IFtyb3V0ZXNdKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRElEX0lOSVRfSVRFTScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBQVUJMSUMgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGUgPSBmdW5jdGlvbiBwcmVwYXJlRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJFUEFSRScsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZSA9IGZ1bmN0aW9uIGFkZEZpbGUoc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgYWRkRmlsZXMoW3sgc291cmNlOiBzb3VyY2UsIG9wdGlvbnM6IG9wdGlvbnMgfV0sIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNGaWxlUG9uZEZpbGUgPSBmdW5jdGlvbiBpc0ZpbGVQb25kRmlsZShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsZSAmJiBvYmouaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGUgPSBmdW5jdGlvbiByZW1vdmVGaWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiAhaXNGaWxlUG9uZEZpbGUocXVlcnkpICYmICFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBxdWVyeTogcXVlcnkgfSkpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KSA9PT0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZXMgPSBmdW5jdGlvbiBhZGRGaWxlcygpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgYSBzb3VyY2VzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIHNvdXJjZXMgYXMgYXJndW1lbnRzLCBsYXN0IG9uZSBtaWdodCBiZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEFyZ3VtZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgIShsYXN0QXJndW1lbnQgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCByZXN0IHRvIHNvdXJjZXNcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkFQSSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0ZpbGUgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGVzID0gZnVuY3Rpb24gcHJlcGFyZUZpbGVzKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgICAgICAgICAgX2tleTIrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBxdWVyaWVzLmxlbmd0aCA/IHF1ZXJpZXMgOiBnZXRGaWxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChwcmVwYXJlRmlsZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzRmlsZXMgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTMgPCBfbGVuMztcbiAgICAgICAgICAgICAgICBfa2V5MysrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBnZXRGaWxlcygpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLklETEUgJiYgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXJpZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGVzID0gZnVuY3Rpb24gcmVtb3ZlRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTQgPCBfbGVuNDtcbiAgICAgICAgICAgICAgICBfa2V5NCsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcmllc1txdWVyaWVzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyaWVzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGdldEZpbGVzKCk7XG5cbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgICAgICBmaWxlcy5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgICAgICAgIHZhciBtYXBwZWRRdWVyaWVzID0gcXVlcmllc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHF1ZXJ5KSA/IChmaWxlc1txdWVyeV0gPyBmaWxlc1txdWVyeV0uaWQgOiBudWxsKSA6IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXBwZWRRdWVyaWVzLm1hcChmdW5jdGlvbihxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUocSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgb24oKSxcbiAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICByZWFkV3JpdGVBcGksXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT3ZlcnJpZGUgb3B0aW9ucyBkZWZpbmVkIGluIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIG9mIHRoZSBmaWxlIChlaXRoZXIgYSBGaWxlLCBiYXNlNjQgZGF0YSB1cmkgb3IgdXJsKVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhZGRGaWxlOiBhZGRGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZXNcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlcyAtIHRoZSBzb3VyY2VzIG9mIHRoZSBmaWxlcyB0byBsb2FkXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZEZpbGVzOiBhZGRGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGZpbGUgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZTogZ2V0RmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpbGU6IHByb2Nlc3NGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlOiBwcmVwYXJlRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBmaWxlIGJ5IGl0cyBuYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVGaWxlOiByZW1vdmVGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbW92ZUZpbGU6IGZ1bmN0aW9uIG1vdmVGaWxlKHF1ZXJ5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHF1ZXJ5LCBpbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYWxsIGZpbGVzICh3cmFwcGVkIGluIHB1YmxpYyBhcGkpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZXM6IGdldEZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RhcnRzIHVwbG9hZGluZyBhbGwgZmlsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcm9jZXNzRmlsZXM6IHByb2Nlc3NGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbW92ZUZpbGVzOiByZW1vdmVGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0YXJ0cyBwcmVwYXJpbmcgb3V0cHV0IG9mIGFsbCBmaWxlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlczogcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU29ydCBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU09SVCcsIHsgY29tcGFyZTogY29tcGFyZSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQnJvd3NlIHRoZSBmaWxlIHN5c3RlbSBmb3IgYSBmaWxlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnJvd3NlOiBmdW5jdGlvbiBicm93c2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIHRyaWdnZXIgZGlyZWN0bHkgYXMgdXNlciBhY3Rpb24gbmVlZHMgdG8gYmUgdHJhY2VhYmxlIChpcyBub3QgdHJhY2VhYmxlIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERlc3Ryb3lzIHRoZSBhcHBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGRlc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuZmlyZSgnZGVzdHJveScsIHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGl0ZW1zIGFuZCBkZXBlbmRpbmcgb24gc3RhdGVzIGNhbGwgYWJvcnQgZm9yIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBQk9SVF9BTEwnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlIHZpc2libGl0eWNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9ERVNUUk9ZJyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBiZWZvcmUgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUkMShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbiBpbnNlcnRBZnRlciQxKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEFmdGVyKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFwcGVuZHMgdGhlIHBsdWdpbiB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hcHBlbmRDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXBsYWNlcyBhbiBlbGVtZW50IHdpdGggdGhlIGFwcFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcGxhY2VFbGVtZW50OiBmdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgYXBwIGJlZm9yZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXN0b3JlRWxlbWVudDogZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGVsZW1lbnQgdG8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEFmdGVyKG9yaWdpbmFsRWxlbWVudCwgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3VyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmlldy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHJvb3QgaXMgYXR0YWNoZWQgdG8gZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXNBdHRhY2hlZFRvOiBmdW5jdGlvbiBpc0F0dGFjaGVkVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50ID09PSBlbGVtZW50IHx8IG9yaWdpbmFsRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERvbmUhXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfSU5JVCcpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4cG9ydHMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXBwT2JqZWN0ID0gZnVuY3Rpb24gY3JlYXRlQXBwT2JqZWN0KCkge1xuICAgICAgICB2YXIgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldID0gdmFsdWVbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCBhcHAgb3B0aW9uc1xuICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgY3VzdG9tT3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfTtcblxuICAgIHZhciBsb3dlckNhc2VGaXJzdExldHRlciA9IGZ1bmN0aW9uIGxvd2VyQ2FzZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICB2YXIgYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQ2FtZWxzKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXmRhdGEtLywgJycpKTtcbiAgICB9O1xuXG4gICAgdmFyIG1hcE9iamVjdCA9IGZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIHByb3BlcnR5TWFwKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgICAgICBmb3Jpbihwcm9wZXJ0eU1hcCwgZnVuY3Rpb24oc2VsZWN0b3IsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGZvcmluKG9iamVjdCwgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclJlZ0V4cCA9IG5ldyBSZWdFeHAoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdHMgaWZcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2gsIHNraXBcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBtYXBwaW5nLCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgaXMgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IHJlbW92ZSwgd2UgZG9uZSFcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdmFsdWUgdG8gbmV3IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFttYXBwaW5nXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBncm91cFxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcHBpbmcpICYmICFvYmplY3RbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtncm91cF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdW2xvd2VyQ2FzZUZpcnN0TGV0dGVyKHByb3BlcnR5LnJlcGxhY2Uoc2VsZWN0b3JSZWdFeHAsICcnKSldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICAgICAgICAgIG1hcE9iamVjdChvYmplY3RbbWFwcGluZy5ncm91cF0sIG1hcHBpbmcubWFwcGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXR0cmlidXRlc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KG5vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU1hcHBpbmcgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvcmluKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChub2RlLmF0dHJpYnV0ZXNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyKG5vZGUsIGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgIG9ialthdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBhdHRyaWJ1dGUubmFtZSA/IHRydWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgIC8vIGRvIG1hcHBpbmcgb2Ygb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFwcEF0RWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcEF0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIG90aGVyIG5hbWVcbiAgICAgICAgICAgICdeY2xhc3MkJzogJ2NsYXNzTmFtZScsXG4gICAgICAgICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICAgICAgICdeY2FwdHVyZSQnOiAnY2FwdHVyZU1ldGhvZCcsXG4gICAgICAgICAgICAnXndlYmtpdGRpcmVjdG9yeSQnOiAnYWxsb3dEaXJlY3Rvcmllc09ubHknLFxuXG4gICAgICAgICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICAgICAgICdec2VydmVyJzoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnc2VydmVyJyxcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3JldmVydCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15mZXRjaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBpbiBvYmplY3RcbiAgICAgICAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICAgICAgICdeZmlsZXMkJzogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgICAgIGFwcGx5RmlsdGVycygnU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbmFsIG9wdGlvbnMgb2JqZWN0IGJ5IHNldHRpbmcgb3B0aW9ucyBvYmplY3QgYW5kIHRoZW4gb3ZlcnJpZGluZyBvcHRpb25zIHN1cHBsaWVkIG9uIGVsZW1lbnRcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgICAgICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdGSUVMRFNFVCcgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKSA6IGVsZW1lbnQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVNYXBwaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGF0dHJpYnV0ZU9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlZE9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVyZ2VkT3B0aW9uc1trZXldLCBhdHRyaWJ1dGVPcHRpb25zW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBhdHRyaWJ1dGVPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgICAgICAvLyB0aGVzZSB3aWxsIHRoZW4gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGluaXRpYWwgZmlsZXNcbiAgICAgICAgbWVyZ2VkT3B0aW9ucy5maWxlcyA9IChvcHRpb25zLmZpbGVzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPWZpbGVdKScpKS5tYXAoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYnVpbGQgcGx1Z2luXG4gICAgICAgIHZhciBhcHAgPSBjcmVhdGVBcHBPYmplY3QobWVyZ2VkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICAgICAgaWYgKGVsZW1lbnQuZmlsZXMpIHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5maWxlcykuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgYXBwLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGFwcC5yZXBsYWNlRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9O1xuXG4gICAgLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuICAgIHZhciBjcmVhdGVBcHAkMSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pXG4gICAgICAgICAgICA/IGNyZWF0ZUFwcEF0RWxlbWVudC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogY3JlYXRlQXBwT2JqZWN0LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIFBSSVZBVEVfTUVUSE9EUyA9IFsnZmlyZScsICdfcmVhZCcsICdfd3JpdGUnXTtcblxuICAgIHZhciBjcmVhdGVBcHBBUEkgPSBmdW5jdGlvbiBjcmVhdGVBcHBBUEkoYXBwKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcblxuICAgICAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBpbiBnaXZlbiBzdHJpbmcgd2l0aCByZXBsYWNlbWVudHNcbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gICAgICogQHBhcmFtIHJlcGxhY2VtZW50cyAtIHsgXCJiYXJcIjogMTAgfVxuICAgICAqL1xuICAgIHZhciByZXBsYWNlSW5TdHJpbmcgPSBmdW5jdGlvbiByZXBsYWNlSW5TdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oPzp7KFthLXpBLVpdKyl9KS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudHNbZ3JvdXBdO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgICAgICB2YXIgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmZXI6IGZ1bmN0aW9uIHRyYW5zZmVyKG1lc3NhZ2UsIGNiKSB7fSxcbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckxpc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gdGVybWluYXRlKCkge1xuICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmFtZUZpbGUgPSBmdW5jdGlvbiByZW5hbWVGaWxlKGZpbGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlbmFtZWRGaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIGZpbGUudHlwZSk7XG4gICAgICAgIHJlbmFtZWRGaWxlLmxhc3RNb2RpZmllZERhdGUgPSBmaWxlLmxhc3RNb2RpZmllZERhdGU7XG4gICAgICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gcmVuYW1lZEZpbGU7XG4gICAgfTtcblxuICAgIHZhciBjb3B5RmlsZSA9IGZ1bmN0aW9uIGNvcHlGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoZmlsZSwgZmlsZS5uYW1lKTtcbiAgICB9O1xuXG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkIHBsdWdpbnMgKGNhbid0IHJlZ2lzdGVyIHR3aWNlKVxuICAgIHZhciByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4gICAgLy8gcGFzcyB1dGlscyB0byBwbHVnaW5cbiAgICB2YXIgY3JlYXRlQXBwUGx1Z2luID0gZnVuY3Rpb24gY3JlYXRlQXBwUGx1Z2luKHBsdWdpbikge1xuICAgICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbWVtYmVyIHRoaXMgcGx1Z2luXG4gICAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgICAgICAvLyBzZXR1cCFcbiAgICAgICAgdmFyIHBsdWdpbk91dGxpbmUgPSBwbHVnaW4oe1xuICAgICAgICAgICAgYWRkRmlsdGVyOiBhZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgICAgIFR5cGU6IFR5cGUsXG4gICAgICAgICAgICAgICAgZm9yaW46IGZvcmluLFxuICAgICAgICAgICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZTogdG9OYXR1cmFsRmlsZVNpemUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nOiByZXBsYWNlSW5TdHJpbmcsXG4gICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lOiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZTogZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgICAgICAgICBnZXRGaWxlRnJvbUJsb2I6IGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkw6IGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgICAgICAgICBjcmVhdGVSb3V0ZTogY3JlYXRlUm91dGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlV29ya2VyOiBjcmVhdGVXb3JrZXIsXG4gICAgICAgICAgICAgICAgY3JlYXRlVmlldzogY3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtQVBJOiBjcmVhdGVJdGVtQVBJLFxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZTogbG9hZEltYWdlLFxuICAgICAgICAgICAgICAgIGNvcHlGaWxlOiBjb3B5RmlsZSxcbiAgICAgICAgICAgICAgICByZW5hbWVGaWxlOiByZW5hbWVGaWxlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUJsb2I6IGNyZWF0ZUJsb2IsXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbjogYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmc6IGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgIGZpbGVBY3Rpb25CdXR0b246IGZpbGVBY3Rpb25CdXR0b24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgcGx1Z2luIG9wdGlvbnMgdG8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGV4dGVuZERlZmF1bHRPcHRpb25zKHBsdWdpbk91dGxpbmUub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgc3VwcG9ydGVkKCkgbWV0aG9kXG4gICAgdmFyIGlzT3BlcmFNaW5pID0gZnVuY3Rpb24gaXNPcGVyYU1pbmkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93Lm9wZXJhbWluaSkgPT09ICdbb2JqZWN0IE9wZXJhTWluaV0nO1xuICAgIH07XG4gICAgdmFyIGhhc1Byb21pc2VzID0gZnVuY3Rpb24gaGFzUHJvbWlzZXMoKSB7XG4gICAgICAgIHJldHVybiAnUHJvbWlzZScgaW4gd2luZG93O1xuICAgIH07XG4gICAgdmFyIGhhc0Jsb2JTbGljZSA9IGZ1bmN0aW9uIGhhc0Jsb2JTbGljZSgpIHtcbiAgICAgICAgcmV0dXJuICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG4gICAgfTtcbiAgICB2YXIgaGFzQ3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gaGFzQ3JlYXRlT2JqZWN0VVJMKCkge1xuICAgICAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG4gICAgfTtcbiAgICB2YXIgaGFzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIGhhc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIHJldHVybiAndmlzaWJpbGl0eVN0YXRlJyBpbiBkb2N1bWVudDtcbiAgICB9O1xuICAgIHZhciBoYXNUaW1pbmcgPSBmdW5jdGlvbiBoYXNUaW1pbmcoKSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdztcbiAgICB9OyAvLyBpT1MgOC54XG4gICAgdmFyIGhhc0NTU1N1cHBvcnRzID0gZnVuY3Rpb24gaGFzQ1NTU3VwcG9ydHMoKSB7XG4gICAgICAgIHJldHVybiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTtcbiAgICB9OyAvLyB1c2UgdG8gZGV0ZWN0IFNhZmFyaSA5K1xuICAgIHZhciBpc0lFMTEgPSBmdW5jdGlvbiBpc0lFMTEoKSB7XG4gICAgICAgIHJldHVybiAvTVNJRXxUcmlkZW50Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICAgIHZhciBpc1N1cHBvcnRlZCA9XG4gICAgICAgICAgICAvLyBIYXMgdG8gYmUgYSBicm93c2VyXG4gICAgICAgICAgICBpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAgICAgLy8gQ2FuJ3QgcnVuIG9uIE9wZXJhIE1pbmkgZHVlIHRvIGxhY2sgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgICAgIWlzT3BlcmFNaW5pKCkgJiZcbiAgICAgICAgICAgIC8vIFJlcXVpcmUgdGhlc2UgQVBJcyB0byBmZWF0dXJlIGRldGVjdCBhIG1vZGVybiBicm93c2VyXG4gICAgICAgICAgICBoYXNWaXNpYmlsaXR5KCkgJiZcbiAgICAgICAgICAgIGhhc1Byb21pc2VzKCkgJiZcbiAgICAgICAgICAgIGhhc0Jsb2JTbGljZSgpICYmXG4gICAgICAgICAgICBoYXNDcmVhdGVPYmplY3RVUkwoKSAmJlxuICAgICAgICAgICAgaGFzVGltaW5nKCkgJiZcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCBDU1NTdXBwb3J0cyBidXQgaXMgYSBnb29kIHdheSB0byBkZXRlY3QgU2FmYXJpIDkrICh3ZSBkbyB3YW50IHRvIHN1cHBvcnQgSUUxMSB0aG91Z2gpXG4gICAgICAgICAgICAoaGFzQ1NTU3VwcG9ydHMoKSB8fCBpc0lFMTEoKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAgICAgKi9cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICAgICAgYXBwczogW10sXG4gICAgfTtcblxuICAgIC8vIHBsdWdpbiBuYW1lXG4gICAgdmFyIG5hbWUgPSAnZmlsZXBvbmQnO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIFBsdWdpbiBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7fTtcbiAgICBleHBvcnRzLlN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZVN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZU9yaWdpbiA9IHt9O1xuICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGZuO1xuICAgIGV4cG9ydHMuZGVzdHJveSA9IGZuO1xuICAgIGV4cG9ydHMucGFyc2UgPSBmbjtcbiAgICBleHBvcnRzLmZpbmQgPSBmbjtcbiAgICBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luID0gZm47XG4gICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZm47XG4gICAgZXhwb3J0cy5zZXRPcHRpb25zID0gZm47XG5cbiAgICAvLyBpZiBub3Qgc3VwcG9ydGVkLCBubyBBUElcbiAgICBpZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gc3RhcnQgcGFpbnRlciBhbmQgZmlyZSBsb2FkIGV2ZW50XG4gICAgICAgIGNyZWF0ZVBhaW50ZXIoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHAuX3JlYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbih0cykge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5fd3JpdGUodHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGZpcmUgbG9hZGVkIGV2ZW50IHNvIHdlIGtub3cgd2hlbiBGaWxlUG9uZCBpcyBhdmFpbGFibGVcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6bG9hZGVkJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiBleHBvcnRzLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGV4cG9ydHMuZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiBleHBvcnRzLnBhcnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluZDogZXhwb3J0cy5maW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBleHBvcnRzLnNldE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHVwIGV2ZW50XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgICAgIHZhciB1cGRhdGVPcHRpb25UeXBlcyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvblR5cGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXNba2V5XSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwb3J0cy5TdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0dXMpO1xuICAgICAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSBPYmplY3QuYXNzaWduKHt9LCBGaWxlT3JpZ2luKTtcbiAgICAgICAgZXhwb3J0cy5GaWxlU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgSXRlbVN0YXR1cyk7XG5cbiAgICAgICAgZXhwb3J0cy5PcHRpb25UeXBlcyA9IHt9O1xuICAgICAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtZXRob2QsIGNyZWF0ZXMgYXBwcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwJDEuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXBwLm9uKCdkZXN0cm95JywgZXhwb3J0cy5kZXN0cm95KTtcbiAgICAgICAgICAgIHN0YXRlLmFwcHMucHVzaChhcHApO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlc3Ryb3lzIGFwcHMgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShob29rKSB7XG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgdGhlIGFwcCB3YXMgZGVzdHJveWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBzdGF0ZS5hcHBzLmZpbmRJbmRleChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGFwcHNcbiAgICAgICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSlbMF07XG5cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhcnNlcyB0aGUgZ2l2ZW4gY29udGV4dCBmb3IgcGx1Z2lucyAoZG9lcyBub3QgaW5jbHVkZSB0aGUgY29udGV4dCBlbGVtZW50IGl0c2VsZilcbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgcG9zc2libGUgaG9va3NcbiAgICAgICAgICAgIHZhciBtYXRjaGVkSG9va3MgPSBBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBuYW1lKSk7XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSBhY3RpdmUgaG9va3NcbiAgICAgICAgICAgIHZhciBuZXdIb29rcyA9IG1hdGNoZWRIb29rcy5maWx0ZXIoZnVuY3Rpb24obmV3SG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhuZXdIb29rKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIGZvciBlYWNoIGhvb2tcbiAgICAgICAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoZnVuY3Rpb24oaG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYW4gYXBwIGJhc2VkIG9uIHRoZSBnaXZlbiBlbGVtZW50IGhvb2tcbiAgICAgICAgZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gZmluZChob29rKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgICAgIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zJDEoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWVbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMkMShvcHRzKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0cykpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcGx1Z2luc1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLnNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgb3B0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_edit_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./filepond-plugin-image-edit.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_edit_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_edit_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRTtBQUMvRSxZQUE2TTs7QUFFN007O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDZGQUFHLENBQUMsMkxBQU87Ozs7QUFJeEIsaUVBQWUsa01BQWMsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZWRpdC9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1lZGl0LmNzcz80ZTA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xM1swXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTNbMF0ucnVsZXNbMF0udXNlWzJdIS4vZmlsZXBvbmQtcGx1Z2luLWltYWdlLWVkaXQuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-edit/dist/filepond-plugin-image-edit.css\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css":
/*!*******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./filepond-plugin-image-preview.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-13[0].rules[0].use[2]!./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_13_0_rules_0_use_2_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRTtBQUMvRSxZQUFnTjs7QUFFaE47O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDZGQUFHLENBQUMsOExBQU87Ozs7QUFJeEIsaUVBQWUscU1BQWMsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3LmNzcz8zNjkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xM1swXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTNbMF0ucnVsZXNbMF0udXNlWzJdIS4vZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFFQUFxRSxxQkFBcUIsY0FBYzs7QUFFeEc7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/filepond.js");
/******/ 	
/******/ })()
;