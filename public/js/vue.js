/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/vue.js":
/*!*****************************!*\
  !*** ./resources/js/vue.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Vue.js v2.6.14\n * (c) 2014-2021 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive.\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    _typeof(value) === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && _typeof(obj) === 'object';\n  }\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val[\"catch\"] === 'function';\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array.\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether an object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function no(a, b, c) {\n    return false;\n  };\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n\n\n  var identity = function identity(_) {\n    return _;\n  };\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = ('__proto__' in {}); // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n  * not type checking this file because flow doesn't play well with\n  * dynamically accessing methods on Array prototype\n  */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (customSetter) {\n          customSetter();\n        } // #7981: for accessor properties without setter\n\n\n        if (getter && !setter) {\n          return;\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i]; // in case the object is already observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n\n        if (typeof def$$1 === 'function') {\n          dirs[key] = {\n            bind: def$$1,\n            update: def$$1\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child); // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n\n    if (!child._base) {\n      if (child[\"extends\"]) {\n        parent = mergeOptions(parent, child[\"extends\"], vm);\n      }\n\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop[\"default\"]; // warn against non-factory defaults for Object & Array\n\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i], vm);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    var haveExpectedTypes = expectedTypes.some(function (t) {\n      return t;\n    });\n\n    if (!valid && haveExpectedTypes) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\n\n  function assertType(value, type, vm) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = _typeof(value);\n\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      try {\n        valid = value instanceof type;\n      } catch (e) {\n        warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n        valid = false;\n      }\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  var functionTypeCheckRE = /^\\s*function (\\w+)/;\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(functionTypeCheckRE);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value); // check if we need to specify expected value\n\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(_typeof(value)) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + styleValue(value, expectedType);\n    }\n\n    message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + styleValue(value, receivedType) + \".\";\n    }\n\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\n\n  function isExplicable(value) {\n    return EXPLICABLE_TYPES.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n\n    try {\n      if (vm) {\n        var cur = vm;\n\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res[\"catch\"](function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        }); // issue #9511\n        // avoid catch triggering multiple times when nested calls\n\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n\n  var isUsingMicroTask = false;\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n\n\n  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n\n  /* istanbul ignore next, $flow-disable-line */\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    timerFunc = function timerFunc() {\n      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function timerFunc() {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function timerFunc() {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag); // perf.clearMeasures(name)\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function warnReservedPrefix(target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = (key in target);\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // #6574 in case the inject object is observed...\n\n        if (key === '__ob__') {\n          continue;\n        }\n\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key][\"default\"];\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n\n    var slots = {};\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots[\"default\"] || (slots[\"default\"] = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    } // expose normal slots on scopedSlots\n\n\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    } // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n\n\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function normalized() {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && _typeof(res) === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      var vnode = res && res[0];\n      return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391\n      ) ? undefined : res;\n    }; // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n\n\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n\n    if (!isDef(ret)) {\n      ret = [];\n    }\n\n    ret._isVList = true;\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallbackRender, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n    } else {\n      nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n\n    return eventKeyCode === undefined;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res, // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || {\n      $stable: !hasDynamicKeys\n    };\n\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n\n        res[slot.key] = slot.fn;\n      }\n    }\n\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a special value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n\n    return baseObj;\n  } // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n\n\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    }); // support for compiled functional template\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options[\"abstract\"])) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't\n  vnode, // activeInstance in lifecycle state\n  parent) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function merged(a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n\n    merged._merged = true;\n    return merged;\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        \"default\": children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {\n          warn(\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\", context);\n        }\n\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data[\"class\"])) {\n      traverse(data[\"class\"]);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      } // if the returned array contains only a single node, allow it\n\n\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp[\"default\"];\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;\n      owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function forceRender(renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      } // specific handler\n\n\n      var cb;\n      var i = cbs.length;\n\n      while (i--) {\n        cb = cbs[i];\n\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options[\"abstract\"]) {\n      while (parent.$options[\"abstract\"] && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        );\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      restoreActiveInstance(); // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options[\"abstract\"]) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  } // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n\n\n  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\n  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function getNow() {\n        return performance.now();\n      };\n    }\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n\n      if (watcher.before) {\n        watcher.before();\n      }\n\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$2 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          var info = \"callback for watcher \\\"\" + this.expression + \"\\\"\";\n          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        } else if (vm.$options.methods && key in vm.$options.methods) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a method.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + _typeof(methods[key]) + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        var info = \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\";\n        pushTarget();\n        invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n        popTarget();\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor[\"super\"]) {\n      var superOptions = resolveConstructorOptions(Ctor[\"super\"]);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = latest[key];\n      }\n    }\n\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var entry = cache[key];\n\n      if (entry) {\n        var name = entry.name;\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var entry = cache[key];\n\n    if (entry && (!current || entry.tag !== current.tag)) {\n      entry.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    \"abstract\": true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    methods: {\n      cacheVNode: function cacheVNode() {\n        var ref = this;\n        var cache = ref.cache;\n        var keys = ref.keys;\n        var vnodeToCache = ref.vnodeToCache;\n        var keyToCache = ref.keyToCache;\n\n        if (vnodeToCache) {\n          var tag = vnodeToCache.tag;\n          var componentInstance = vnodeToCache.componentInstance;\n          var componentOptions = vnodeToCache.componentOptions;\n          cache[keyToCache] = {\n            name: getComponentName(componentOptions),\n            tag: tag,\n            componentInstance: componentInstance\n          };\n          keys.push(keyToCache); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n\n          this.vnodeToCache = null;\n        }\n      }\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.cacheVNode();\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    updated: function updated() {\n      this.cacheVNode();\n    },\n    render: function render() {\n      var slot = this.$slots[\"default\"];\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          // delay setting the cache until update\n          this.vnodeToCache = vnode;\n          this.keyToCache = key;\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n    Vue.set = set;\n    Vue[\"delete\"] = del;\n    Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.6.14';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function convertEnumeratedValue(key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data[\"class\"]);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      \"class\": isDef(child[\"class\"]) ? [child[\"class\"], parent[\"class\"]] : parent[\"class\"]\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          );\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur, vnode.data.pre);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value, isInPre) {\n    if (isInPre || el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data[\"class\"]) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData[\"class\"]))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n\n\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({\n      name: name,\n      value: value\n    }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n\n    if (modifiers[\"native\"]) {\n      delete modifiers[\"native\"];\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({\n      value: value.trim(),\n      dynamic: dynamic\n    }, range);\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n\n    return item;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n\n\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n\n      handler = original._wrapper = function (e) {\n        if ( // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget || // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n\n    target$1.addEventListener(name, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if ( // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecessary `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (_typeof(def$$1) === 'object') {\n      var res = {};\n\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n\n\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options[\"abstract\"]) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function isNotTextNode(c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function isVShowDirective(d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    \"abstract\": true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots[\"default\"];\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n      var update = this._update;\n\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots[\"default\"] || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n  /*  */\n  // install platform specific utils\n\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n  /*  */\n\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n            start: index + html.length\n          });\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs,\n          start: match.start,\n          end: match.end\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n              start: stack[i].start,\n              end: stack[i].end\n            });\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:|^#/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  var slotRE = /^v-slot(:|$)|^#/;\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /[ \\f\\t\\r\\n]+/g;\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  var decodeHTMLCached = cached(he.decode);\n  var emptySlotScopeToken = \"_empty_\"; // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n\n    maybeComponent = function maybeComponent(el) {\n      return !!(el.component || el.attrsMap[':is'] || el.attrsMap['v-bind:is'] || !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      } // tree management\n\n\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root[\"if\"] && (element.elseif || element[\"else\"])) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n            start: element.start\n          });\n        }\n      }\n\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element[\"else\"]) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      } // final children cleanup\n      // filter out scoped slots\n\n\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      }); // remove trailing whitespace node again\n\n      trimEndingWhitespace(element); // check pre state\n\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n          start: el.start\n        });\n      }\n\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n            start: element.start\n          });\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1]; // pop stack\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n\n        closeElement(element);\n      },\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', {\n                start: start\n              });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n                start: start\n              });\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n\n          var res;\n          var child;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anything as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n\n        if (el[\"for\"]) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n            /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res[\"for\"] = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el[\"if\"] = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el[\"else\"] = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev[\"if\"]) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  } // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\n  function processSlotContent(el) {\n    var slotScope;\n\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n\n      el.slotScope = slotScope;\n    } // slot=\"xxx\"\n\n\n    var slotTarget = getBindingAttr(el, 'slot');\n\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    } // 2.6 v-slot syntax\n\n\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          } // add the component's children to its default slot\n\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n          el.children = []; // mark el non-plain so data gets generated\n\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n\n    return dynamicArgRE.test(name) // dynamic [name]\n    ? {\n      name: name.slice(1, -1),\n      dynamic: true\n    } // static name\n    : {\n      name: \"\\\"\" + name + \"\\\"\",\n      dynamic: false\n    };\n  } // handle <slot/> outlets\n\n\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent[\"for\"] !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el[\"for\"] && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0[\"if\"] = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0[\"if\"],\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0[\"else\"] = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$1];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node[\"static\"] = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child[\"static\"]) {\n          node[\"static\"] = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block[\"static\"]) {\n            node[\"static\"] = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node[\"static\"] || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node[\"static\"] && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node[\"for\"]);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node[\"if\"] && !node[\"for\"] && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node[\"for\"]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \".apply(null, arguments)\" : isFunctionExpression ? \"return (\" + handler.value + \").apply(null, arguments)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (// make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options); // fix #11483, Root level <script> tags should not be rendered.\n\n    var code = ast ? ast.tag === 'script' ? 'null' : genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el[\"for\"] && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el[\"if\"] && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n\n    var originalPreState = state.pre;\n\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el[\"if\"] && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent[\"for\"]) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el[\"for\"];\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    } // v-bind data wrap\n\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', {\n        start: el.start\n      });\n    }\n\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el[\"for\"] || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot[\"if\"] || slot[\"for\"] || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    }); // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n\n    var needsKey = !!el[\"if\"]; // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent[\"for\"]) {\n          needsForceUpdate = true;\n          break;\n        }\n\n        if (parent[\"if\"]) {\n          needsKey = true;\n        }\n\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n\n      return el.children.some(containsSlotChild);\n    }\n\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n\n    if (el[\"if\"] && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n\n    if (el[\"for\"] && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el[\"if\"] && isLegacySyntax ? \"(\" + el[\"if\"] + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1[\"for\"] && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el[\"for\"] !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",function(){return \" + children + \"}\" : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            var range = node.rawAttrsMap[name];\n\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (name === 'v-slot' || name[0] === '#') {\n              checkFunctionParameterExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stripped = exp.replace(stripStringRE, '');\n    var keywordMatch = stripped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node[\"for\"] || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n\n  function checkFunctionParameterExpression(exp, text, warn, range) {\n    try {\n      new Function(exp, '');\n    } catch (e) {\n      warn(\"invalid function parameter expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n  /*  */\n\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n\n            count += lineLength + 1;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n\n        n >>>= 1;\n\n        if (n <= 0) {\n          break;\n        }\n\n        str += str;\n      }\n    }\n\n    return result;\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function warn(msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function warn(msg, range, tip) {\n              var data = {\n                msg: msg\n              };\n\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n\n              (tip ? tips : errors).push(data);\n            };\n          } // merge custom modules\n\n\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDtBQXFFQTtBQUNKO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU3VrQyxZQUFULENBQXVCMTJDLEVBQXZCLEVBQTJCO0FBQ3ZCLFFBQUlBLEVBQUUsQ0FBQzIyQyxTQUFQLEVBQWtCO0FBQ2QsYUFBTzMyQyxFQUFFLENBQUMyMkMsU0FBVjtBQUNILEtBRkQsTUFFTztBQUNILFVBQUlDLFNBQVMsR0FBR2p3QyxRQUFRLENBQUM4SyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FtbEMsTUFBQUEsU0FBUyxDQUFDcndCLFdBQVYsQ0FBc0J2bUIsRUFBRSxDQUFDMmhDLFNBQUgsQ0FBYSxJQUFiLENBQXRCO0FBQ0EsYUFBT2lWLFNBQVMsQ0FBQ2pyQixTQUFqQjtBQUNIO0FBQ0o7O0FBRUQzL0IsRUFBQUEsR0FBRyxDQUFDeXBELE9BQUosR0FBY0Msa0JBQWQ7QUFFQSxTQUFPMXBELEdBQVA7QUFFSCxDQXh1WEEsQ0FBRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy92dWUuanM/ZjNlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgICAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgICAgICAgICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4gICAgLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4gICAgLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbiAgICBmdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gICAgICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICAgICAgICByZXR1cm4gdiA9PT0gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gICAgICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICAgICAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gICAgICovXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICBmdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICAgICAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gICAgICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzRGVmKHZhbCkgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID09IG51bGxcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICAgICAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAgICAgKiBpcyBpbiB0aGF0IG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTWFwIChcbiAgICAgICAgc3RyLFxuICAgICAgICBleHBlY3RzTG93ZXJDYXNlXG4gICAgKSB7XG4gICAgICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICAgICAqL1xuICAgIHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBmdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgICAgICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuICAgIHZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gICAgICovXG4gICAgdmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbiAgICB2YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICAgICAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgICAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgICAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAgICAgKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICAgICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBsXG4gICAgICAgICAgICAgICAgPyBsID4gMVxuICAgICAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgICAgICAgICAgIDogZm4uY2FsbChjdHgpXG4gICAgICAgIH1cblxuICAgICAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBib3VuZEZuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICAgICAgICByZXR1cm4gZm4uYmluZChjdHgpXG4gICAgfVxuXG4gICAgdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAgICAgICA/IG5hdGl2ZUJpbmRcbiAgICAgICAgOiBwb2x5ZmlsbEJpbmQ7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgICAgICAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAgICAgKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAgICAgKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuICAgIC8qKlxuICAgICAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgdmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICAgICAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gICAgICAgIH0sIFtdKS5qb2luKCcsJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAgICAgKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICAgICAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICAgICAgICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICAgICAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAgICAgKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlIChmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbiAgICB2YXIgQVNTRVRfVFlQRVMgPSBbXG4gICAgICAgICdjb21wb25lbnQnLFxuICAgICAgICAnZGlyZWN0aXZlJyxcbiAgICAgICAgJ2ZpbHRlcidcbiAgICBdO1xuXG4gICAgdmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgICAgICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgICAgICdjcmVhdGVkJyxcbiAgICAgICAgJ2JlZm9yZU1vdW50JyxcbiAgICAgICAgJ21vdW50ZWQnLFxuICAgICAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAgICAgJ3VwZGF0ZWQnLFxuICAgICAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgICAgICdkZXN0cm95ZWQnLFxuICAgICAgICAnYWN0aXZhdGVkJyxcbiAgICAgICAgJ2RlYWN0aXZhdGVkJyxcbiAgICAgICAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAgICAgICAnc2VydmVyUHJlZmV0Y2gnXG4gICAgXTtcblxuICAgIC8qICAqL1xuXG5cblxuICAgIHZhciBjb25maWcgPSAoe1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICAgICAqL1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICAgICAgICovXG4gICAgICAgIHByb2R1Y3Rpb25UaXA6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgICAgICAgKi9cbiAgICAgICAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAgICAgICAqL1xuICAgICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgICAgICovXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAgICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgICAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAgICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgICAgICovXG4gICAgICAgIG11c3RVc2VQcm9wOiBubyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICAgICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYzogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgICAgICovXG4gICAgICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG4gICAgfSk7XG5cbiAgICAvKiAgKi9cblxuICAgIC8qKlxuICAgICAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICAgICAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAgICAgKi9cbiAgICB2YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICAgICAgICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAgICAgKi9cbiAgICB2YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbiAgICBmdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgICAgICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICAvLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbiAgICB2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuICAgIC8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbiAgICB2YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG4gICAgdmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbiAgICB2YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbiAgICB2YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG4gICAgdmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuICAgIHZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG4gICAgdmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG4gICAgdmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG4gICAgdmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4gICAgLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuICAgIHZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuICAgIC8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG4gICAgdmFyIF9pc1NlcnZlcjtcbiAgICB2YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9pc1NlcnZlclxuICAgIH07XG5cbiAgICAvLyBkZXRlY3QgZGV2dG9vbHNcbiAgICB2YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxuICAgIH1cblxuICAgIHZhciBoYXNTeW1ib2wgPVxuICAgICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gICAgICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4gICAgdmFyIF9TZXQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gICAgICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICBfU2V0ID0gU2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgICAgICAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gU2V0O1xuICAgICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHdhcm4gPSBub29wO1xuICAgIHZhciB0aXAgPSBub29wO1xuICAgIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG4gICAgdmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbiAgICB7XG4gICAgICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgICAgICAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgICAgICAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgICAgICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgICAgICAgICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgICAgICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgICAgICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICA6IHZtO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICAgICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgICAgICAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgICAgICAgICApXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICAgICAgICAgIHZhciByZXMgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzXG4gICAgICAgIH07XG5cbiAgICAgICAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciB1aWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gICAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICAgKi9cbiAgICB2YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgICAgICAgdGhpcy5pZCA9IHVpZCsrO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcbiAgICB9O1xuXG4gICAgRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICAgICAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICAgIH07XG5cbiAgICBEZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gICAgfTtcblxuICAgIERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgICAgICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgICAgICAgIC8vIG9yZGVyXG4gICAgICAgICAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbiAgICAvLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbiAgICAvLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbiAgICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgICB2YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gICAgICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgICAgICAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gICAgICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgICAgICAgdGFnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGV4dCxcbiAgICAgICAgZWxtLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb21wb25lbnRPcHRpb25zLFxuICAgICAgICBhc3luY0ZhY3RvcnlcbiAgICApIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5lbG0gPSBlbG07XG4gICAgICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgICAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICAgIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gICAgdmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICAgICAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgICAgICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG4gICAgfVxuXG4gICAgLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbiAgICAvLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4gICAgLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4gICAgLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbiAgICBmdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgICAgICAgICAgdm5vZGUudGFnLFxuICAgICAgICAgICAgdm5vZGUuZGF0YSxcbiAgICAgICAgICAgIC8vICM3OTc1XG4gICAgICAgICAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAgICAgICAgIC8vIGEgY2hpbGQuXG4gICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgICAgICAgICAgdm5vZGUudGV4dCxcbiAgICAgICAgICAgIHZub2RlLmVsbSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHQsXG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgICAgICAgICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICAgICAgICk7XG4gICAgICAgIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICAgICAgICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgICAgICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgICAgICAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgICAgICAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgICAgICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgICAgICAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgICAgICAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgICAgICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNsb25lZFxuICAgIH1cblxuICAgIC8qXG4gICAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICAgKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAgICovXG5cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxuICAgIHZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgICAgICAgJ3B1c2gnLFxuICAgICAgICAncG9wJyxcbiAgICAgICAgJ3NoaWZ0JyxcbiAgICAgICAgJ3Vuc2hpZnQnLFxuICAgICAgICAnc3BsaWNlJyxcbiAgICAgICAgJ3NvcnQnLFxuICAgICAgICAncmV2ZXJzZSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gICAgICovXG4gICAgbWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAgICAgICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICAgICAgICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4gICAgLyoqXG4gICAgICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gICAgICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgICAgICAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICAgICAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICAgICAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICAgICAqL1xuICAgIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgICAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgICAgICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhbGsodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICAgKi9cbiAgICBPYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAgICAgKi9cbiAgICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaGVscGVyc1xuXG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gICAgICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICAgICAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAgICAgKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICAgICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBvYjtcbiAgICAgICAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAgICAgICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgICAgICAgIXZhbHVlLl9pc1Z1ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgICAgICAgICAgb2Iudm1Db3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gICAgICAgIG9iaixcbiAgICAgICAga2V5LFxuICAgICAgICB2YWwsXG4gICAgICAgIGN1c3RvbVNldHRlcixcbiAgICAgICAgc2hhbGxvd1xuICAgICkge1xuICAgICAgICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgICAgICAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgICAgICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgICAgICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgICAgICAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgICAgICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICAgICAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAgICAgKiBhbHJlYWR5IGV4aXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgICAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAgICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICB9XG4gICAgICAgIGlmICghb2IpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHZhbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgICAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAgICAgICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgIGlmICghb2IpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICAgICAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsdWVbaV07XG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAgICAgKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICAgICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICAgICAqL1xuICAgIHtcbiAgICAgICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIXZtKSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICAgICAgICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgICAgICAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgICAgICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgICAgICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICAgICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICAgICAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgICAgICAgICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgICAgICAgcGFyZW50VmFsLFxuICAgICAgICBjaGlsZFZhbCxcbiAgICAgICAgdm1cbiAgICApIHtcbiAgICAgICAgaWYgKCF2bSkge1xuICAgICAgICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgICAgICAgICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGRWYWw7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gICAgICAgIHBhcmVudFZhbCxcbiAgICAgICAgY2hpbGRWYWwsXG4gICAgICAgIHZtXG4gICAgKSB7XG4gICAgICAgIGlmICghdm0pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZUhvb2sgKFxuICAgICAgICBwYXJlbnRWYWwsXG4gICAgICAgIGNoaWxkVmFsXG4gICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBjaGlsZFZhbFxuICAgICAgICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICAgICAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgICAgICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgICAgICAgICAgOiByZXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQXNzZXRzXG4gICAgICpcbiAgICAgKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gICAgICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICAgICAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgICAgICAgcGFyZW50VmFsLFxuICAgICAgICBjaGlsZFZhbCxcbiAgICAgICAgdm0sXG4gICAgICAgIGtleVxuICAgICkge1xuICAgICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gICAgICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV2F0Y2hlcnMuXG4gICAgICpcbiAgICAgKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gICAgICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gICAgICovXG4gICAgc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICAgICAgICBwYXJlbnRWYWwsXG4gICAgICAgIGNoaWxkVmFsLFxuICAgICAgICB2bSxcbiAgICAgICAga2V5XG4gICAgKSB7XG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgICAgIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICAgICAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICAgICAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICAgICAqL1xuICAgIHN0cmF0cy5wcm9wcyA9XG4gICAgICAgIHN0cmF0cy5tZXRob2RzID1cbiAgICAgICAgICAgIHN0cmF0cy5pbmplY3QgPVxuICAgICAgICAgICAgICAgIHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VmFsLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZhbCxcbiAgICAgICAgICAgICAgICAgICAgdm0sXG4gICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgIHN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHBhcmVudFZhbFxuICAgICAgICAgICAgOiBjaGlsZFZhbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICAgICAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgICAgIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB2YXIgaSwgdmFsLCBuYW1lO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbFxuICAgICAgICAgICAgICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICAgICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgICAgICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICAgICAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgICAgICAgICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgICAgICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgICAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICAgICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICAgICAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgdm1cbiAgICApIHtcbiAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gICAgICAgIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICAgICAgICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAgICAgICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gICAgICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgICAgICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgICAgICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gICAgICAgIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICAgICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgICAgICAgICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhbiBhc3NldC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAgICAgKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaWQsXG4gICAgICAgIHdhcm5NaXNzaW5nXG4gICAgKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gICAgICAgIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gICAgICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICAgICAgICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gICAgICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICAgICAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgICAgIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICAgICAgICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgICAgICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qICAqL1xuXG5cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gICAgICAgIGtleSxcbiAgICAgICAgcHJvcE9wdGlvbnMsXG4gICAgICAgIHByb3BzRGF0YSxcbiAgICAgICAgdm1cbiAgICApIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICAgICAgICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAgICAgICAvLyBib29sZWFuIGNhc3RpbmdcbiAgICAgICAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgICAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgICAgICAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgICAgICAgICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICAgICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAgICAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAgICAgICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAgICAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgICAgIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICAgICAgICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gICAgICAgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICAgICAgICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgICAgICAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICAgICAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICAgICAgICA6IGRlZlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgICAgICAgcHJvcCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZtLFxuICAgICAgICBhYnNlbnRcbiAgICApIHtcbiAgICAgICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgICAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlRXhwZWN0ZWRUeXBlcyA9IGV4cGVjdGVkVHlwZXMuc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgaGF2ZUV4cGVjdGVkVHlwZXMpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2x8QmlnSW50KSQvO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUsIHZtKSB7XG4gICAgICAgIHZhciB2YWxpZDtcbiAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgICAgIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICAgICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICAgICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogdmFsaWQsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICAgICAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICAgICAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICAgICAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gICAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgICAgICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICAgICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAgICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgKHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICAgICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpKSArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRVhQTElDQUJMRV9UWVBFUyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gICAgZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRVhQTElDQUJMRV9UWVBFUy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgICAgICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodm0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gdm07XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHZtLFxuICAgICAgICBpbmZvXG4gICAgKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgICAgICAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgICAgICAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgY2F0Y2ggdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyB3aGVuIG5lc3RlZCBjYWxsc1xuICAgICAgICAgICAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICAgICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICAgICAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgICAgICB7XG4gICAgICAgICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICB2YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHZhciBwZW5kaW5nID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3BpZXNbaV0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbiAgICAvLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuICAgIC8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4gICAgLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4gICAgLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4gICAgLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuICAgIC8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuICAgIC8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuICAgIC8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbiAgICAvLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbiAgICB2YXIgdGltZXJGdW5jO1xuXG4gICAgLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAgIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICAgICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgICAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgICAgIH07XG4gICAgICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICAgICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgICApKSB7XG4gICAgICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgICAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gICAgICAgIHZhciBjb3VudGVyID0gMTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICAgICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgICAgICB9O1xuICAgICAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAgICAgICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAgICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gICAgICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgICAgICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICAgICAgdmFyIF9yZXNvbHZlO1xuICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRpbWVyRnVuYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIG1hcms7XG4gICAgdmFyIG1lYXN1cmU7XG5cbiAgICB7XG4gICAgICAgIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHBlcmYgJiZcbiAgICAgICAgICAgIHBlcmYubWFyayAmJlxuICAgICAgICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICAgICAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICAgICAgICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICAgICAgICApIHtcbiAgICAgICAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICAgICAgICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgICAgICAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgICAgICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICAgICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG4gICAgdmFyIGluaXRQcm94eTtcblxuICAgIHtcbiAgICAgICAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAgICAgICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgICAgICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICAgICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgICAgICAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAgICAgICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAgICAgICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICAgICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAgICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMuICcgK1xuICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYXNQcm94eSA9XG4gICAgICAgICAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICAgICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgICAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgICAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICAgICAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAgICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgICAgICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgICAgICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gICAgICAgIHZhciBpLCBrZXlzO1xuICAgICAgICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgICAgICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgICAgICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQSkge1xuICAgICAgICAgICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgICAgICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICAgICAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gICAgICAgIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gICAgICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICAgICAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBvbmNlOiBvbmNlJCQxLFxuICAgICAgICAgICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICAgICAgcmV0dXJuIGludm9rZXJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICAgICAgICBvbixcbiAgICAgICAgb2xkT24sXG4gICAgICAgIGFkZCxcbiAgICAgICAgcmVtb3ZlJCQxLFxuICAgICAgICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgICAgICAgdm1cbiAgICApIHtcbiAgICAgICAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICAgICAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgICAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlT25jZUhhbmRsZXIoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgICAgICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgICAgICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgICAgICAgICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52b2tlcjtcbiAgICAgICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgICAgICAgICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgICAgICAgICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAgICAgICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgICAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICAgICAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgICAgICAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgICAgICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICAgICAgICBkYXRhLFxuICAgICAgICBDdG9yLFxuICAgICAgICB0YWdcbiAgICApIHtcbiAgICAgICAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gICAgICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICAgICAgICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gICAgICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgICAgICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICAgICAgICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgICAgICAgcmVzLFxuICAgICAgICBoYXNoLFxuICAgICAgICBrZXksXG4gICAgICAgIGFsdEtleSxcbiAgICAgICAgcHJlc2VydmVcbiAgICApIHtcbiAgICAgICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4gICAgLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbiAgICAvL1xuICAgIC8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4gICAgLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuICAgIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAgIC8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAvLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gICAgLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4gICAgLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuICAgIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgfVxuXG4gICAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgICAvLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICAvLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4gICAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgICAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICAgICAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAgICAgICAgIC8vICBuZXN0ZWRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgICAgIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgICAgICAgaWYgKHByb3ZpZGUpIHtcbiAgICAgICAgICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICAgICAgICAgICAgOiBwcm92aWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgICAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cblxuXG4gICAgLyoqXG4gICAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29udGV4dFxuICAgICkge1xuICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9XG4gICAgICAgIHZhciBzbG90cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgICAgICAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgICAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgICAgICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICAgICAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgICAgICAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsb3RzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICAgICAgICBzbG90cyxcbiAgICAgICAgbm9ybWFsU2xvdHMsXG4gICAgICAgIHByZXZTbG90c1xuICAgICkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gICAgICAgIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICAgICAgICBpZiAoIXNsb3RzKSB7XG4gICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgICAgICAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGlzU3RhYmxlICYmXG4gICAgICAgICAgICBwcmV2U2xvdHMgJiZcbiAgICAgICAgICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICAgICAgICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAgICAgICAgICFoYXNOb3JtYWxTbG90cyAmJlxuICAgICAgICAgICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgICAgICAgICByZXR1cm4gcHJldlNsb3RzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICAgICAgICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgICAgICAgICAgaWYgKCEoa2V5JDIgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgICAgIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICAgICAgICBpZiAoc2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzbG90cykpIHtcbiAgICAgICAgICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gICAgICAgIH1cbiAgICAgICAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gICAgICAgIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgICAgICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gICAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgICAgICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICAgICAgICAgIHZhciB2bm9kZSA9IHJlcyAmJiByZXNbMF07XG4gICAgICAgICAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICAgICAgICAgICAhdm5vZGUgfHxcbiAgICAgICAgICAgICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiB2bm9kZS5pc0NvbW1lbnQgJiYgIWlzQXN5bmNQbGFjZWhvbGRlcih2bm9kZSkpIC8vICM5NjU4LCAjMTAzOTFcbiAgICAgICAgICAgICkgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHJlc1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgICAgICAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gICAgICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgICAgICBpZiAoZm4ucHJveHkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICAvKipcbiAgICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICAgICAgICB2YWwsXG4gICAgICAgIHJlbmRlclxuICAgICkge1xuICAgICAgICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWYocmV0KSkge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICAvKipcbiAgICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICAgICAgICBuYW1lLFxuICAgICAgICBmYWxsYmFja1JlbmRlcixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGJpbmRPYmplY3RcbiAgICApIHtcbiAgICAgICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICAgICAgICB2YXIgbm9kZXM7XG4gICAgICAgIGlmIChzY29wZWRTbG90Rm4pIHtcbiAgICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgICAgIHNjb3BlZFNsb3RGbihwcm9wcykgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIC8qKlxuICAgICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gICAgICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gICAgICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gICAgICAgIGV2ZW50S2V5Q29kZSxcbiAgICAgICAga2V5LFxuICAgICAgICBidWlsdEluS2V5Q29kZSxcbiAgICAgICAgZXZlbnRLZXlOYW1lLFxuICAgICAgICBidWlsdEluS2V5TmFtZVxuICAgICkge1xuICAgICAgICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICAgICAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgICAgICAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudEtleUNvZGUgPT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgLyoqXG4gICAgICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICAgICAgICBkYXRhLFxuICAgICAgICB0YWcsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhc1Byb3AsXG4gICAgICAgIGlzU3luY1xuICAgICkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhhc2g7XG4gICAgICAgICAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICAvKipcbiAgICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbkZvclxuICAgICkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICAgICAgICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgICAgIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAgICAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgICAgICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICAgICAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICAgICAgICApO1xuICAgICAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJlZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gICAgICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFya09uY2UgKFxuICAgICAgICB0cmVlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAga2V5XG4gICAgKSB7XG4gICAgICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICAgICAgICByZXR1cm4gdHJlZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICAgICAgICB0cmVlLFxuICAgICAgICBrZXksXG4gICAgICAgIGlzT25jZVxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICAgICAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gICAgICAgIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgICAgICAgcmVzLFxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBhZGRlZCBpbiAyLjZcbiAgICAgICAgaGFzRHluYW1pY0tleXMsXG4gICAgICAgIGNvbnRlbnRIYXNoS2V5XG4gICAgKSB7XG4gICAgICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBmbnNbaV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICAgICAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgICAgICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgICAgICAgICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VPYmpcbiAgICB9XG5cbiAgICAvLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbiAgICAvLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuICAgIC8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbiAgICBmdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICAgICAgICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgICAgICAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gICAgICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gICAgICAgIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gICAgICAgIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gICAgICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgICAgICAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICAgICAgICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICAgICAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICAgICAgICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gICAgICAgIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgICAgICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgICAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICAgICAgICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICAgICAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gICAgICAgIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIEN0b3JcbiAgICApIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICAgICAgICB2YXIgY29udGV4dFZtO1xuICAgICAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgICAgICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAgICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gICAgICAgIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICAgICAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgICAgICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICAgICAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAgICAgICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgICAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgICAgICAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgICAgICAgQ3RvcixcbiAgICAgICAgcHJvcHNEYXRhLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0Vm0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgICAgICAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250ZXh0Vm0sXG4gICAgICAgICAgICBDdG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICAgICAgICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgICAgICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgICAgICAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gICAgICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICAgICAgICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgICAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB7XG4gICAgICAgICAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAgICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgICAgICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIC8qICAqL1xuXG4gICAgLyogICovXG5cbiAgICAvKiAgKi9cblxuICAgIC8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG4gICAgdmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICAgICAgICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgICAgICAgICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgICAgICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgICAgICAgQ3RvcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICkge1xuICAgICAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gICAgICAgIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICAgICAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgICAgICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gICAgICAgIC8vIHJlamVjdC5cbiAgICAgICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzeW5jIGNvbXBvbmVudFxuICAgICAgICB2YXIgYXN5bmNGYWN0b3J5O1xuICAgICAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgICAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgICAgICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIHRhZ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gICAgICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAgICAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgICAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgICAgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgICAgICAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAgICAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgICAgICAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gICAgICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gICAgICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgICAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgICAgICAgICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgICAgICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gICAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gICAgICAgIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICAgICAgICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgICAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgICAgICAgICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICAgICAgICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgICAgICAgICBhc3luY0ZhY3RvcnlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgICAgICAgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gICAgICAgIHZub2RlLFxuICAgICAgICAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgICAgICAgcGFyZW50XG4gICAgKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICAgICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gICAgICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgICAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgICAgICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICAgICAgICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICAgICAgICAgIGYxKGEsIGIpO1xuICAgICAgICAgICAgZjIoYSwgYik7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZFxuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbiAgICAvLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICAgICAgICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgICAgICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICAgICAgICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICAgICAgICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgICAgICAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICB2YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG4gICAgdmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4gICAgLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2VcbiAgICAvLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdGFnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGUsXG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZVxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgICAgICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgICAgICAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdGFnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGVcbiAgICApIHtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICAgICAgICAgIHRhZyA9IGRhdGEuaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWcpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICAgICAgfVxuICAgICAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICAgICAgICkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZSwgbnM7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIEN0b3I7XG4gICAgICAgICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJiBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgICAgICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICAgICAgICB2bm9kZS5ucyA9IG5zO1xuICAgICAgICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgICAgICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlZiAjNTMxOFxuICAgIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4gICAgLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbiAgICBmdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgICAgICAgICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gICAgICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgICAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgICAgIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gICAgICAgIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAgICAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgICAgIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gICAgICAgIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgICAgIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICAgICAgICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAgICAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgICAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gICAgICAgIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAgICAgICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICAgICAgICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICAgICAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgICAgICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgICAgICAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICAgICAgICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICAgICAgICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgICAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgICAgICAgIHZhciB2bm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICAgICAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAgICAgICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgICAgICAgICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHBhcmVudFxuICAgICAgICAgICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgICAgICAgICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgICAgICAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgICAgICAgICA6IGNvbXBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgICAgICAgZmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICkge1xuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICAgICAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICAgICAgICByZXR1cm4gbm9kZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gICAgICAgIGZhY3RvcnksXG4gICAgICAgIGJhc2VDdG9yXG4gICAgKSB7XG4gICAgICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgICAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgICAgICAgICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgICAgICAgICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICAgICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgICAgICAgICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICAgICAgICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgICAgICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAgICAgICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICAgICAgICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICAgICAgICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgICAgICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgICAgICAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICAgICAgICB2bSxcbiAgICAgICAgbGlzdGVuZXJzLFxuICAgICAgICBvbGRMaXN0ZW5lcnNcbiAgICApIHtcbiAgICAgICAgdGFyZ2V0ID0gdm07XG4gICAgICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgICAgICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgICAgICAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICAgICAgICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm1cbiAgICAgICAgfTtcblxuICAgICAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgICAgICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbi5mbiA9IGZuO1xuICAgICAgICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICAgICAgICByZXR1cm4gdm1cbiAgICAgICAgfTtcblxuICAgICAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gYWxsXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2bVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICAgICAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmICghY2JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB2bVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICAgICAgdmFyIGNiO1xuICAgICAgICAgICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZtXG4gICAgICAgIH07XG5cbiAgICAgICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgICAgICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgICAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gICAgICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgICAgICAgdm0uJGNoaWxkcmVuID0gW107XG4gICAgICAgIHZtLiRyZWZzID0ge307XG5cbiAgICAgICAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICAgICAgICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICAgICAgICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgICAgICAgICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgICAgICAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgICAgICAgICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzXG4gICAgICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmIChwcmV2RWwpIHtcbiAgICAgICAgICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICAgICAgICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICAgICAgICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgICAgICAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICAgICAgICB9O1xuXG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgICAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICAgICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICAgICAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICAgICAgICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgICAgICAgICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgICAgICAgICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgICAgICAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgICAgICAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgICAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICAgICAgICAgIHZtLiRvZmYoKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICAgICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICAgICAgICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gICAgICAgIHZtLFxuICAgICAgICBlbCxcbiAgICAgICAgaHlkcmF0aW5nXG4gICAgKSB7XG4gICAgICAgIHZtLiRlbCA9IGVsO1xuICAgICAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgICAgICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gICAgICAgIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgICAgICAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gICAgICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICAgICAgICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gICAgICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gICAgICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gICAgICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gICAgICAgIHZtLFxuICAgICAgICBwcm9wc0RhdGEsXG4gICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgcGFyZW50Vm5vZGUsXG4gICAgICAgIHJlbmRlckNoaWxkcmVuXG4gICAgKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgICAgICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAgICAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gICAgICAgIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gICAgICAgIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgICAgICAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgICAgICAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgICAgICAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxuICAgICAgICAgICAgKCFuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gICAgICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgICAgICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgICAgICAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICAgICAgICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICAgICAgICk7XG5cbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgICAgIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgICAgICAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgICAgICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgICAgICB9XG4gICAgICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAgICAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgICAgICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgICAgICAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgICAgICAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAgICAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICAgICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICAgICAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAgICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gICAgICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gICAgICAgIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgICAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gICAgICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgICAgICAgICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgICAgICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICAgICAgICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgICAgICAgICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICAgICAgICB9XG4gICAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgaGFzID0ge307XG4gICAgdmFyIGNpcmN1bGFyID0ge307XG4gICAgdmFyIHdhaXRpbmcgPSBmYWxzZTtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICAgICAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhcyA9IHt9O1xuICAgICAgICB7XG4gICAgICAgICAgICBjaXJjdWxhciA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAvLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbiAgICAvLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuICAgIC8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxuICAgIHZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4gICAgLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbiAgICB2YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuICAgIC8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4gICAgLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4gICAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuICAgIC8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG4gICAgaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICAgICAgICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlICYmXG4gICAgICAgICAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcFxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVyIHRpbWVzdGFtcHMgYXNcbiAgICAgICAgICAgIC8vIHdlbGwuXG4gICAgICAgICAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICAgICAgICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgICAgICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAgICAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgICAgICAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAgICAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgICAgIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gICAgICAgIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgICAgICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gICAgICAgIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAgICAgICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICAgICAgICAgIGhhc1tpZF0gPSBudWxsO1xuICAgICAgICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgICAgICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICAgICAgICAgIGlmIChoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICAgICAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICAgICAgICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgICAgICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gICAgICAgIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAgICAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgICAgICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgICAgICAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gICAgICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAgICAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gICAgICAgIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gICAgICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAgICAgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAgICAgKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgICAgICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICAgICAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgICAgICAgICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG5cblxuICAgIHZhciB1aWQkMiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAgICAgKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICAgICAqL1xuICAgIHZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gICAgICAgIHZtLFxuICAgICAgICBleHBPckZuLFxuICAgICAgICBjYixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNSZW5kZXJXYXRjaGVyXG4gICAgKSB7XG4gICAgICAgIHRoaXMudm0gPSB2bTtcbiAgICAgICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICAgICAgICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgICAgICAgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgICAgICAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNiID0gY2I7XG4gICAgICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgICAgICAgdGhpcy5kZXBzID0gW107XG4gICAgICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgICAgICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgICAgICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICAgICAgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB0aGlzLmdldCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAgICovXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgdm0gPSB0aGlzLnZtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBXYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICAgICAgICB2YXIgaWQgPSBkZXAuaWQ7XG4gICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICAgICAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgICAgICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICAgICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgICAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5kZWVwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gICAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgICAqL1xuICAgIFdhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICAgKi9cbiAgICBXYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAgICAgKi9cbiAgICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAgICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBub29wLFxuICAgICAgICBzZXQ6IG5vb3BcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICAgICAgICB9O1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgICAgICAgICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gICAgICAgIHZtLl93YXRjaGVycyA9IFtdO1xuICAgICAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgICAgICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gICAgICAgIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgICAgICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgICAgICAgaW5pdERhdGEodm0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgICAgICAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICAgICAgICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gICAgICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgICAgIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICAgICAgICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICAgICAgICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICAgICAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAgICAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgICAgICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgICAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICAgICAgICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgICAgICAgICAgOiBkYXRhIHx8IHt9O1xuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAgICAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gICAgICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICAgICAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gICAgICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgICAgICAgcHVzaFRhcmdldCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgICAgICAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNTU1IpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgICAgICAgICAgICAgdm0sXG4gICAgICAgICAgICAgICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICAgICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgICAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgICAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5tZXRob2RzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5tZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBtZXRob2QuXCIpLCB2bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleSxcbiAgICAgICAgdXNlckRlZlxuICAgICkge1xuICAgICAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICAgICAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgICAgICAgICAgICA6IG5vb3A7XG4gICAgICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgICAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICAgICAgICB2bSxcbiAgICAgICAgZXhwT3JGbixcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gICAgICAgIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAgICAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAgICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgICAgICB2YXIgZGF0YURlZiA9IHt9O1xuICAgICAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgICAgICAgdmFyIHByb3BzRGVmID0ge307XG4gICAgICAgIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICAgICAgICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICAgICAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIGV4cE9yRm4sXG4gICAgICAgICAgICBjYixcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiO1xuICAgICAgICAgICAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xuICAgICAgICAgICAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHVpZCQzID0gMDtcblxuICAgIGZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgICAgICAgIC8vIGEgdWlkXG4gICAgICAgICAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgICAgICAgICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgICAgICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICAgICAgICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgICAgICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgICAgICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgICAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgICAgICAgICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgICAgICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICAgICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgICAgICAgICAgaW5pdFN0YXRlKHZtKTtcbiAgICAgICAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgICAgICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICAgICAgICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAgICAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgICAgICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICAgICAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICAgICAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICAgICAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgICAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgICAgICAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgICAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICAgICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICAgICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgICAgICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgICAgICAgICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgICAgICAgICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgICAgICAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICAgICAgICB2YXIgbW9kaWZpZWQ7XG4gICAgICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICAgICAgICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaW5pdE1peGluKFZ1ZSk7XG4gICAgc3RhdGVNaXhpbihWdWUpO1xuICAgIGV2ZW50c01peGluKFZ1ZSk7XG4gICAgbGlmZWN5Y2xlTWl4aW4oVnVlKTtcbiAgICByZW5kZXJNaXhpbihWdWUpO1xuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgICAgICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gICAgICAgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAgICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgICAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBWdWUuY2lkID0gMDtcbiAgICAgICAgdmFyIGNpZCA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICAgICAgICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgICAgICAgICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgICAgICAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgICAgICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgICAgICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgICAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAgICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgICAgICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgICAgICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgICAgICAgICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgICAgICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAgICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICAgICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAgICAgICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgICAgICAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgICAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICAgICAgICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICAgICAgICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICAgICAgICAgIHJldHVybiBTdWJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICAgICAgICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICAgICAgICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gICAgICAgIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZW50cnkubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXksXG4gICAgICAgIGtleXMsXG4gICAgICAgIGN1cnJlbnRcbiAgICApIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgICAgICAgICAgZW50cnkuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG4gICAgdmFyIEtlZXBBbGl2ZSA9IHtcbiAgICAgICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcblxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgY2FjaGVWTm9kZTogZnVuY3Rpb24gY2FjaGVWTm9kZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSByZWYua2V5cztcbiAgICAgICAgICAgICAgICB2YXIgdm5vZGVUb0NhY2hlID0gcmVmLnZub2RlVG9DYWNoZTtcbiAgICAgICAgICAgICAgICB2YXIga2V5VG9DYWNoZSA9IHJlZi5rZXlUb0NhY2hlO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHZub2RlVG9DYWNoZS50YWc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZVRvQ2FjaGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVba2V5VG9DYWNoZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZTogY29tcG9uZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXlUb0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgICAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgICAgICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICAgICAgICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5IHNldHRpbmcgdGhlIGNhY2hlIHVudGlsIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IHZub2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleVRvQ2FjaGUgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgICAgICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgICAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAgICAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgICAgICAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gICAgICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gICAgICAgIFZ1ZS51dGlsID0ge1xuICAgICAgICAgICAgd2Fybjogd2FybixcbiAgICAgICAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgICAgICAgfTtcblxuICAgICAgICBWdWUuc2V0ID0gc2V0O1xuICAgICAgICBWdWUuZGVsZXRlID0gZGVsO1xuICAgICAgICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAgICAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICAgICAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYnNlcnZlKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH07XG5cbiAgICAgICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAgICAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gICAgICAgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gICAgICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgICAgICAgaW5pdFVzZShWdWUpO1xuICAgICAgICBpbml0TWl4aW4kMShWdWUpO1xuICAgICAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgICAgIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xuICAgIH1cblxuICAgIGluaXRHbG9iYWxBUEkoVnVlKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICAgICAgICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICAgICAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbiAgICB9KTtcblxuICAgIFZ1ZS52ZXJzaW9uID0gJzIuNi4xNCc7XG5cbiAgICAvKiAgKi9cblxuICAgIC8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuICAgIC8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuICAgIHZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbiAgICAvLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG4gICAgdmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xuICAgIHZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgICAgICAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgICAgICAgICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgICAgICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgdmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuICAgIHZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbiAgICB2YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgICAgICAgPyAnZmFsc2UnXG4gICAgICAgICAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgICAgICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogJ3RydWUnXG4gICAgfTtcblxuICAgIHZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgICAgICAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgICAgICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICAgICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAgICAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAgICAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgICAgICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4gICAgKTtcblxuICAgIHZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG4gICAgdmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG4gICAgfTtcblxuICAgIHZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbiAgICB9O1xuXG4gICAgdmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG4gICAgfTtcblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgICAgICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgICAgICAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICAgICAgICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgICAgICAgc3RhdGljQ2xhc3MsXG4gICAgICAgIGR5bmFtaWNDbGFzc1xuICAgICkge1xuICAgICAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSAnJztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgICAgICAgICAgIHJlcyArPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgICAgICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbiAgICB9O1xuXG4gICAgdmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICAgICAgICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgICAgICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAgICAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAgICAgICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAgICAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgICAgICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgICAgICAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAgICAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAgICAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICAgICAgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICAgICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuICAgICk7XG5cbiAgICAvLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbiAgICAvLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuICAgIHZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICAgICAgICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgICAgICdmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgICAgICAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgICAgICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3ZnJ1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAgICAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgICAgICAgICAgcmV0dXJuICdtYXRoJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgICAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgICAgICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICAgICAgICAgKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4gICAgLyogICovXG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICAgICAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxtXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgICAgICAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsbVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50YWdOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgICAgICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgICAgIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgICAgICAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgICAgICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgICAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgICAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICAgICAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxuICAgIH0pO1xuXG4gICAgLyogICovXG5cbiAgICB2YXIgcmVmID0ge1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgICAgICAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICAgICAgICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICAgICAgICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICAgICAgICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICAgICAgICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICAgICAgICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgICAgICAgICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAgICAgKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICpcbiAgICAgKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAgICAgKlxuICAgICAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAgICAgKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAgICAgKi9cblxuICAgIHZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbiAgICB2YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuICAgIGZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiYgKFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgICAgICAgICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgICAgICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICAgICAgICAgICApIHx8IChcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgICAgICAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gICAgICAgIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gICAgICAgIHZhciBpLCBrZXk7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgICAgICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gICAgICAgIHZhciBpLCBqO1xuICAgICAgICB2YXIgY2JzID0ge307XG5cbiAgICAgICAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gICAgICAgIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlJCQxXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgICAgICAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICAgICAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgIWluVlByZSAmJlxuICAgICAgICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgICAgICByZWZFbG0sXG4gICAgICAgICAgICBuZXN0ZWQsXG4gICAgICAgICAgICBvd25lckFycmF5LFxuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgICAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICAgICAgICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgICAgICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICAgICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICAgICAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICAgICAgICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAgICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgICAgICAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAgICAgICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgICAgICAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgICAgICAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICAgICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAgICAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgICAgICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAgICAgIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICAgICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgICAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgICAgICAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgICAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgICAgICAgICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICAgICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAgICAgICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgICAgICAgICAgb2xkVm5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAgIG93bmVyQXJyYXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZU9ubHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgICAgICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAgICAgICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgICAgICAgICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgICAgICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgICAgICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gICAgICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAgICAgICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgICAgICAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAgICAgICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICAgICAgICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgICAgICAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAgICAgICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlLmVsbVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICAgICAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgICAgIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICAgICAgICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICAgICAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgICAgIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICAgICAgICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICAgICAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICAgICAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgICAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgICAgICAgICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgICAgICAgICAgaWYgKCFvbGREaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgICAgICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgICAgICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgICAgICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbEluc2VydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgICAgICAgZGlycyxcbiAgICAgICAgdm1cbiAgICApIHtcbiAgICAgICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmICghZGlycykge1xuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICByZXR1cm4gcmVzXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGksIGRpcjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICAgICAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgICAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gICAgICAgIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgICAgICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYXNlTW9kdWxlcyA9IFtcbiAgICAgICAgcmVmLFxuICAgICAgICBkaXJlY3RpdmVzXG4gICAgXTtcblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgICAgICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgICAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICAgICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICAgICAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1ciwgdm5vZGUuZGF0YS5wcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gICAgICAgIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgICAgICAgICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICAgICAgICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICAgICAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgICAgICAgICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICAgICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgICAgICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICAgICAgICAgICAgICA/ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICA6IGtleTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAgICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlQXR0cnNcbiAgICB9O1xuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICAgICAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICAgICAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICAgICAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGNsYXNzXG4gICAgICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IHtcbiAgICAgICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVDbGFzc1xuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICAgICAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gICAgICAgIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICAgICAgICB2YXIgY3VybHkgPSAwO1xuICAgICAgICB2YXIgc3F1YXJlID0gMDtcbiAgICAgICAgdmFyIHBhcmVuID0gMDtcbiAgICAgICAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gICAgICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByZXYgPSBjO1xuICAgICAgICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICAgICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAgICAgICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgICAgICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICAgICAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIGZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICAgICAgICBtb2R1bGVzLFxuICAgICAgICBrZXlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgICAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgICAgICAgOiBbXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICAgICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGR5bmFtaWNcbiAgICAgICAgICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgICAgICAgICAgOiAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKTtcbiAgICAgICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbiAgICBmdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gICAgICAgIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gICAgICAgIGVsLFxuICAgICAgICBuYW1lLFxuICAgICAgICByYXdOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXJnLFxuICAgICAgICBpc0R5bmFtaWNBcmcsXG4gICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgcmFuZ2VcbiAgICApIHtcbiAgICAgICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgICAgIH0sIHJhbmdlKSk7XG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIGR5bmFtaWNcbiAgICAgICAgICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgICAgICAgICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gICAgICAgIGVsLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICBpbXBvcnRhbnQsXG4gICAgICAgIHdhcm4sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBkeW5hbWljXG4gICAgKSB7XG4gICAgICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgICAgICAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB3YXJuICYmXG4gICAgICAgICAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICAgICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgICAgICAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgICAgICAgICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J21vdXNldXAnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gICAgICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgICAgICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICAgICAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudHM7XG4gICAgICAgIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgICAgICAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICAgICAgICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xuICAgICAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICAgICAgICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICAgICAgZWwsXG4gICAgICAgIG5hbWVcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1iaW5kOicgKyBuYW1lXSB8fFxuICAgICAgICAgICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgICAgIGVsLFxuICAgICAgICBuYW1lLFxuICAgICAgICBnZXRTdGF0aWNcbiAgICApIHtcbiAgICAgICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICAgICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgICAgIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgICAvLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuICAgIC8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuICAgIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgICBmdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgICAgICAgZWwsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlbW92ZUZyb21NYXBcbiAgICApIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICAgICAgICBlbCxcbiAgICAgICAgbmFtZVxuICAgICkge1xuICAgICAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKG5hbWUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhbmdlU2V0SXRlbSAoXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHJhbmdlXG4gICAgKSB7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgICAgICAgZWwsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnNcbiAgICApIHtcbiAgICAgICAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgICAgICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICAgICAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgICAgICAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICAgICAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgICAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgICAgICAgZWwubW9kZWwgPSB7XG4gICAgICAgICAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgICAgICAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgICAgICAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXNzaWdubWVudFxuICAgICkge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgICAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxuICAgICAqXG4gICAgICogUG9zc2libGUgY2FzZXM6XG4gICAgICpcbiAgICAgKiAtIHRlc3RcbiAgICAgKiAtIHRlc3Rba2V5XVxuICAgICAqIC0gdGVzdFt0ZXN0MVtrZXldXVxuICAgICAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICAgICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgICAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgbGVuLCBzdHIsIGNociwgaW5kZXgkMSwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgICAgICAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gICAgICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgICAgICB2YWwgPSB2YWwudHJpbSgpO1xuICAgICAgICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgPSB2YWw7XG4gICAgICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgICAgICAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVvZiAoKSB7XG4gICAgICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICAgICAgICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgICAgIHZhciBpbkJyYWNrZXQgPSAxO1xuICAgICAgICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgICAgICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICAgICAgICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICAgICAgICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICAgICAgICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gICAgICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgICAgICAgIGNociA9IG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHdhcm4kMTtcblxuICAgIC8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbiAgICAvLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxuICAgIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICAgIHZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4gICAgZnVuY3Rpb24gbW9kZWwgKFxuICAgICAgICBlbCxcbiAgICAgICAgZGlyLFxuICAgICAgICBfd2FyblxuICAgICkge1xuICAgICAgICB3YXJuJDEgPSBfd2FybjtcbiAgICAgICAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICAgICAgdmFyIHRhZyA9IGVsLnRhZztcbiAgICAgICAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgICAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgICAgICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICAgICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgICAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gICAgICAgIGVsLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICAgICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgICAgIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICAgICAgICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgICAgICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICAgICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICAgICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgICAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAgICAgICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICAgICAgICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICAgICAgICAgIG51bGwsIHRydWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICAgICAgZWwsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnNcbiAgICApIHtcbiAgICAgICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgICAgICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICAgICAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gICAgICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgICAgICBlbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgICkge1xuICAgICAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgICAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICAgICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gICAgICAgIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgICAgICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgICAgICAgZWwsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnNcbiAgICApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gICAgICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAgICAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgICAgICAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgICAgICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgICAgICAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgICAgICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgICAgIHZhciB0cmltID0gcmVmLnRyaW07XG4gICAgICAgIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gICAgICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgICAgICAgID8gJ2NoYW5nZSdcbiAgICAgICAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICAgICAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgICAgICAgICAgICA6ICdpbnB1dCc7XG5cbiAgICAgICAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICAgICAgICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICAgICAgICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgICAgICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICAvLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4gICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAgIC8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbiAgICAvLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgICAgICAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgICAgICAgICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICAgICAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAgICAgICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgICAgICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCQxO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4gICAgLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuICAgIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgICB2YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuICAgIGZ1bmN0aW9uIGFkZCQxIChcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgcGFzc2l2ZVxuICAgICkge1xuICAgICAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgICAgICAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgICAgICAgICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgICAgICAgICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICAgICAgICAgICAgOiBjYXB0dXJlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICAgICAgICBuYW1lLFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBfdGFyZ2V0XG4gICAgKSB7XG4gICAgICAgIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgICAgICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgICAgICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgICAgICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICAgICAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHtcbiAgICAgICAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG4gICAgfTtcblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHN2Z0NvbnRhaW5lcjtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSwgY3VyO1xuICAgICAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgICAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICAgICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICAgICAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBlbG1ba2V5XSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAgICAgICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICAgICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgICAgICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgICAgICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICAgICAgICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgICAgICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgICAgICAgICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2Vzc2FyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgICAgICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuICAgIGZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gICAgICAgIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgICAgICAgICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgICAgICAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgICAgICAgICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgICAgICAgKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gICAgICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgICAgICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gICAgICAgIC8vICM2MTU3XG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgICAgICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gICAgICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuICAgIH1cblxuICAgIHZhciBkb21Qcm9wcyA9IHtcbiAgICAgICAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgICAgICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgICAgICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzXG4gICAgfSk7XG5cbiAgICAvLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gICAgICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgICAgICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICAgICAgICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgICAgICAgICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgICAgICAgICA6IHN0eWxlXG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nU3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gICAgICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB2YXIgc3R5bGVEYXRhO1xuXG4gICAgICAgIGlmIChjaGVja0NoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIGNzc1ZhclJFID0gL14tLS87XG4gICAgdmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG4gICAgdmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgICAgICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbiAgICB2YXIgZW1wdHlTdHlsZTtcbiAgICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICAgICAgICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gICAgICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gICAgICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICAgICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1ciwgbmFtZTtcbiAgICAgICAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICAgICAgICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgICAgICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAgICAgICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICAgICAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gICAgICAgIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgICAgICAvLyB0byBtdXRhdGUgaXQuXG4gICAgICAgIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgICAgICAgICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgICAgICAgICAgOiBzdHlsZTtcblxuICAgICAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgICAgICAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgICAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gICAgICAgIGlmICghZGVmJCQxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICAgICAgICAgIHJldHVybiByZXNcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICAgICAgICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICAgICAgICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgICAgICAgICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICAgICAgICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICAgICAgICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbiAgICB2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbiAgICB2YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbiAgICAvLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuICAgIHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG4gICAgdmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbiAgICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICAgICAgICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbiAgICB2YXIgcmFmID0gaW5Ccm93c2VyXG4gICAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgICAgICAgICAgOiBzZXRUaW1lb3V0XG4gICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICAgICAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmFmKGZuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICAgICAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICAgICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICAgICAgICBlbCxcbiAgICAgICAgZXhwZWN0ZWRUeXBlLFxuICAgICAgICBjYlxuICAgICkge1xuICAgICAgICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gICAgICAgIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICAgICAgICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICAgICAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgICAgIHZhciBlbmRlZCA9IDA7XG4gICAgICAgIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQgKyAxKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICAgICAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgICAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgICAgICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB2YXIgdGltZW91dCA9IDA7XG4gICAgICAgIHZhciBwcm9wQ291bnQgPSAwO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgICAgICAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgICAgICAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgICAgICAgfSkpXG4gICAgfVxuXG4gICAgLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuICAgIC8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbiAgICAvLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuICAgIC8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbiAgICBmdW5jdGlvbiB0b01zIChzKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gICAgICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgICAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgICAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICAgICAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWwuX2xlYXZlQ2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICAgICAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gICAgICAgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgICAgICAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gICAgICAgIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gICAgICAgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICAgICAgICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICAgICAgICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICAgICAgICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICAgICAgICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgICAgICAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgICAgICAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICAgICAgICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gICAgICAgIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gICAgICAgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgICAgICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gICAgICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgICAgICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAgICAgICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICAgICAgICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gICAgICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgICAgICAgICAgPyBhcHBlYXJDbGFzc1xuICAgICAgICAgICAgOiBlbnRlckNsYXNzO1xuICAgICAgICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgICAgICAgICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgICAgICAgICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICAgICAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICAgICAgICAgID8gYXBwZWFyVG9DbGFzc1xuICAgICAgICAgICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgICAgICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICAgICAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgICAgICAgICA6IGJlZm9yZUVudGVyO1xuICAgICAgICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgICAgICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICAgICAgICAgIDogZW50ZXI7XG4gICAgICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICAgICAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgICAgICAgICAgOiBhZnRlckVudGVyO1xuICAgICAgICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICAgICAgICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICAgICAgICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgICAgICAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgICAgICAgICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgICAgICAgICAgIDogZHVyYXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgICAgICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICAgICAgICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgICAgICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgICAgICAgICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gICAgICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgICAgICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICAgICAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgICAgICAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICAgICAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBybSgpXG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgICAgICAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICAgICAgICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgICAgICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICAgICAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgICAgICAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gICAgICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgICAgIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgICAgICAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgICAgICAgICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgICAgICAgICAgIDogZHVyYXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgICAgICAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICAgICAgICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbiAgICBmdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICAgICAgICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gICAgICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gICAgICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gICAgICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gICAgICAgIGlmIChpc1VuZGVmKGZuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gICAgICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgICAgICAgICAgLy8gaW52b2tlclxuICAgICAgICAgICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICAgICAgICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgICAgICAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZW50ZXIodm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgICAgIGNyZWF0ZTogX2VudGVyLFxuICAgICAgICBhY3RpdmF0ZTogX2VudGVyLFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IDoge307XG5cbiAgICB2YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICAgICAgICBhdHRycyxcbiAgICAgICAga2xhc3MsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgZG9tUHJvcHMsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICB0cmFuc2l0aW9uXG4gICAgXTtcblxuICAgIC8qICAqL1xuXG4gICAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gICAgLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICB2YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG4gICAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICAgICAqL1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUU5KSB7XG4gICAgICAgIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGlyZWN0aXZlID0ge1xuICAgICAgICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gIzY5MDNcbiAgICAgICAgICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgICAgICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgICAgICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgICAgICAgICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICAgICAgICAgID8gb3B0aW9uLl92YWx1ZVxuICAgICAgICAgICAgOiBvcHRpb24udmFsdWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgICAgICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gICAgICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgICAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICAgICAgICA6IHZub2RlXG4gICAgfVxuXG4gICAgdmFyIHNob3cgPSB7XG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICAgICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgb2xkVm5vZGUsXG4gICAgICAgICAgICBpc0Rlc3Ryb3lcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICAgICAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgICAgICAgc2hvdzogc2hvd1xuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxuICAgICAgICBjc3M6IEJvb2xlYW4sXG4gICAgICAgIG1vZGU6IFN0cmluZyxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gICAgICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICAgICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgICAgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICAgICAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICAgICAgICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG4gICAgfTtcblxuICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuICAgIC8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG4gICAgZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICAgICAgICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAgICAgICAvLyBwcm9wc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBldmVudHMuXG4gICAgICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgICAgICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgICAgICAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgICAgICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICAgICAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbiAgICB9XG5cbiAgICB2YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbiAgICB2YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxuICAgIHZhciBUcmFuc2l0aW9uID0ge1xuICAgICAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4gICAgICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgICAgIGFic3RyYWN0OiB0cnVlLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgICAgICAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgICAgICAgICAgaWYgKG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAgICAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgICAgICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdDaGlsZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAgICAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICAgICAgICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICAgICAgICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICAgICAgICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICAgICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgICAgICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICAgICAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9sZENoaWxkICYmXG4gICAgICAgICAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgICAgICAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAgICAgICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgICAgICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgICAgICAgICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogICovXG5cbiAgICB2YXIgcHJvcHMgPSBleHRlbmQoe1xuICAgICAgICB0YWc6IFN0cmluZyxcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgICB9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG4gICAgZGVsZXRlIHByb3BzLm1vZGU7XG5cbiAgICB2YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICAgICAgICBwcm9wczogcHJvcHMsXG5cbiAgICAgICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICAgICAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgICAgICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgICAgICAgICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgICAgICAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgICAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAgICAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgICAgICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICAgICAgICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgICAgICAgICBjLmVsbS5fZW50ZXJDYigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgICAgICAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgICAgICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgICAgIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICAgICAgICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICAgICAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICAgICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgICAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICAgICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICAgICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgICAgIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG4gICAgfTtcblxuICAgIC8qICAqL1xuXG4gICAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuICAgIFZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcbiAgICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICAgIFZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcbiAgICBWdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcbiAgICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4gICAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgICAvLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG4gICAgVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbiAgICAvLyBwdWJsaWMgbW91bnQgbWV0aG9kXG4gICAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgICAgIGVsLFxuICAgICAgICBoeWRyYXRpbmdcbiAgICApIHtcbiAgICAgICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICAgIH07XG5cbiAgICAvLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgICAgICAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuICAgIHZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxuICAgIHZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICAgICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbiAgICB9KTtcblxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZVRleHQgKFxuICAgICAgICB0ZXh0LFxuICAgICAgICBkZWxpbWl0ZXJzXG4gICAgKSB7XG4gICAgICAgIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICAgICAgICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFnIHRva2VuXG4gICAgICAgICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgICAgICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgICAgICAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICAgICAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gICAgICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgICAgICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICAgICAgaWYgKGNsYXNzQmluZGluZykge1xuICAgICAgICAgICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAnJztcbiAgICAgICAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgICAgICAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgICAgICAgICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIHZhciBrbGFzcyQxID0ge1xuICAgICAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gICAgICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgICAgIGdlbkRhdGE6IGdlbkRhdGFcbiAgICB9O1xuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgICAgICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICAgICAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICAgICAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICAgICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICAgIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgICAgICAgICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIHZhciBzdHlsZSQxID0ge1xuICAgICAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gICAgICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgICAgICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gICAgfTtcblxuICAgIC8qICAqL1xuXG4gICAgdmFyIGRlY29kZXI7XG5cbiAgICB2YXIgaGUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgICAgICAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogICovXG5cbiAgICB2YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICAgICAgICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgICAgICAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuICAgICk7XG5cbiAgICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbiAgICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gICAgdmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAgICAgICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbiAgICApO1xuXG4gICAgLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuICAgIC8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICAgIHZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgICAgICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAgICAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgICAgICAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAgICAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICAgICAndGl0bGUsdHIsdHJhY2snXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICAgICAqL1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICAgIHZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbiAgICB2YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rP1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gICAgdmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xuICAgIHZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG4gICAgdmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xuICAgIHZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG4gICAgdmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xuICAgIHZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4gICAgLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc3NlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbiAgICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgICB2YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbiAgICAvLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbiAgICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gICAgdmFyIHJlQ2FjaGUgPSB7fTtcblxuICAgIHZhciBkZWNvZGluZ01hcCA9IHtcbiAgICAgICAgJyZsdDsnOiAnPCcsXG4gICAgICAgICcmZ3Q7JzogJz4nLFxuICAgICAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAgICAgJyZhbXA7JzogJyYnLFxuICAgICAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAgICAgJyYjOTsnOiAnXFx0JyxcbiAgICAgICAgJyYjMzk7JzogXCInXCJcbiAgICB9O1xuICAgIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgICB2YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4gICAgLy8gIzU5OTJcbiAgICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gICAgdmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuICAgIGZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICAgICAgICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgICAgICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgICAgICAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBsYXN0LCBsYXN0VGFnO1xuICAgICAgICB3aGlsZSAoaHRtbCkge1xuICAgICAgICAgICAgbGFzdCA9IGh0bWw7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgICAgICAgICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICAgICAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIiksIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgICAgICAgcGFyc2VFbmRUYWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgICAgICAgICBpbmRleCArPSBuO1xuICAgICAgICAgICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgICAgICAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICAgICAgICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgICAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICAgICAgICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgICAgICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgICAgICAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQsIGVuZDogc3RhY2tbaV0uZW5kIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgICAgICAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIG9uUkUgPSAvXkB8XnYtb246LztcbiAgICB2YXIgZGlyUkUgPSAvXnYtfF5AfF46fF4jLztcbiAgICB2YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgICB2YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgICB2YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbiAgICB2YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG4gICAgdmFyIGFyZ1JFID0gLzooLiopJC87XG4gICAgdmFyIGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbiAgICB2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG4gICAgdmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG4gICAgdmFyIGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbiAgICB2YXIgd2hpdGVzcGFjZVJFJDEgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xuXG4gICAgdmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbiAgICB2YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4gICAgdmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuICAgIC8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuICAgIHZhciB3YXJuJDI7XG4gICAgdmFyIGRlbGltaXRlcnM7XG4gICAgdmFyIHRyYW5zZm9ybXM7XG4gICAgdmFyIHByZVRyYW5zZm9ybXM7XG4gICAgdmFyIHBvc3RUcmFuc2Zvcm1zO1xuICAgIHZhciBwbGF0Zm9ybUlzUHJlVGFnO1xuICAgIHZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xuICAgIHZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbiAgICB2YXIgbWF5YmVDb21wb25lbnQ7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgICAgICAgdGFnLFxuICAgICAgICBhdHRycyxcbiAgICAgICAgcGFyZW50XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgICAgICByYXdBdHRyc01hcDoge30sXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UgKFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgICAgICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICAgICAgICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICAgICAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAgICAgbWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhKFxuICAgICAgICAgICAgZWwuY29tcG9uZW50IHx8XG4gICAgICAgICAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcbiAgICAgICAgICAgIGVsLmF0dHJzTWFwWyd2LWJpbmQ6aXMnXSB8fFxuICAgICAgICAgICAgIShlbC5hdHRyc01hcC5pcyA/IGlzUmVzZXJ2ZWRUYWcoZWwuYXR0cnNNYXAuaXMpIDogaXNSZXNlcnZlZFRhZyhlbC50YWcpKVxuICAgICAgICApOyB9O1xuICAgICAgICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gICAgICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgICAgICAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gICAgICAgIHZhciByb290O1xuICAgICAgICB2YXIgY3VycmVudFBhcmVudDtcbiAgICAgICAgdmFyIGluVlByZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgICAgICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICAgICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgICAgICAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICAgICAgICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgICAgICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgICAgICAgICAgd2Fybjogd2FybiQyLFxuICAgICAgICAgICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgICAgICAgICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgICAgICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAvLyBwb3Agc3RhY2tcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGRpbmcgYW55dGhpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm9vdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gICAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5wcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICAgICAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2ldLmVuZCA9IGxpc3RbaV0uZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgICAgICAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBlbC5wbGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAgICAgICAgICFlbGVtZW50LmtleSAmJlxuICAgICAgICAgICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAgICAgICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gICAgICAgIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLmtleSA9IGV4cDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gICAgICAgIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBlbC5yZWYgPSByZWY7XG4gICAgICAgICAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgICAgICAgdmFyIGV4cDtcbiAgICAgICAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgICAgICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgICAgICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgICAgIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICAgICAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gICAgICAgIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBlbC5pZiA9IGV4cDtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICAgICAgICAgICAgZXhwOiBleHAsXG4gICAgICAgICAgICAgICAgYmxvY2s6IGVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICAgICAgICAgIGlmIChlbHNlaWYpIHtcbiAgICAgICAgICAgICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgICAgICAgICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgICAgICAgICAgICBibG9jazogZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiLFxuICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICAgICAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgICAgICAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gICAgICAgIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLm9uY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4gICAgLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICAgICAgICB2YXIgc2xvdFNjb3BlO1xuICAgICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHNsb3RTY29wZSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2xvdD1cInh4eFwiXG4gICAgICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgICAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICAgICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGUgcmVjZWl2aW5nIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWMgPSByZWYuZHluYW1pYztcbiAgICAgICAgICAgICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgICAgICAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICAgICAgICB2YXIgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgICAgICAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgICAgICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAgICAgICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgICAgICAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbiAgICBmdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgICAgICAgICAgaWYgKGVsLmtleSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgICAgICAgdmFyIGJpbmRpbmc7XG4gICAgICAgIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICAgICAgICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgICAgICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgICAgICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBtb2RpZmllcnNcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgICAgICAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsO1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgICAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBcbiAgICB9XG5cbiAgICAvLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbiAgICBmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAgICAgICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgICAgICAgICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgKSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuICAgIHZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9lbCA9IGVsO1xuICAgICAgICB3aGlsZSAoX2VsKSB7XG4gICAgICAgICAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2VsID0gX2VsLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgICAgICAgICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgICAgICAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgICAgICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICAgICAgICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgICAgICAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgICAgICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgICAgICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIDMuIG90aGVyXG4gICAgICAgICAgICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgICAgICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG4gICAgfVxuXG4gICAgdmFyIG1vZGVsJDEgPSB7XG4gICAgICAgIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbiAgICB9O1xuXG4gICAgdmFyIG1vZHVsZXMkMSA9IFtcbiAgICAgICAga2xhc3MkMSxcbiAgICAgICAgc3R5bGUkMSxcbiAgICAgICAgbW9kZWwkMVxuICAgIF07XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICAgICAgICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgICAgICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaXJlY3RpdmVzJDEgPSB7XG4gICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaHRtbDogaHRtbFxuICAgIH07XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBiYXNlT3B0aW9ucyA9IHtcbiAgICAgICAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgICAgICAgbW9kdWxlczogbW9kdWxlcyQxLFxuICAgICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gICAgICAgIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgICAgICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICAgICAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICAgICAgICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICAgICAgICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICAgICAgICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgICAgICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG4gICAgfTtcblxuICAgIC8qICAqL1xuXG4gICAgdmFyIGlzU3RhdGljS2V5O1xuICAgIHZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbiAgICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gICAgLyoqXG4gICAgICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAgICAgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gICAgICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICAgICAqXG4gICAgICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICAgICAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAgICAgKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgICAgICAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gICAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAgICAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgICAgICAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAgICAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gICAgICAgIHJldHVybiBtYWtlTWFwKFxuICAgICAgICAgICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAgICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAgICAgICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAgICAgICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgICAgICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgICAgICAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAgICAgICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgICAgICAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgICAgICAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAgICAgICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAgICAgICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAgICAgICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgICAgICAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICAgICAgICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgICAgICAgKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XG4gICAgdmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbiAgICB2YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuICAgIC8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG4gICAgdmFyIGtleUNvZGVzID0ge1xuICAgICAgICBlc2M6IDI3LFxuICAgICAgICB0YWI6IDksXG4gICAgICAgIGVudGVyOiAxMyxcbiAgICAgICAgc3BhY2U6IDMyLFxuICAgICAgICB1cDogMzgsXG4gICAgICAgIGxlZnQ6IDM3LFxuICAgICAgICByaWdodDogMzksXG4gICAgICAgIGRvd246IDQwLFxuICAgICAgICAnZGVsZXRlJzogWzgsIDQ2XVxuICAgIH07XG5cbiAgICAvLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG4gICAgdmFyIGtleU5hbWVzID0ge1xuICAgICAgICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgICAgICAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgICAgICAgdGFiOiAnVGFiJyxcbiAgICAgICAgZW50ZXI6ICdFbnRlcicsXG4gICAgICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gICAgICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAgICAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgICAgICAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICAgICAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgICAgIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgICAgICAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAgICAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgICAgICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbiAgICB9O1xuXG4gICAgLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbiAgICAvLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuICAgIHZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG4gICAgdmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgICAgICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICAgICAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICAgICAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgICAgICAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gICAgICAgIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gICAgICAgIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgICAgICAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gICAgICAgIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gICAgICAgIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgICAgICAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGlzTmF0aXZlXG4gICAgKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gICAgICAgIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gICAgICAgIHZhciBkeW5hbWljSGFuZGxlcnMgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgICAgICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gICAgICAgIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgICAgICAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgICAgICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSkgOiBoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgICAgICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICAgICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIi5hcHBseShudWxsLCBhcmd1bWVudHMpXCIpXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikuYXBwbHkobnVsbCwgYXJndW1lbnRzKVwiKVxuICAgICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgICAgICAgICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAgICAgICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgICAgICAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgICAgICAgICAgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCJcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICAgICAgICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXlWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgICAgICAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgICAgICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgICAgICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgICAgICAgICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICAgICAgICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICBmdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgICAgICAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qICAqL1xuXG4gICAgdmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICAgICAgICBvbjogb24sXG4gICAgICAgIGJpbmQ6IGJpbmQkMSxcbiAgICAgICAgY2xvYWs6IG5vb3BcbiAgICB9O1xuXG4gICAgLyogICovXG5cblxuXG5cblxuICAgIHZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICAgICAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICAgICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgICAgIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gICAgICAgIHRoaXMub25jZUlkID0gMDtcbiAgICAgICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wcmUgPSBmYWxzZTtcbiAgICB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgICAgICAgYXN0LFxuICAgICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gICAgICAgIC8vIGZpeCAjMTE0ODMsIFJvb3QgbGV2ZWwgPHNjcmlwdD4gdGFncyBzaG91bGQgbm90IGJlIHJlbmRlcmVkLlxuICAgICAgICB2YXIgY29kZSA9IGFzdCA/IChhc3QudGFnID09PSAnc2NyaXB0JyA/ICdudWxsJyA6IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkpIDogJ19jKFwiZGl2XCIpJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgICAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICAgICAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICAgICAgICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gICAgICAgIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICAgICAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICAgICAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG4gICAgZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgICAgICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxuICAgICAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAgICAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgICAgICB2YXIgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgICAgICAgaWYgKGVsLnByZSkge1xuICAgICAgICAgICAgc3RhdGUucHJlID0gZWwucHJlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICAgICAgICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICAgICAgICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICAgIH1cblxuICAgIC8vIHYtb25jZVxuICAgIGZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICAgICAgICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICAgICAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgICAgICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbklmIChcbiAgICAgICAgZWwsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhbHRHZW4sXG4gICAgICAgIGFsdEVtcHR5XG4gICAgKSB7XG4gICAgICAgIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gICAgICAgIGNvbmRpdGlvbnMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhbHRHZW4sXG4gICAgICAgIGFsdEVtcHR5XG4gICAgKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgICAgICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICAgICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICA6IGVsLm9uY2VcbiAgICAgICAgICAgICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbkZvciAoXG4gICAgICAgIGVsLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgYWx0R2VuLFxuICAgICAgICBhbHRIZWxwZXJcbiAgICApIHtcbiAgICAgICAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgICAgICAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gICAgICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgICAgICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gICAgICAgIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICAgICAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICAgICAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgICFlbC5rZXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzdGF0ZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgICAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgICAgICAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgICAgICAgICAnfSknXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAneyc7XG5cbiAgICAgICAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgICAgICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICAgICAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gICAgICAgIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gICAgICAgIC8vIGtleVxuICAgICAgICBpZiAoZWwua2V5KSB7XG4gICAgICAgICAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZcbiAgICAgICAgaWYgKGVsLnJlZikge1xuICAgICAgICAgICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgICAgICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVcbiAgICAgICAgaWYgKGVsLnByZSkge1xuICAgICAgICAgICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gICAgICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICAgICAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIERPTSBwcm9wc1xuICAgICAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgICAgICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgICAgICAgICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzbG90IHRhcmdldFxuICAgICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gICAgICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NvcGVkIHNsb3RzXG4gICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgICAgICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICAgICAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5saW5lLXRlbXBsYXRlXG4gICAgICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAgICAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAgICAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAgICAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgICAgIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICAgICAgICAgIGRhdGEgPSBcIl9iKFwiICsgZGF0YSArIFwiLFxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiICsgKGdlblByb3BzKGVsLmR5bmFtaWNBdHRycykpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICAgICAgICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgICAgICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgICAgICAgICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICAgICAgICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgICAgICAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICAgICAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgICAgICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbikge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgICAgICAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gICAgICAgIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgc3RhdGUud2FybihcbiAgICAgICAgICAgICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgICAgICAgZWwsXG4gICAgICAgIHNsb3RzLFxuICAgICAgICBzdGF0ZVxuICAgICkge1xuICAgICAgICAvLyBieSBkZWZhdWx0IHNjb3BlZCBzbG90cyBhcmUgY29uc2lkZXJlZCBcInN0YWJsZVwiLCB0aGlzIGFsbG93cyBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgICAgICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgICAgICAvLyBmb3IgZXhhbXBsZSBpZiB0aGUgc2xvdCBjb250YWlucyBkeW5hbWljIG5hbWVzLCBoYXMgdi1pZiBvciB2LWZvciBvbiB0aGVtLi4uXG4gICAgICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gZWwuZm9yIHx8IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgICAgICAgICAgIHNsb3QuaWYgfHxcbiAgICAgICAgICAgICAgICBzbG90LmZvciB8fFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgICAgICAgICApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gICAgICAgIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gICAgICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gICAgICAgIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgICAgICAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gICAgICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAgICAgLy8gIzk0MzgsICM5NTA2XG4gICAgICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAgICAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgICAgIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5mb3JcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcblxuICAgICAgICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgICAgIHZhciBoYXNoID0gNTM4MTtcbiAgICAgICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgICAgICB3aGlsZShpKSB7XG4gICAgICAgICAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoID4+PiAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gICAgICAgIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gICAgICAgIGVsLFxuICAgICAgICBzdGF0ZVxuICAgICkge1xuICAgICAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICAgICAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gICAgICAgIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgICAgICAgICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICAgICAgICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICAgICAgICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gICAgICAgIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgICAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XG4gICAgICAgIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICAgICAgICBlbCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGNoZWNrU2tpcCxcbiAgICAgICAgYWx0R2VuRWxlbWVudCxcbiAgICAgICAgYWx0R2VuTm9kZVxuICAgICkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgICAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICAgICAgICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICAgICAgICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUkMSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlJDEpIDogJycpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuICAgIC8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4gICAgLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuICAgIC8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbiAgICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUNvbXBvbmVudFxuICAgICkge1xuICAgICAgICB2YXIgcmVzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gMjtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICAgICAgICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgICAgICAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgICAgICAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgICAgICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLGZ1bmN0aW9uKCl7cmV0dXJuIFwiICsgY2hpbGRyZW4gKyBcIn1cIikgOiAnJyk7XG4gICAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgICAgICAgICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICAgICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgICAgICAgfSk7IH0pKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgICAgICAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJlcyArPSBcIixudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZCQkMSkge1xuICAgICAgICAgICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcyArICcpJ1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbiAgICBmdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICBlbCxcbiAgICAgICAgc3RhdGVcbiAgICApIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICAgICAgICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICAgICAgICB2YXIgZHluYW1pY1Byb3BzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgICAgICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gIzM4OTUsICM0MjY4XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxuICAgIH1cblxuICAgIC8qICAqL1xuXG5cblxuICAgIC8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4gICAgLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuICAgIHZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICAgICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgICAgICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgICAgICAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4gICAgKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuICAgIC8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG4gICAgdmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgICAgICdkZWxldGUsdHlwZW9mLHZvaWQnXG4gICAgKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbiAgICAvLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG4gICAgdmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuICAgIC8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG4gICAgZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgICAgIHZhciBzdHJpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICAgICAgdmFyIGtleXdvcmRNYXRjaCA9IHN0cmlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICAgICAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0cmlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgICAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgICAgICAgaWRlbnQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHdhcm4sXG4gICAgICAgIHJhbmdlXG4gICAgKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogICovXG5cbiAgICB2YXIgcmFuZ2UgPSAyO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICApIHtcbiAgICAgICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICAgICAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiIFwiLCBwYWQpICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoJDEgPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICAgICAgICAgICAgbiA+Pj49IDE7XG4gICAgICAgICAgICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyogICovXG5cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm9vcFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBjYWNoZVxuICAgICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIDogdGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbXBpbGVcbiAgICAgICAgICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgICAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgICAgICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICAgICAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgICAgICAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICAgICAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgKi9cblxuICAgIC8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbiAgICAvLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4gICAgLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG4gICAgdmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3Q6IGFzdCxcbiAgICAgICAgICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qICAqL1xuXG4gICAgdmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBjb21waWxlID0gcmVmJDEuY29tcGlsZTtcbiAgICB2YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gICAgLyogICovXG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuICAgIHZhciBkaXY7XG4gICAgZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gICAgICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICAgICAgICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxuICAgIH1cblxuICAgIC8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG4gICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuICAgIC8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbiAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbiAgICAvKiAgKi9cblxuICAgIHZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgICAgICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxuICAgIH0pO1xuXG4gICAgdmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG4gICAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgICAgIGVsLFxuICAgICAgICBoeWRyYXRpbmdcbiAgICApIHtcbiAgICAgICAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICAgICAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgICAgICAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbiAgICByZXR1cm4gVnVlO1xuXG59KSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwiVnVlIiwiZW1wdHlPYmplY3QiLCJPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwidG9SYXdUeXBlIiwiY2FsbCIsInNsaWNlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJuIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiaXNQcm9taXNlIiwidGhlbiIsIkFycmF5IiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJtYXAiLCJjcmVhdGUiLCJsaXN0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsIkZ1bmN0aW9uIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImUiLCJEYXRlIiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiYXN5bmMiLCJfbGlmZWN5Y2xlSG9va3MiLCJ1bmljb2RlUmVnRXhwIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsIlJlZ0V4cCIsInNvdXJjZSIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsIndpbmRvdyIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwiaXNGRiIsIm1hdGNoIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJwdXNoIiwidWlkIiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5Iiwic29ydCIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsInBvcCIsIlZOb2RlIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwidGV4dCIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInBhcmVudCIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImRlZmluZVByb3BlcnRpZXMiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsInR5cGUiLCJrZXkkMSIsInByb3BzIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImhhdmVFeHBlY3RlZFR5cGVzIiwic29tZSIsInQiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwiZnVuY3Rpb25UeXBlQ2hlY2tSRSIsImlzU2FtZVR5cGUiLCJtZXNzYWdlIiwicmVjZWl2ZWRUeXBlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwic3R5bGVWYWx1ZSIsIk51bWJlciIsIkVYUExJQ0FCTEVfVFlQRVMiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsIl9oYW5kbGVkIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwic2V0SW1tZWRpYXRlIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsImV2ZW50IiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsIm5hbWUkMSIsImlzV2hpdGVzcGFjZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3RzIiwibm9ybWFsU2xvdHMiLCJwcmV2U2xvdHMiLCJoYXNOb3JtYWxTbG90cyIsImlzU3RhYmxlIiwiJHN0YWJsZSIsIiRrZXkiLCJfbm9ybWFsaXplZCIsIiRoYXNOb3JtYWwiLCJub3JtYWxpemVTY29wZWRTbG90Iiwia2V5JDIiLCJwcm94eU5vcm1hbFNsb3QiLCJwcm94eSIsInJlbmRlckxpc3QiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwicmVuZGVyU2xvdCIsImZhbGxiYWNrUmVuZGVyIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsIm5vZGVzIiwiJHNsb3RzIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImxvb3AiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsImh5cGhlbmF0ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsInRoaXMkMSIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImxpc3RlbmVycyIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsIl9wYXJlbnRWbm9kZSIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiJHZub2RlIiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJfcmVuZGVyIiwicmVmIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsIm93bmVyIiwib3duZXJzIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwic3luYyIsInRpbWVyTG9hZGluZyIsInRpbWVyVGltZW91dCIsIiRvbiIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwiY2xlYXJUaW1lb3V0IiwicmVqZWN0IiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJub3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJmaWx0ZXIiLCJlbnRyeSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNhY2hlVk5vZGUiLCJ2bm9kZVRvQ2FjaGUiLCJrZXlUb0NhY2hlIiwicGFyc2VJbnQiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInVwZGF0ZWQiLCJyZWYkMSIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsIm9ic2VydmFibGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUiLCJjb252ZXJ0RW51bWVyYXRlZFZhbHVlIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJhcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJpc0luUHJlIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicmFuZ2UiLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImR5bmFtaWMiLCJyYW5nZVNldEl0ZW0iLCJwbGFpbiIsImFkZEF0dHIiLCJkeW5hbWljQXR0cnMiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJpc0R5bmFtaWNBcmciLCJwcmVwZW5kTW9kaWZpZXJNYXJrZXIiLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldFJhd0JpbmRpbmdBdHRyIiwicmF3QXR0cnNNYXAiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ2YWx1ZSQxIiwidHlwZUJpbmRpbmciLCJiaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsImN1cnJlbnRUYXJnZXQiLCJvd25lckRvY3VtZW50IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwid2hpdGVzcGFjZVJFIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsIm91dHB1dFNvdXJjZVJhbmdlIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiZHluYW1pY0FyZ1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwic2xvdFJFIiwibGluZUJyZWFrUkUiLCJ3aGl0ZXNwYWNlUkUkMSIsImludmFsaWRBdHRyaWJ1dGVSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJlbXB0eVNsb3RTY29wZVRva2VuIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJtYXliZUNvbXBvbmVudCIsImNyZWF0ZUFTVEVsZW1lbnQiLCJtYWtlQXR0cnNNYXAiLCJwYXJzZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsIndoaXRlc3BhY2VPcHRpb24iLCJ3aGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY2xvc2VFbGVtZW50IiwiZWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJlbHNlaWYiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJzdGFydCQxIiwiZ3VhcmRJRVNWR0J1ZyIsImN1bXVsYXRlZCIsImlzRm9yYmlkZGVuVGFnIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsImVuZCQxIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdFRhcmdldER5bmFtaWMiLCJzbG90QmluZGluZyIsImdldFNsb3ROYW1lIiwic2xvdEJpbmRpbmckMSIsImR5bmFtaWMkMSIsInNsb3RDb250YWluZXIiLCJzbG90TmFtZSIsInN5bmNHZW4iLCJpc0R5bmFtaWMiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQxIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsImZuSW52b2tlUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwiZG93biIsImtleU5hbWVzIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwibmVlZHNLZXkiLCJnZW5lcmF0ZWRTbG90cyIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsIm5vcm1hbGl6YXRpb25UeXBlJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0cmlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwiY291bnQiLCJyZXBlYXQkMSIsImxpbmVMZW5ndGgiLCJwYWQiLCJsZW5ndGgkMSIsIm1pbiIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/vue.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/vue.js");
/******/ 	
/******/ })()
;